const totalData = [
    {
        "name": "1\n开篇：可视化介绍\n学习时长: 14分30秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>大家好，我们是蚂蚁集团体验技术部的可视化团队。今天，我们想和大家一起聊聊数据可视化。</p>\n<p>提到数据可视化，大家脑海里面可能会出现下面这些图表。的确，在很多人的印象里，数据可视化就等于制作美丽的图表，但其实数据可视化远不如此：“It's not just about making pretty pictures”。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a19825311de4b33a8fab2fd6cf2a1ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>那么接下来就给大家简单地介绍一下数据可视化这个年轻却又古老的领域，希望大家“宝山一游，不会空手而归”。</p>\n<h2 data-id=\"heading-0\">数据可视化是什么？</h2>\n<p>首先我们来通过一个经典的挑战来认识数据可视化：观察下面的表格数据，你能在短时间内判断出每一组数据的关系吗？</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2282434dc2524929bad00dd627f40653~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>相信直接看这些数据，大家内心或多或少都会有点崩溃；如果大家碰巧懂得统计学的一些知识，估计会更加崩溃：它们的单维度均值、最小二乘法回归线方程、误差的平方和、方差的回归和、均方误差的误差和、相关系数等统计属性均相同！</p>\n<p>但如果我们将上面的数据分布情况用下面这张图表示的话，相信大家可以迅速的从数据中发现它们不同的模式。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e554437a22b4bda9032b082885ff014~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>上面这种“<strong>将不可见或难以直接显示的数据转化为可感知的图形、符号、颜色、 纹理等，增强数据识别效率，传递有效信息</strong>”的手段就是数据可视化。</p>\n<p>浙江大学陈为教授的《数据可视化》这部书中是这样定义数据可视化的：<strong>利用人眼的感知能力对数据进行交互的可视表达以增强认知的技术</strong> 。接下来我们就深入了解一下定义中的“人眼的感知能力”和“增强认知”。</p>\n<h3 data-id=\"heading-1\">人眼的感知能力</h3>\n<p>“人眼的感知能力”，也就是我们平常说的视觉。不知道大家会不会和我有相同的疑问：视觉只是我们众多感觉中的一种，是什么让它脱颖而出，可以用来分析数据呢？这里列出两点比较重要的原因。</p>\n<p><strong>第一，在几种感官系统中，视觉系统获得信息是最高效的。</strong> 因为它可以并行处理视觉信息，比如你可以很迅速地从一片蓝色的点中找到一个红色的点。相比之下，耳朵只能线性地获得信息，而我们也从来没有听说过人的鼻子和嘴巴可以感知大量的复杂信息，对它们的探索还在一个很初始的阶段。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6360d8f8b8d9487a89c2e7f719235313~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p><strong>第二，图片可以加速人们查找和识别信息，因为信息会和空间信息相关联。</strong> 比如说，如果将有关联的事物放在一起，在不借助任何标签的情况下，我们也能轻易找到和识别这些事物，下面提到的元素周期表就是很好的例子。同时图片也很易于理解，就像很少有人能一眼看出一组数据的模式，但是小孩都能看懂条形图。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8d4fc0e517164b4f9dbde3092dc5a434~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h3 data-id=\"heading-2\">增强认知</h3>\n<p>基于这两个特点，我们可以把数据和视觉元素关联起来，通过视觉去高效获得视觉元素的特点，从而了解对应数据的特点，达到增强认知的效果。</p>\n<p>提到增强认知，这里就不得不注意了：<strong>不是所有的数据可视化都能到达增强认知的效果</strong>。比如下面两张图都是用折线图可视化任天堂游戏销售趋势，但是第一张图给人的感觉是他们的趋势异常稳定，第二张图却反映出在2016年6月左右他们有极高的提升。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1b468dc48d724b4b93b0c7cc19005877~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>出现这个问题的原因就是第一张图的 y 轴的范围设置的远远超过了数据的范围，出现了视觉上的偏差，这种可视化设计就是不好的：不仅仅没有达到增强认知的效果，还给大家带来了错误的认知。</p>\n<p>所以到底什么样的数据可视化才是能帮助我们增强认知的呢？更形象一点：什么样的数据可视化才能算的上是美丽的？在《Beautiful Visualization》里面将归纳了美丽的数据可视化的四个特点：新颖，充实，高效和美感。下面我们将用下面伦敦地铁图这个经典的案例来解释这4个特点：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/feeaab3c5feb47d8bc0c3e9f28fb2ede~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>伦敦地铁图的最大改变就是：<strong>把地图从准确代表地理特征的束缚释放出来了，线条不再是歪歪扭扭的，只有简单的直线和角度。</strong> 从传统歪歪扭扭的线条这种旧的风格，到直线和角度这种新的角度看数据，就是<strong>新颖</strong>。着重展示地铁站之间相对的逻辑关系，弱化地理关系，让人们弄明白下一步自己怎么走，而不是这条地铁线路到底是如何修的，简介的突出关键信息，这就是<strong>充实</strong>和<strong>高效。</strong> 合理利用简单的直线和角度来引导用户，揭示关系，这就是“美感”。</p>\n<p>当然上面的原则也不是绝对的。根据上面的高效原则我们需要尽量避免过多的装饰，但是<strong>信息图（Infographics)</strong> 的出现，让大家意识到装饰能提高用户的参与感，让用户更难忘。</p>\n<p>比如在下面展示世界上最高的建筑的信息图中，用建筑的图片替代了本来的条，虽然降低人们获得信息的效率，但是能让大家感到更有意思，印象更加深刻：也许多年以后你在回忆起这本小册子的时候，你啥都忘了，但是这张图还深深的印在你的脑海里！</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f70666191177462596ec0bc623798fe8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-3\">为什么要学习数据可视化</h2>\n<p>聊了这么多数据可视化是什么，那么我们为什么要学习数据可视化呢？数据可视化到底对我们的生活，工作和世界的发展到底有什么用？</p>\n<h3 data-id=\"heading-4\">时代背景</h3>\n<p>了解任何一个东西的作用都不应该脱离它的时代背景，毕竟俗话说的好：“时势造英雄”，所以我们首先在了解一下我们的时代背景。</p>\n<p>随着科技的发展，更多的数据被收集、存储和感知，我们真正进入了<strong>大数据时代</strong>。而大数据时代最值钱的是什么？当然是数据，更准确地说：应该是数据背后的信息，这些信息进行整理，又会形成知识和经验，从而帮助我们做决策。</p>\n<p>这个时候，也许就有人就要问了：在人工智能家喻户晓的时代，直接把数据分析交给机器不就好了吗？为什么还需要人的参与？这是因为在大多数情况下，人们面对数据不知道提出什么样的问题，甚至不能提前知道自己提的问题是否正确。这种时候，统计学和机器学习也无能为力。</p>\n<p>因此，在数据分析中，我们首先可以通过可视化提出需要研究的问题。在分析过程中，再用可视化去发现算法的问题以及参数对结果的影响，从而改进算法和任务。最后，我们还可以用可视化去展现分析结果，并且判断根据这个结果做的决策是否正确。</p>\n<p>在大数据时代的背景下，针对不同的数据类型和研究目的，数据可视化分为了三个主要分支：科学可视化、信息可视化和可视化分析学。</p>\n<p>接下来我们就分别来了解一下它们，看看我们日常生活中主要是在哪个分支上以及每个分支在工作中的主要应用场景，从而了解更多学习数据可视化的理由。</p>\n<h3 data-id=\"heading-5\">科学可视化</h3>\n<p>首先我们来看看可视化领域最早、最成熟的一个跨学科研究与应用的领域：<strong>科学可视化(scientifc visualization)</strong>。</p>\n<p>科学可视化主要可视化的是自然科学领域中一些具体的、非抽象的东西，比如医学领域的骨骼等影像数据，气象气候的洋流流动数据等。这些数据主要带有几何和空间信息，比如形状、位置等，重点探索如何有效地呈现其中的几何、拓扑和形状特征。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09c1beb4762c40ca93dec9da7656bc24~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>在日常生活中，我们都接触的比较少，接触它的更多是一些科学家和相关研究人员。</p>\n<h3 data-id=\"heading-6\">信息可视化</h3>\n<p>相对于科学可视化面向抽象数据数据，<strong>信息可视化(information visualization)</strong> 处理的对象是抽象的、非结构化数据。这些数据往往来源我们的日常生活：社交网络数据，疫情数据，销量数据，平常我们接触到的数据可视化几乎都是信息可视化。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaa9fd0e0b5f4cb38b6c2a2def24bc20~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>工作中信息可视化的具体场景这里提以下三个：移动端可视化，图可视化和地理可视化。</p>\n<p><strong>移动端可视化</strong>是在手机 APP、H5 或者小程序做数据可视化图表。移动端是大势所趋，几乎所有的线上应用，都有其对应的移动端，如何让用户更好的了解自己的数据或者在使用产品时产生的数据，这个就是移动端可视化需要考虑的问题了。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34ed10315d734deb913467fc871ddc0e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p><strong>图可视化</strong>主要是对网络数据的可视化，主要分为<strong>图分析</strong>和<strong>图编辑。</strong> 图分析用于风控、安全、营销场景中的关系发现，对图的一些基本概念进行业务上解读，环、关键链路、连通量等。<strong>图编辑</strong>用于图建模（ER图、UML图）、流程图、脑图等，需要用户深入参与关系的创建、编辑和删除的场景。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25b1c687760341adac1435032cc47ff9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p><strong>地理数据可视化</strong>主要是对空间数据域的可视化，主要有四大方向：</p>\n<ul>\n<li>信息图：主要用于展示位置相关的报表，信息图，路径变化等等。</li>\n</ul>\n\n<ul>\n<li>大屏应用：大屏展示一般以地理数据为载体，如建筑，道路，轨迹等数据可视化。</li>\n</ul>\n\n<ul>\n<li>地理分析应用:这类应用往往是海量地理数据的交互分析，用户基于位置的用户推荐，拉新，促活等业务运营系统，或者选址，风险监控等系统。</li>\n</ul>\n\n<ul>\n<li>移动端地图应用：路径规划，位置导航，一般是需要和PC联动，PC端地图侧重规划指挥，移动侧重作业执行。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af095aac7d75495b8be1973fe1f3f224~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h3 data-id=\"heading-7\">可视分析学</h3>\n<p>由于上面提到的在大数据时代数据分析的重要性，<strong>可视分析学(Visual Analytics)</strong> 就诞生了：可视化和分析结合的新领域，同时也涉及到图形学、数据挖掘和人机交互等领域。它往往以可视交互界面的形式给用户提供分析和可视化的能力，帮助用户做决策。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a9b0ff040d74f6d88e7194e03f92778~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>而可视分析在工作的运用场景主要有两个：BI 工具和大屏可视化。</p>\n<p>所谓的 <strong>BI 工具</strong>就是商业智能分析工具，是指使用一套方法和技术来准备、呈现和帮助分析数据的工具。比如有名的 PowerPI，Tableau 等等。对于 BI 工具来说，其中85% 以上的需求都是做通用报表的需求。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d008b9d774749dba5556d619b07c107~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p><strong>大屏可视化</strong>聚焦于会议展览、业务监控、风险预警、地理信息分析等多种业务的展示，在图形渲染、可视化设计方面都有很高的要求。比较有名的就是双十一时候的可视化大屏。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ca47411d566495294c622a211d015e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-8\">数据可视化学习的难点</h2>\n<p>讲到这里，大家应该对学习数据可视化很感兴趣了，但是学习数据可视化却不是一件容易的事情。一个比较完整的数据分析流程主要分为两大部分：<strong>设计和实现</strong>，每一部分都有对应的挑战。</p>\n<p><strong>设计</strong>的主要由认识数据，确认任务和设计方案构成。主要是根据数据提出想要探索的问题，并且提出解决方案。这个部分的挑战在于：什么样的数据适合讨论什么样的问题？众多设计方案之中哪一个才是最好的？</p>\n<p><strong>实现</strong>的主要由数据转换和数据绘制构成。首先需要抽象的数据转换成绘制需要的视觉形式数据，然后将视觉形式的数据绘制到屏幕上。这个部分的挑战在于有太多的工具可以选择，什么样的工具才是真正适合当前设计方案的？</p>\n<p>一方面来讲，国内高校传统的数据可视化课程更偏理论，更侧重设计，但是对实现却讲解甚少。这导致某些学生学习完成之后，面对市面上各种各样的数据可视化工具，不知道如何学习和选择。</p>\n<ul>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fd3%2Fd3\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/d3/d3\" ref=\"nofollow noopener noreferrer\">D3</a>，<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fecharts.apache.org%2Fzh%2Findex.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://echarts.apache.org/zh/index.html\" ref=\"nofollow noopener noreferrer\">ECharts</a>，<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fg2.antv.vision%2Fzh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://g2.antv.vision/zh\" ref=\"nofollow noopener noreferrer\">G2</a>，<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvega%2Fvega\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/vega/vega\" ref=\"nofollow noopener noreferrer\">Vega</a>，<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvega%2Fvega-lite\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/vega/vega-lite\" ref=\"nofollow noopener noreferrer\">Vega-lite</a> 都可以做可视化，到底选择哪个？</li>\n<li>D3 学习曲线那么高，怎么入门？</li>\n<li>ECharts 和 G2 一个是配置式的 API，一个是函数式 API，到底有哪些区别？</li>\n</ul>\n<p>另一方面现有的网课对理论的讲解比较薄弱，侧重于讲解实现部分，但也不完整。课程中数据绘制这部分占比较多，比如浏览器的绘制技术，性能优化的方法等。这导致学习完成之后，面对数据和任务也不知道选择什么可视化方法，一些基础概念也不清楚：比例尺，数据映射，分箱操作等等。</p>\n<p>比如我们在开发迭代 G2 的过程中，发现了许多用户有许多问题，就是因为对数据可视化中的图形语法不了解所导致的。</p>\n<ul>\n<li>Quantile，Threshold，Quantize 比例尺有啥区别？</li>\n<li>希望生成的坐标刻度是6个，但是为什么却生成了8个？</li>\n<li>nice 操作到底有什么用？</li>\n</ul>\n<p>为了图形语法能够普罗大众，所以我们简化了 API，增加了 G2Plot 项目。但是，从另一方面，我们也希望提升社区同学的可视化的理解广度，这是小册子的初衷。</p>\n<h2 data-id=\"heading-9\">小册子的优势</h2>\n<p>针对上面的问题，我们团队设计了这本小册子。为了保证内容能形象生动，不停留在理论，我们设计了一个真实的数据分析任务：<strong>可视化苏菲的世界</strong>。这个任务的具体细节会在后面讲解，小册子的内容分为三个部分，都围绕着“通过可视化苏菲的世界学习可视化”这个目的展开：</p>\n<ul>\n<li><strong>基础篇</strong>：首先会了解什么是“苏菲的世界”和数据可视化的流程（确定数据种类，任务等），然后基于此提出我们想要通过数据可视化解决的问题。这之后我们会不借助任何工具，学习如何基于浏览器的 Canvas 和 SVG 绘图技术绘制一个条形图，从而解决上面的其中一个问题。在这个过程中我们会发现开发一个简单的条形图就会很麻烦，于是我们会介绍图形语法以及它如何去简化这个流程。</li>\n<li><strong>实战篇：</strong> 为了提高我们解决问题的效率，这里会带大家从 0 到 1 不使用任何第三方库开发一个基于图形语法的图表库：<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow\" ref=\"nofollow noopener noreferrer\">Sparrow</a>。从搭建开发环境开始，到一些低层级的可视化模块（比例尺，坐标系等）的开发，最后在它们的基础上完成图形语法图表库。</li>\n<li><strong>分析篇</strong>：开发完了 Sparrow，我们将用它去解决上面的问题。但是在这个过程中我们会发现 Sparrow 的能力不足，有些问题它没有办法解决。于是这个时候我们就会用 AntV 里面一些成熟的图表库去解决剩余的问题，来看看一个图表库从 1 到 2 有哪些地方需要增强。</li>\n</ul>\n<p>除了丰富且完整的内容之外，我们有强大的写作阵容：基础篇和实战篇主要由由逍为和万木完成。两者除了都是 G2 的核心维护者之外，前者还是 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fantv.vision%2Fzh%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://antv.vision/zh/\" ref=\"nofollow noopener noreferrer\">AntV </a>的总架构师，在 BI 开发领域有丰富的开发经验；后者在 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fvast-challenge.github.io%2F2021%2Fdescription.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://vast-challenge.github.io/2021/description.html\" ref=\"nofollow noopener noreferrer\">Vast Challenge</a>，<a href=\"https://link.juejin.cn?target=http%3A%2F%2Fchinavis.org%2F2020%2Fchallenge.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"http://chinavis.org/2020/challenge.html\" ref=\"nofollow noopener noreferrer\">ChinaVis Challenge</a> 等挑战赛中多次获得不错成绩。分析篇由新茗，福晋和云极完成，三人分别是 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fg2plot.antv.vision%2Fzh%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://g2plot.antv.vision/zh/\" ref=\"nofollow noopener noreferrer\">G2Plot</a>，<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fcharts.ant.design%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://charts.ant.design/\" ref=\"nofollow noopener noreferrer\">Ant Desgin Charts</a> 和 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7Plot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7Plot\" ref=\"nofollow noopener noreferrer\">L7Plot</a> 的作者和核心维护者。</p>\n<p>学习理论最好的方法就是去动手解决一个实际的问题，了解一个“轮子”的最好方式就是去写一个“轮子”。如果你满足下面任何一点，那么这本小册子将是你最好的选择：</p>\n<ul>\n<li>对可视化和数据分析感兴趣，在日常学习或者工作中常常和它们接触，想深入了解。</li>\n<li>对前端或者前端工程化感兴趣，想开发一个完整的前端工具来练练手，熟悉其中的主要流程。</li>\n<li>想参与 G2 等开源社区的建设，却不知道从哪开始看代码。</li>\n<li>想参加 Vast Challenge ，ChinaVis Challenge 等数据分析的挑战赛，但是无从下手。</li>\n<li>想加入我们，但是怕通不过面试。</li>\n</ul>\n<p>那么，接下来就让我们从认识苏菲的世界和了解数据可视化的基本流程开始，一起加入这段有意思的旅程吧！</p>\n<blockquote>\n<p>参考资料</p>\n<ul>\n<li>数据可视化，陈为</li>\n<li>Visualization Analysis &amp; Design，Tamara Munzner</li>\n<li>Beautiful.Visualization，Julie Steele/&nbsp;Noah Iliinsky</li>\n<li>Data-Driven Guides: Supporting Expressive Design for Information Graphics，Nam Wook Kim, Eston Schweickart, Zhicheng Liu, Mira Dontcheva, Wilmot Li, Jovan Popovic, and Hanspeter Pfister</li>\n</ul>\n</blockquote><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "2\n基础：数据分析模型\n学习时长: 13分36秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>在开篇我们提到了我们的小册子将围绕着“可视化苏菲的世界”这个具体任务展开，这样可以让我们在一边学习理论的时候，一边用它们去解决实际的问题，加深我们对理论的记忆和理解。</p>\n<p>为了完成任务，我们首先要了解什么是“苏菲的世界”，知道它是什么，它的背景，以及它有什么特别的东西，从而找到我们的数据分析方向。</p>\n<p>在这之后，我们也许仍然不能提出具体的分析任务和相应的设计方案，所以我们将学习 Tamara Munzner 的 《Visualization Analysis &amp; Design》这本书中提到的数据分析模型，这个模型分为三个部分：<strong>认识数据、确定任务和设计方案</strong>。</p>\n<p>在学习模型的过程中，我们依据模型提供的理论去分析“苏菲的世界”，这样学以致用的模式也大大降低了学习抽象模型的难度。</p>\n<h2 data-id=\"heading-0\">苏菲的世界</h2>\n<p>《苏菲的世界》是挪威作家乔斯坦·贾德书写的一本享誉全球的儿童哲学读物，它描述了一名哲学家向一个叫苏菲的女孩传授哲学知识的过程，以这种童话故事的形式向我们讲述了西方哲学的历史。</p>\n<blockquote>\n<p>14岁的少女苏菲某天放学回家，收到了神秘的一封信——“你是谁？世界从哪里来？”与此同时，她收到一封古怪的明信片，上面的收件人是“请苏菲转交给席德（Hilde）”，邮戳来自黎巴嫩。</p>\n</blockquote>\n<blockquote>\n<p>从这一天开始，苏菲不断接到一些极不寻常的来信，世界像谜团一般在她眼底展开。她运用少女天生的悟性与后天知识，企图解开这些谜团.....</p>\n</blockquote>\n<p>哲学在大家的印象里面是抽象难懂的，而数据可视化的优势就是将抽象的东西变得形象，所以为什么我们不去可视化一下《苏菲的世界》中和哲学相关的一些东西，来改变大家对哲学的看法？有了这个想法，那么我们首先得确定一下分析方向，其实也就是哲学这个学科的主要研究对象。</p>\n<p>任何一门学科都有自己的主要研究对象，如果这个对象不存在了，那么这门学科就失去了研究的意义。比如经济学是研究稀缺性的，概率论是研究不确定性的，计算机（Computer Science）是研究计算的，狄杰斯特拉说过：\"Computer science should be called computing science, for the same reason why surgery is not called knife science.\"</p>\n<p>那么哲学主要研究对象是什么呢？答案是<strong>永恒的问题</strong>。永恒的问题不是“今天中午吃什么”，也不是“蚂蚁什么时候会上市”，这些问题在历史的长河里面显得太渺小了，不值得一代代人前仆后继的研究。像“世界从何而来”，“世界由什么搞成”等这种能跨越时空的问题才是永恒的问题。</p>\n<p>有了问题，就有回答问题的哲学家和答案，拥有相似观点的答案就会形成哲学流派，哲学的历史就围绕着问题缓缓拉开了帷幕。所以我们的数据分析任务将围绕着“永恒的问题”展开，于是我们从书中收集并整理了一些和“永恒的问题”相关的数据，包括这些问题本身、回答这些问题的哲学家和这些哲学家构成的流派，<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fvisualize-sophie-world%23%25E6%2595%25B0%25E6%258D%25AE\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/visualize-sophie-world#%E6%95%B0%E6%8D%AE\" ref=\"nofollow noopener noreferrer\">具体的</a><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fvisualize-sophie-world%23%25E6%2595%25B0%25E6%258D%25AE\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/visualize-sophie-world#%E6%95%B0%E6%8D%AE\" ref=\"nofollow noopener noreferrer\">数据</a><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fvisualize-sophie-world%23%25E6%2595%25B0%25E6%258D%25AE\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/visualize-sophie-world#%E6%95%B0%E6%8D%AE\" ref=\"nofollow noopener noreferrer\">可以看这里</a>。</p>\n<p>有了分析方向，接下来，我们就可以去学习分析模型并确定分析任务了。</p>\n<h2 data-id=\"heading-1\">认识数据：What</h2>\n<p>该模型的第一部分是认识数据，也就是认识我们可视化的对象：数据。</p>\n<p>认识数据的核心就是确定数据的类型，只有正确地认识数据类型才能选择正确的可视化方法。比如分类数据就应该用差别比较大的颜色去可视化，如果用连续的颜色去可视化就会带来错误的信息。现实生活的数据是复杂多层次的，不同的层次有不同的分类方法，这是认识数据的难点所在。</p>\n<p>总的来说数据分为三个层次：数据集、数据和属性，这里需要说明一下层次中的数据和前面提到的数据是不一样的：前面是一个统称，这里的是具体的实例。数据是由一些<strong>数据集（DataSet）</strong> 构成的，数据集又是由一条条<strong>数据（Data）</strong> 构成的，每一条数据是由<strong>属性（Attribute）</strong> 构成的。接下来我们就分别看看它们对应的类型。</p>\n<h3 data-id=\"heading-2\">数据集类型</h3>\n<p>在信息可视化中，数据集主要分为：<strong>表格（Table）</strong> 、<strong>网络（Network）</strong> 和<strong>几何（Geometry）</strong> 。下面是《Visualization Analysis &amp; Design》的一个解释它们的形象的插图。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52a7375441db4fed832f6b045dc09401~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>表格想必大家都不陌生，是由行（Row）和列（Col）构成。对于一个一维表格（Flat Table）来说，每一行是一个<strong>实体（</strong> <strong>Item</strong> <strong>）</strong> ，每一列是该实体的一个<strong>属性（Attribute</strong> <strong>）</strong> 。《苏菲的世界》数据集中的philosophers.json，schools.json 和 questions.json 都是表格，因为它们的每一行都代表了一个实体，这些实体分别是：哲学家、哲学流派、哲学问题。下面用 philosophers.json 中的一条哲学家实体举例：</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th><strong>id</strong></th><th><strong>name</strong></th><th><strong>birthday</strong></th><th><strong>last day</strong></th><th><strong>country</strong></th><th><strong>points</strong></th></tr></thead><tbody><tr><td>75</td><td>苏格拉底</td><td>-470</td><td>-399</td><td>雅典</td><td>[\"我只知道一件事情，那就是我一无所知\", \"…\"]</td></tr></tbody></table>\n<p>这表格的一行表示：编号 75 的哲学家名叫苏格拉底，他出生于雅典，生于公元前 470 年，死于公元前 399 年，他的其中一条哲学观点是：“我只知道一件事情，那就是我一无所知”。</p>\n<p>说完了表格，我们来看看网络数据。网络数据主要用来表示实体之间的关系，在网络中的实体往往被称作为<strong>节点（</strong> <strong>node</strong> <strong>）</strong> ，节点之间的关系被称作为<strong>链接（link）</strong> 。《苏菲的世界》数据集中的 relations.csv 就是一个网络，因为它有作为节点的哲学家和哲学流派，也有表示它们关系的链接。下面就是其中一条数据，我们以它为例：</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th><strong>from</strong></th><th><strong>to</strong></th><th><strong>type</strong></th></tr></thead><tbody><tr><td>151</td><td>66</td><td>0</td></tr></tbody></table>\n<p>上面的 from 和 to 分别代表两个节点的编号，其中编号为151的节点是哲学中的自然学派，编号为66的节点是哲学家泰利斯，type 为0表示这条链接是流派和哲学家的关系，也就是这条数据表示：泰利斯属于自然学派，也就是说他是一个自然学派的哲学家。</p>\n<p>聊完了网络数据，最后我们里看看几何数据。几何数据用构成这个东西的点的<strong>位置（Position）</strong> 去描述一个实体的形状，这些实体可能是点，线，平面等。在《苏菲的世界》数据集合中，country.json 就是一个几何数据，因为它描述了每个国家的位置和形状的数据。其中 <code>\"centroid\": [35.55686145836136, -17.30493389122804]</code> ，就是国家的位置经纬度数据。<code>coordinates\": []</code>里面的数据就是国家的形状数据。</p>\n<h3 data-id=\"heading-3\">数据类型</h3>\n<p>了解完数据集的类型，我们来看看构成它的数据的类型。其实在上面数据集类型的介绍中已经提到了不少类型了，那在信息可视化中，数据的主要种类是：<strong>实体（</strong> <strong>Item</strong> <strong>）</strong> 、<strong>链接（Link</strong>）、<strong>位置（Position）</strong> 和<strong>属性（Attribute）</strong> 。下面的插图展示了表示数据集和数据的之间的关系。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e5254a1dc5a439aac46de718770db32~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>实体是一个单独的个体，比如表格中的一行，网络中一个节点。可以是一个人，也可以是一只蚂蚁，上面的 <code>(75, '苏格拉底', -470, 399, '雅典', [\"我只知道一件事情...\"])</code> 其实就是一个实体，因为它描述了“苏格拉底”这个哲学家的一些基本信息。</p>\n<p>链接是实体之间的关系（Relationship），比如上面提到的 relations.csv 中的 <code>(151, 66, 0)</code>，因为它将对应编号的两个节点链接起来了，并且指明了链接的类型。</p>\n<p>位置是空间数据，描述二维或者三维空间的一个位置，比如上面提到的 country.csv 中的 <code>(38, 24)</code> 就是一个位置，因为它描述了雅典这个国家的地理位置。</p>\n<h3 data-id=\"heading-4\">属性类型</h3>\n<p>其实，不仅仅数据有类型，构成数据的属性同样有类型。</p>\n<p>属性是一个可以被测量、观察和记录的特性，所有的实体、链接和位置都由属性构成。属性又被称为<strong>变量（Variable）</strong> 或者<strong>数据维度（Data Dimension）</strong> 。</p>\n<p>属性可以分为<strong>分类属性（Categorical）</strong> 和<strong>可排序属性（Ordered）</strong> 。分类数据不能排序，比如对于上面任何一条哲学家的数据来说：name 和 country 不能排序，都算是分类属性。可排序的数据都具有显示的排序方法，比如 birthday 和 last day 可以直接根据年份大小排序，所以是可排序的数据。</p>\n<p>对于可排序的属性来讲，又可以分为<strong>序数属性（Ordinal）</strong> 和<strong>数值属性（Quantitative）</strong> 。序数属性本身不能通过计算来排序，但是存在一个约定俗成的排序方法，比如衣服的尺码，它们的排序规则就是：XXL &gt; XL &gt; L &gt; M &gt; S。相对来讲，数值属性可以直接通过计算来排序，比如上面提到的 birthday 和 last day 就可以直接根据年份大小排序。</p>\n<p>大家可以通过下面书中的插图感受一下它们的区别。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84f61bec6554482297a54b3d69ed6ef1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>对于可排序的属性来讲，它们还可以按照方向去排序：<strong>顺序属性（Sequential）</strong> 、<strong>发散属性（Diverging）</strong> 和<strong>周期属性（Cyclic）</strong> 。</p>\n<p>顺序属性往往有一个最大值和最小值，比如上面数据中的 id 属性，最大值是 171，最小值是 0。</p>\n<p>发散属性往往是两个方向相反的序列在一个零点相遇，比如上面的 birthday，因为年份分为公元前和公元后，是两个相反的序列，同时它们的零点就是公元零零年。周期属性在增加到一定程度之后就不会增加了，会回到原点，比如上面的 longitude 和 latitude 都是周期属性，因为它们增加到 180 度之后都会回到0度，也就是上面提到的原点。</p>\n<p>下面的书中的插图形象展示了它们的区别。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/861c93ab64094962b41f2bba18318b25~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-5\">确定任务：Why</h2>\n<p>当认识了手中的数据之后，接下来就是确定任务了，这也是我们数据模型的第二部分。</p>\n<p>在描述任务的时候往往会存在一个挑战：不同领域有不同的术语，但是在数据分析的层面它们其实表达是相同的意思。比如，一个问题是哲学家中寿命最长的是多少岁，另一个问题是回答中出现次数最多词的数量是多少？这两个看上去是两种不同的问题，但其实都是：发现属性的极值。</p>\n<p>所以我们需要一些确定的词去描述任务，去将这些任务一步步抽象，变成和领域知识没有关系的描述。这些词可以分成两个部分：<strong>行动（Action）</strong> 和<strong>目标（Target）</strong> 。</p>\n<h3 data-id=\"heading-6\">行动：Action</h3>\n<p>行动是动词，主要用来描述用户想要通过可视化达到的目的。这里主要介绍最常见的两种行动：发现（Discover）和展现（Present）。</p>\n<p>发现的主要目的是找到之前不知道的新信息或者知识。可以是提出一个新的假设，也可以是验证一个假设是否为正确。比如验证哲学家是否真的都是讨论永恒的问题？展现的主要目的就是让用户和信息之间进行交流，可以是用数据来讲故事。一个典型的例子就是新闻，PPT 或者博客里面的一些信息图。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e287b66173574438a1f8fc7739188563~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h3 data-id=\"heading-7\">目标：Target</h3>\n<p>有了行动，就可以看我们的目标了：目标是动词，是用户对数据感兴趣的方面，对于不同的数据类型可能会有不同的目标。</p>\n<p>对于所有种类的数据来说，这个目标可能会是数据的<strong>趋势（Trend）</strong> ：数据的模式，比如增加、减少等，也可能是数据的<strong>异常值（Outliers）</strong> ：那些不符合数据趋势的数据，也可能是数据的<strong>特征（Feature）</strong> ：数据的特殊结构。（可以参考下面的插图）</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db55624d4aba42d8810284335d5e9b2b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>对于单一属性来讲，我们可能会关心属性的<strong>分布（Distribution）</strong> 和<strong>极值（Extremes）</strong> ；对于多个属性来讲，我们可能关心的就是属性之间的<strong>依赖关系（Dependency）</strong> 、<strong>相关性（Correlation）</strong> 和<strong>相似性（Similarity）</strong> ；对于网络数据来讲，一般就会去探索它们的<strong>拓扑结构（Topology）</strong> ；对于几何数据来讲，我们一般关心的就是它们的<strong>形状（Shape）</strong> 。（可以参考下面的插图）</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d16109b52844351ac453e70e92594d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>根据上面提到的行动和目标，我们可以确定如下的任务。</p>\n<ol>\n<li>揭露中世纪是一个压抑的时代。（展现时代和哲学家数量的相关性和异常值）。</li>\n<li>证明哲学家谈论的都是一些永恒的问题。（展现哲学家观点的特征）。</li>\n<li>哲学家，哲学问题和流派的数量关系是怎样的？（展现哲学家，哲学问题和流派的数量的特征）。</li>\n<li>哲学问题，哲学家和流派的数量随着时间是如何变化的？（探索哲学问题，哲学家，流派的数量的趋势，以及它们和时间的依赖关系）。</li>\n<li>有多少哲学家的寿命超过了40岁，其中年龄最大和最小分别是多少？（探索哲学家寿命的分布和极值）。</li>\n<li>每个哲学家回答了哪些问题？每个问题有哪些哲学家回答了？哲学家和问题之间的关系又如何？（探索哲学家和问题——网络数据之间的拓扑结构）。</li>\n<li>每个流派有哪些哲学家？哪个流派的哲学家比较多？哪个比较少？（探索哲学家和流派——网络数据之间的拓扑结构）。</li>\n<li>哲学的中心是怎么变化的的？（哲学家聚集地点——几何数据的形状）。</li>\n</ol>\n<h2 data-id=\"heading-8\">设计方案：How</h2>\n<p>在清楚了任务或者问题之后，就应该去设计方案去解决问题了，这也是该数据模型的最后一部分。</p>\n<p>这个部分的挑战在于有太多的设计方案可以选择，哪一种才是简单又有效的，才是真正美丽的？就像上一章提到的那样，选择错误的设计方案，不仅不能提高信息传递的效率，还会传递错误信息。那么这篇文章中我们先看看一些基本的手段，在后面分析的部分再提出具体的设计方案。</p>\n<p>在设计一个可视化的时候，我们主要有多种基本手段比如：<strong>分面（Facet）</strong> ，<strong>操作（Manipulate）</strong> 和<strong>减少（Reduce）</strong> ，但是这里主要介绍<strong>编码（Encode）</strong> 这种方式。上一章节里面提到：“数据可视化将不可见或难以直接显示的数据转化为可感知的图形、符号、颜色、纹理等”，这个从数据到视觉元素的过程就是编码。</p>\n<p>编码过程主要有两个部分：<strong>布局（Arrange）</strong> 和<strong>映射（Map）</strong> 。布局的主要任务就是确定视觉元素在最后画布上的位置，映射的主要任务就是用视觉元素的属性去表示数据的属性。比如在条形图中，我们需要根据数据种类确定每一个条的位置，这就是布局，也需要根据数据的大小去确定每一个条的高度，这就是映射。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/444efa69122247d79ecb25cc8ef871cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>不同的布局和映射方法可以先简单看看上面的插图，这个地方只是简单， 后面我们会深入讨论。在接下来的章节中我们会用不同的可视化方法去解决上面提出的8个问题，在解决每个问题的过程中会带领大家更加深入的了解编码这个强有力的工具。</p>\n<h2 data-id=\"heading-9\">小结</h2>\n<p>这一章节我们首先认识了“苏菲的世界”，知道了哲学是研究永恒的问题的。然后通过学习一个由<strong>认识数据</strong>、<strong>确定任务</strong>和<strong>设计方案</strong>构成的数据分析模型（具体参考下面的思维导图）。我们用该模型去分析了“苏菲的世界”里面的数据，并且得到了分析任务和之后解决该这些问题的主要手段，同时也对该模型也有了比较深刻的理解。</p>\n<p>那么下一章我们就先通过条形图去解决其中一个问题，在这个过程中我们将学习到基本的数据处理方法和基于浏览的 Canvas2D 和 SVG 绘制技术。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b1e00dff4f2445398e10355b019b596~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<blockquote>\n<p>参考资料</p>\n<ul>\n<li>Visualization Analysis &amp; Design，Tamara Munzner</li>\n<li>苏菲的世界，乔斯坦·贾德</li>\n</ul>\n</blockquote><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "3\n基础：绘制一个条形图\n学习时长: 41分13秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>通过上一章节的学习，我们认识了“<strong>可视化苏菲世界</strong>”这个分析任务，学习了一个数据分析的模型，并且基于该模型提出了很多想要讨论的问题，甚至已经有了简单的设计手段。</p>\n<p>但是在一个完整的数据分析的流程中，我们还处于<strong>设计</strong>阶段 <strong>，</strong> 也就是还停留在理论阶段。因此，这一章节我们将进入<strong>实现</strong>阶段，选择一个问题进行讨论，完成可视化图表的选择，再在浏览器里把它用 Canvas2D 和 SVG 绘制出来，让你更完整和深入地理解数据可视化。</p>\n<p>学习是一个循序渐进的过程，所以我们先从一个比较简单的问题入手，来掌握整个<strong>实现</strong>的流程。基于简单的标准，我们选择的问题是：“哲学家、哲学问题和流派的数量关系是怎样的？”，所以我们去统计了“苏菲的世界”<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fvisualize-sophie-world%23%25E6%2595%25B0%25E6%258D%25AE\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/visualize-sophie-world#%E6%95%B0%E6%8D%AE\" ref=\"nofollow noopener noreferrer\">数据集</a>中哲学家、哲学问题和流派的数量，得到的结果如下：</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th><strong>name</strong></th><th><strong>value</strong></th></tr></thead><tbody><tr><td>questions</td><td>17</td></tr><tr><td>schools</td><td>25</td></tr><tr><td>philosophers</td><td>35</td></tr></tbody></table>\n<p>想要体现这三者的数量关系，按照通用的数据分析流程，我们需要经过方案设计、数据处理、数据渲染这几个步骤。接下来，我们分别来说。</p>\n<h2 data-id=\"heading-0\">设计方案</h2>\n<p>上一章节提到的数据分析的模型主要有三部分，我们就用这三个部分的理论来分析一下“哲学家，哲学问题和流派的数量关系是怎样的？”这个问题，从而得出的我们的设计方案。</p>\n<ul>\n<li><strong>认识数据</strong>：这个数据集是表格，每一条数据代表一个实体，每一个实体有明显两个属性：name 是分类属性，value 是一个数值属性。当然也有一个隐藏属性，就是它们在表格里面的索引属性：比 questions 的索引属性是 0， schools 的索引属性是 1，philosophers 的索引属性是 2，索引属性明显是分类属性。</li>\n<li><strong>确定任务</strong>：因为我们不知道它们的关系到底是咋样的，所以这是一个发现任务，对象是哲学家、哲学问题和流派的数量的特征。</li>\n<li><strong>设计方案</strong>：我们可以根据数据属性和任务的种类，去选择合适的可视化图表。一般来说，了解分类数据和数值属性的特征，最好的选择就是条形图。因为条水平方向的位置是分类属性，所以可以将同为分类属性的索引属性映射过去；因为同为数值属性，所以可以把 value 属性映射为条的高度；最后因为相同的道理，可以把 name 属性映射为条的颜色。</li>\n</ul>\n<p>提出设计方案之后，在正式开始写代码之前，因为小册子篇幅的限制，我们先来做几个约定，让我们在有限的篇幅内可以给大家讲解更多有价值的东西。</p>\n<h2 data-id=\"heading-1\">开发约定</h2>\n<p>这里我们先介绍两个开发约定：</p>\n<p><strong>第一，在介绍新代码块的时候，不会显式地说新建或者修改文件或者文件夹。</strong> 文章中的代码块中的顶部会有包含该代码块文件的地址，这个地址是相对项目根目录的。如果不存在对应的文件夹和文件，就自行新建对应的文件夹或者文件。否则，对该文件夹或者文件进行修改即可。</p>\n<p>比如我要加入以下的代码，因为目前项目中没有 <code>hello</code> 这个文件夹和 <code>index.js</code> 这个文件，所以需要新建它们，然后再增加以下的 <code>foo</code> 函数。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/hello/index.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'foo'</span>;\n}\n</code></pre>\n<p>第二，<strong>讲解内容很多会以注释的实行在代码中展现，不会单独说明</strong>。这样将需要实现的功能和对应的代码关联起来，一方面可以更加清楚功能的具体代码实现，另一方面也知道这段代码主要解决什么问题。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// index.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">foo</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'foo'</span>; <span class=\"hljs-comment\">// 让调用者知道这是一个 foo 函数</span>\n}\n</code></pre>\n<p>当然最后都会把完整且可以运行的代码存储的 Github 仓库分享给大家，大家可以将代码 Clone 下来学习一下。</p>\n<p>说了这么多废话，那么接下里我们正式进入开发环节。</p>\n<h2 data-id=\"heading-2\">数据处理</h2>\n<p>我们首先进入数据处理阶段，这个阶段的核心任务或者难点就是“如何把原始数据转换成可以直接绘制的数据？”，包括 “转换过程分为哪几个阶段？，我们接下来一点点来看。</p>\n<p>首先加入如下代码，用来声明我们要可视化的数据和画布的维度信息。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// ch03/barchart/canvas/index.js</span>\n\n<span class=\"hljs-keyword\">const</span> data = [\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"questions\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">17</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"schools\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">25</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"philosophers\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">35</span> },\n];\n\n<span class=\"hljs-keyword\">const</span> chartWidth = <span class=\"hljs-number\">480</span>; <span class=\"hljs-comment\">// 条形图的宽度</span>\n<span class=\"hljs-keyword\">const</span> chartHeight = <span class=\"hljs-number\">300</span>; <span class=\"hljs-comment\">// 条形图的高度</span>\n<span class=\"hljs-keyword\">const</span> margin = <span class=\"hljs-number\">15</span>; <span class=\"hljs-comment\">// 条形图的外边距</span>\n\n<span class=\"hljs-keyword\">const</span> containerWidth = chartWidth + margin * <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 容器的宽度</span>\n<span class=\"hljs-keyword\">const</span> containerHeight = chartHeight + margin * <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 容器的高度</span>\n</code></pre>\n<p>接下来我们把需要编码的属性对应的值提取出来。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// ch03/barchart/canvas/index.js</span>\n\n<span class=\"hljs-keyword\">const</span> names = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(data, <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">name</span>);\n<span class=\"hljs-keyword\">const</span> values = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(data, <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">value</span>);\n<span class=\"hljs-keyword\">const</span> indices = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(data, <span class=\"hljs-function\">(<span class=\"hljs-params\">_, i</span>) =&gt;</span> i);\n</code></pre>\n<h3 data-id=\"heading-3\">布局</h3>\n<p>这之后我们需要对每一个条进行布局，这个地方就是计算出每一个条的左下顶点的坐标。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// ch03/barchart/canvas/index.js</span>\n\n<span class=\"hljs-comment\">// 计算每一个条左下顶点的横坐标</span>\n<span class=\"hljs-comment\">// 位置和在数组里面的 index 有关</span>\n<span class=\"hljs-keyword\">const</span> step = chartWidth / names.<span class=\"hljs-property\">length</span>;\n<span class=\"hljs-keyword\">const</span> barWidth = step * <span class=\"hljs-number\">0.8</span>;\n<span class=\"hljs-keyword\">const</span> xs = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(indices, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> i * step);\n\n<span class=\"hljs-comment\">// 计算每一个条左下顶点的纵坐标</span>\n<span class=\"hljs-comment\">// 因为所有条底部都是对齐的，所以就是图表的高度</span>\n<span class=\"hljs-keyword\">const</span> y = chartHeight;\n</code></pre>\n<h3 data-id=\"heading-4\">映射</h3>\n<p>布局完成之后就来到了映射过程。这里我们需要把数据的 value 属性映射为条的高度，需要把数据的 name 属性映射为条的颜色。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// ch03/barchart/canvas/index.js</span>\n\n<span class=\"hljs-comment\">// 获得每一个条的高度</span>\n<span class=\"hljs-comment\">// 条的高度应该和 value 线性相关的</span>\n<span class=\"hljs-keyword\">const</span> vmax = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(...values);\n<span class=\"hljs-keyword\">const</span> barHeights = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(values, <span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =&gt;</span> chartHeight * (v / vmax));\n\n<span class=\"hljs-comment\">// 获得每一个条的颜色</span>\n<span class=\"hljs-keyword\">const</span> nameColor = {\n  <span class=\"hljs-attr\">questions</span>: <span class=\"hljs-string\">\"#5B8FF9\"</span>,\n  <span class=\"hljs-attr\">philosophers</span>: <span class=\"hljs-string\">\"#61DDAA\"</span>,\n  <span class=\"hljs-attr\">schools</span>: <span class=\"hljs-string\">\"#65789B\"</span>,\n};\n\n<span class=\"hljs-keyword\">const</span> colors = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(names, <span class=\"hljs-function\">(<span class=\"hljs-params\">name</span>) =&gt;</span> nameColor[name]);\n</code></pre>\n<h2 data-id=\"heading-5\">数据渲染</h2>\n<p>目前为止我们的数据已经处理完成了，接下来就进入到了数据渲染阶段。数据渲染阶段的核心任务就是是处理后的数据渲染到屏幕上了。</p>\n<p>这个阶段需要考虑：选择什么作为承载我们可视化结果的容器，同时选择什么样的绘制技术来渲染这些数据。往往面对不同的可视化需求，不同量级的数据，我们需要选择不同的渲染技术，渲染技术的选择和学习也是其中一个难点。</p>\n<p>毫无疑问，作为前端这个领域，承载我们可视化的结果容器就是现代浏览器。在现代浏览器中可以完成可视化的绘制技术至少有4个：HTML、Canvas2D、SVG、WebGL。HTML 的绘制不够灵活，WebGL 主要针对三维场景的可视化（虽然也可以进行二维可视化，我们之后会了解到），所有主流的 2D 可视化的绘制技术主要有两种： Canvas2D 和 SVG。</p>\n<p>Canvas2D 和 SVG 的使用方式不同，针对的场景也不同，接下来我们就分别说说。</p>\n<h3 data-id=\"heading-6\">Canvas2D</h3>\n<p>首先，我们来看看 Canvas2D。Canvas2D 是一种指令式的绘图系统，我们调用一些绘图指令，就可以在画布上绘制对应的视觉元素。我们接下来通过绘制一个矩形和 hello world 来看看 Canvas2D 的使用方式。</p>\n<p>首先新建一个名叫 canvas-demo 的文件夹，输入以下内容：</p>\n<p>（1）在 HTML 文件中声明一个画布。</p>\n<pre><code class=\"hljs language-html\" lang=\"html\"><span class=\"hljs-comment\">&lt;!-- ch03/canvas-demo/draw/index.html --&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 声明一个画布，之后的可视化主要在这里发生 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"canvas\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./index.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>（2）获得绘制上下文并且设置维度信息。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// ch03/canvas-demo/draw/index.js</span>\n\n<span class=\"hljs-comment\">// 获得 canvas 容器元素</span>\n<span class=\"hljs-keyword\">const</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">\"canvas\"</span>);\n\n<span class=\"hljs-comment\">// 设置 canvas 的样式宽高</span>\n<span class=\"hljs-comment\">// 样式宽高决定了 canvas 在画布上呈现的大小</span>\ncanvas.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">400</span> + <span class=\"hljs-string\">\"px\"</span>;\ncanvas.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">200</span> + <span class=\"hljs-string\">\"px\"</span>;\n\n<span class=\"hljs-comment\">// 设置 canvas 画布宽高</span>\n<span class=\"hljs-comment\">// 这个宽高是可以绘制区域的大小</span>\n<span class=\"hljs-comment\">// 样式宽高是默认等于画布宽高的</span>\ncanvas.<span class=\"hljs-property\">width</span> = <span class=\"hljs-number\">400</span>;\ncanvas.<span class=\"hljs-property\">height</span> = <span class=\"hljs-number\">200</span>;\n\n<span class=\"hljs-comment\">// 获得绘制的上下文</span>\n<span class=\"hljs-comment\">// 之后的 API 都是通过调用 context</span>\n<span class=\"hljs-keyword\">const</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">\"2d\"</span>);\n</code></pre>\n<p>（3）绘制视觉元素</p>\n<p>这里需要注意的 Canvas2D 的坐标系和我们课本里介绍的坐标系有点不同：它的原点是在左上角，x 轴是从左到右的，y 轴是从上到下的，大家可以参考下面的这张图。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b90635f20024320891f476b8e501c42~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// ch03/canvas-demo/draw/index.js</span>\n\n<span class=\"hljs-comment\">// 绘制一个矩形</span>\ncontext.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">\"red\"</span>; <span class=\"hljs-comment\">// 设置填充颜色</span>\ncontext.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">\"yellow\"</span>; <span class=\"hljs-comment\">// 设置边框的颜色</span>\ncontext.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// 设置边框的宽度</span>\ncontext.<span class=\"hljs-title function_\">strokeRect</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>); <span class=\"hljs-comment\">// 绘制边框</span>\ncontext.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">95</span>, <span class=\"hljs-number\">95</span>); <span class=\"hljs-comment\">// 绘制填充颜色</span>\n\n<span class=\"hljs-comment\">// 绘制一段文字</span>\ncontext.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">\"black\"</span>; <span class=\"hljs-comment\">// 设置文字的颜色</span>\ncontext.<span class=\"hljs-property\">font</span> = <span class=\"hljs-string\">\"25px PingFangSC-Regular, sans-serif\"</span>; <span class=\"hljs-comment\">// 设置文字的大小和字体</span>\ncontext.<span class=\"hljs-title function_\">fillText</span>(<span class=\"hljs-string\">\"hello world\"</span>, <span class=\"hljs-number\">150</span>, <span class=\"hljs-number\">100</span>); <span class=\"hljs-comment\">// 绘制文字</span>\n</code></pre>\n<p>最后的绘制效果如下：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/347615eb86084988abd46a8192cdd4d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>当然 Canvas2D 的能力肯定不止绘制矩形和文字，更多的基本图形：圆形、线段和路径这些我们之后会涉及，但绘制方式都大同小异。首先，我们设置一些绘制的样式，然后调用绘制命令来绘制拥有这些样式的视觉元素。所以其实 Canvas 的 API 主要分为两类，一类是设置状态的 API： <code>context.fillStyle = 'red'</code> ，另一类是绘制的 API：<code>context.fillRect(0, 0, 10, 10)</code> 。</p>\n<p>下面再介绍一下 Canvas2D 坐标变换能力，我们可以对其进行平移、缩放和旋转等坐标系变换操作，具体的使用方式和效果参考下面这个例子：</p>\n<pre><code class=\"hljs language-html\" lang=\"html\"><span class=\"hljs-comment\">&lt;!-- ch03/canvas-demo/transform/index.html --&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- 声明一个画布，之后的可视化主要在这里发生 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"canvas\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./index.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// ch03/canvas-demo/transform/index.js</span>\n\n<span class=\"hljs-comment\">/*\n * 这里需要补上获得绘制上下文并且设置维度信息的内容。\n */</span>\ncontext.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">\"red\"</span>;\ncontext.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span>);\n\n<span class=\"hljs-comment\">// 进行一系列坐标变换</span>\ncontext.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">\"blue\"</span>;\ncontext.<span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span>);\ncontext.<span class=\"hljs-title function_\">rotate</span>(-<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> / <span class=\"hljs-number\">6</span>);\ncontext.<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\ncontext.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span>);\n</code></pre>\n<p>最后得到的绘制效果如下图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19e8edca922a4ebeb1ed8c08618cde21~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>知道了 Canvas2D 的基本用法，接下来我们就可以把上面处理好的数据渲染出来了。</p>\n<pre><code class=\"hljs language-html\" lang=\"html\"><span class=\"hljs-comment\">&lt;!-- ch03/barchart/canvas/index.html --&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">canvas</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"container-canvas\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">canvas</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./index.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// ch03/barchart/canvas/index.js</span>\n\n<span class=\"hljs-keyword\">const</span> canvas = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">\"container-canvas\"</span>);\ncanvas.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">width</span> = containerWidth + <span class=\"hljs-string\">\"px\"</span>;\ncanvas.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">height</span> = containerHeight + <span class=\"hljs-string\">\"px\"</span>;\n\n<span class=\"hljs-comment\">// 下面把画布宽高设置为样式宽高的两倍主要是为了解决模糊问题</span>\n<span class=\"hljs-comment\">// 这个地方就不详细展开了，感兴趣的可以自行查阅</span>\ncanvas.<span class=\"hljs-property\">width</span> = containerWidth * <span class=\"hljs-number\">2</span>;\ncanvas.<span class=\"hljs-property\">height</span> = containerHeight * <span class=\"hljs-number\">2</span>;\n\n<span class=\"hljs-keyword\">const</span> context = canvas.<span class=\"hljs-title function_\">getContext</span>(<span class=\"hljs-string\">\"2d\"</span>);\ncontext.<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 抵消将画布宽高设置为样式宽高两倍的影响</span>\n\ncontext.<span class=\"hljs-title function_\">translate</span>(margin, margin); <span class=\"hljs-comment\">// 将坐标原点移动到绘制图表的区域</span>\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> index <span class=\"hljs-keyword\">of</span> indices) {\n  <span class=\"hljs-comment\">// 将需要绘制的属性取出来</span>\n  <span class=\"hljs-keyword\">const</span> color = colors[index];\n  <span class=\"hljs-keyword\">const</span> x = xs[index];\n  <span class=\"hljs-keyword\">const</span> barHeight = barHeights[index];\n  <span class=\"hljs-keyword\">const</span> value = values[index];\n  <span class=\"hljs-comment\">// 绘制条</span>\n  context.<span class=\"hljs-property\">fillStyle</span> = color;\n  context.<span class=\"hljs-title function_\">fillRect</span>(x, y - barHeight, barWidth, barHeight);\n\n  <span class=\"hljs-comment\">// 绘制值</span>\n  context.<span class=\"hljs-property\">textAlign</span> = <span class=\"hljs-string\">\"center\"</span>;\n  context.<span class=\"hljs-property\">textBaseline</span> = <span class=\"hljs-string\">\"middle\"</span>;\n  context.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">\"white\"</span>;\n  context.<span class=\"hljs-property\">font</span> = <span class=\"hljs-string\">\"25px PingFangSC-Regular, sans-serif\"</span>;\n  context.<span class=\"hljs-title function_\">fillText</span>(value, x + barWidth / <span class=\"hljs-number\">2</span>, y - barHeight / <span class=\"hljs-number\">2</span>);\n}\n</code></pre>\n<p>最后的绘制结果如图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2cd4888df7b41a0ad4f6e6787aec0f3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h3 data-id=\"heading-7\">SVG</h3>\n<p>接下来，我们再看看第二种绘图方式：SVG（Scalable Vector Graphics），可缩放矢量图，它是浏览器支持的一种基于 XML 语法的图像格式。相对于 Canvas2D 这种指令式的绘图系统来讲，SVG 是一种声明式的绘图系统，它的使用方式和普通的 DOM 元素非常像，所以使用起来比较简单。下面我们通过绘制和上面相同的内容来看看 SVG 的使用方法，新建一个名叫 svg-demo 的文件夹。</p>\n<p>（1）基础图形的绘制</p>\n<p>SVG 的坐标系和上面提到的 Canvas2D 所用的坐标系是一样的。</p>\n<pre><code class=\"hljs language-html\" lang=\"html\"><span class=\"hljs-comment\">&lt;!-- ch03/svg-demo/draw/index.html --&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- width，height 可以简单理解为样式宽高 --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- viewBox 可以简单理解为画布宽高 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span>\n  <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.w3.org/2000/svg\"</span>\n  <span class=\"hljs-attr\">version</span>=<span class=\"hljs-string\">\"1.1\"</span>\n  <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"400\"</span>\n  <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"200\"</span>\n  <span class=\"hljs-attr\">viewBox</span>=<span class=\"hljs-string\">\"0, 0, 400, 200\"</span>\n&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span>\n    <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"95\"</span>\n    <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"95\"</span>\n    <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">\"5\"</span>\n    <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">\"5\"</span>\n    <span class=\"hljs-attr\">stroke</span>=<span class=\"hljs-string\">\"yellow\"</span>\n    <span class=\"hljs-attr\">stroke-width</span>=<span class=\"hljs-string\">\"10\"</span>\n    <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>\n  /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text</span>\n    <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"black\"</span>\n    <span class=\"hljs-attr\">font-family</span>=<span class=\"hljs-string\">\"PingFangSC-Regular, sans-serif\"</span>\n    <span class=\"hljs-attr\">font-size</span>=<span class=\"hljs-string\">\"25\"</span>\n    <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">\"150\"</span>\n    <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">\"100\"</span>\n  &gt;</span>\n    hello world\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n</code></pre>\n<p>下面是绘制的效果：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be4ee428ab3c40bb89a779f4a7a795d1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>可以发现通过 SVG 绘制出来的效果和 Canvas2D 绘制出来的效果几乎一摸一样（除了边框的粗细以外）。但是绘制的方式却完全不同，在 SVG 中我们只用在 <code>&lt;svg&gt;&lt;/svg&gt;</code> 插入对应的 SVG 元素，然后设置它们的属性就好了，这和 DOM 的使用方式非常类似。当然除了上面展示的 <code>&lt;rect /&gt;</code> 和 <code>&lt;text /&gt;</code> 标签，还有绘制其他图形的标签，比如 <code>&lt;circle /&gt;</code>， <code>&lt;path /&gt;</code>， <code>&lt;line /&gt;</code> 这些，我们后面会介绍。</p>\n<p>（2）坐标变换</p>\n<p>在 SVG 实现坐标变换的其中一种方式是使用 <code>&lt;g /&gt;</code> 标签，给它设置 transform 属性，它将对它的所有子元素进行相应的变换。</p>\n<pre><code class=\"hljs language-html\" lang=\"html\"><span class=\"hljs-comment\">&lt;!-- ch03/svg-demo/transform/index.html --&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span>\n  <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.w3.org/2000/svg\"</span>\n  <span class=\"hljs-attr\">version</span>=<span class=\"hljs-string\">\"1.1\"</span>\n  <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"400\"</span>\n  <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"200\"</span>\n  <span class=\"hljs-attr\">viewBox</span>=<span class=\"hljs-string\">\"0, 0, 400, 200\"</span>\n&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">\"translate(50, 50) rotate(-30) scale(2, 3) \"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">x</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">y</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span> /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n</code></pre>\n<p>上看的代码同样可以获得如 Canvas2D 绘制的效果：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38a7537f0657400f85353f2b11011150~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>在了解了 SVG 的基本使用方式之后，就可以通过 SVG 来渲染我们处理好的数据了。首先，我们把 Canvas 2D 绘制相关的内容注释掉。</p>\n<pre><code class=\"hljs language-html\" lang=\"html\"><span class=\"hljs-comment\">&lt;!-- ch03/barchart/svg/index.html --&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"container-svg\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./index.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// ch03/barchart/svg/index.js</span>\n\n<span class=\"hljs-comment\">/*\n * 这里要补上数据处理的内容\n */</span>\n\n<span class=\"hljs-comment\">// 直接使用 document.createElement 是不行的</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createSVGElement</span>(<span class=\"hljs-params\">type</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElementNS</span>(<span class=\"hljs-string\">\"http://www.w3.org/2000/svg\"</span>, type);\n}\n\n<span class=\"hljs-keyword\">const</span> svg = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">\"container-svg\"</span>);\n<span class=\"hljs-comment\">// 设置 svg 的坐标原点和大小</span>\nsvg.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"width\"</span>, containerWidth);\nsvg.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"height\"</span>, containerHeight);\nsvg.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"viewBox\"</span>, [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, containerWidth, containerHeight]);\n\n<span class=\"hljs-comment\">// 创建一个 g 元素用于平移</span>\n<span class=\"hljs-keyword\">const</span> g = <span class=\"hljs-title function_\">createSVGElement</span>(<span class=\"hljs-string\">\"g\"</span>);\ng.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"transform\"</span>, <span class=\"hljs-string\">`translate(<span class=\"hljs-subst\">${margin}</span>, <span class=\"hljs-subst\">${margin}</span>)`</span>);\nsvg.<span class=\"hljs-title function_\">appendChild</span>(g);\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> index <span class=\"hljs-keyword\">of</span> indices) {\n  <span class=\"hljs-comment\">// 取得对应的属性</span>\n  <span class=\"hljs-keyword\">const</span> color = colors[index];\n  <span class=\"hljs-keyword\">const</span> x = xs[index];\n  <span class=\"hljs-keyword\">const</span> barHeight = barHeights[index];\n  <span class=\"hljs-keyword\">const</span> value = values[index];\n\n  <span class=\"hljs-comment\">// 绘制条</span>\n  <span class=\"hljs-keyword\">const</span> rect = <span class=\"hljs-title function_\">createSVGElement</span>(<span class=\"hljs-string\">\"rect\"</span>);\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"x\"</span>, x);\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"y\"</span>, y - barHeight);\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"fill\"</span>, color);\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"width\"</span>, barWidth);\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"height\"</span>, barHeight);\n  g.<span class=\"hljs-title function_\">appendChild</span>(rect);\n\n  <span class=\"hljs-comment\">// 绘制值</span>\n  <span class=\"hljs-keyword\">const</span> text = <span class=\"hljs-title function_\">createSVGElement</span>(<span class=\"hljs-string\">\"text\"</span>);\n  text.<span class=\"hljs-property\">textContent</span> = value;\n  text.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"text-anchor\"</span>, <span class=\"hljs-string\">\"middle\"</span>);\n  text.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"fill\"</span>, <span class=\"hljs-string\">\"white\"</span>);\n  text.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"font-family\"</span>, <span class=\"hljs-string\">\"PingFangSC-Regular, sans-serif\"</span>);\n  text.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'font-size'</span>, <span class=\"hljs-number\">25</span>);\n  text.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"alignment-baseline\"</span>, <span class=\"hljs-string\">\"middle\"</span>);\n  text.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"x\"</span>, x + barWidth / <span class=\"hljs-number\">2</span>);\n  text.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">\"y\"</span>, y - barHeight / <span class=\"hljs-number\">2</span>);\n\n  g.<span class=\"hljs-title function_\">appendChild</span>(text);\n}\n</code></pre>\n<p>最后绘制的结果如下图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e424af2cea7e40f182a47070992e2021~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h3 data-id=\"heading-8\">SVG VS Canvas2D</h3>\n<p>就这样，不知不觉，我们就用 SVG 和 Canvas2D 从 0 到 1 绘制了一个简单的条形图，而且效果几乎一模一样。那么，它们分别有什么特点，以及分别适合什么样的绘制场景呢？</p>\n<p>SVG 的优点是方便交互，因为它也有 DOM 结构，可以方便地监听事件。但是性能方面却有所影响：如果我们要绘制的图形非常复杂，这些元素节点的数量就会非常多。而节点数量多，就会大大增加 DOM 树渲染和重绘所需要的时间。</p>\n<p>相比来说，Canvas 交互实现就不太容易，因为对每个图形的拾取（判断鼠标点位置在哪个图形上）需要开发者自己实现（很多渲染引擎会解决这个问题，我们后面会看到），但是它的绘制性能却相对较优。</p>\n<p>所以当数据量不大且侧重交互的情况，用 SVG 比较合适；当数据量较大的时候用 Canvas 比较合适。</p>\n<h2 data-id=\"heading-9\">回答问题</h2>\n<p>总结了一下我们的绘制技术，但是我们不能忘记我们绘制图表的初衷：回答问题。虽然目前我们绘制的条形图很简单，连坐标轴，图例这些都没有，但是已经足够解决我们的问题了：哲学家，哲学问题和流派的数量关系是怎样的？</p>\n<p>可以发现在《苏菲的世界》这本书中提到的流派的数量比哲学问题多，哲学家又比流派的数量多，说明大多数的哲学问题都有多个流派尝试解答，大多数流派都有多个哲学家。虽然这个结论很简单，或者说整个分析任务都很简单，但是“麻雀虽小，五脏俱全”，已经足够我们一窥数据分析的大部分东西了。</p>\n<h2 data-id=\"heading-10\">小结</h2>\n<p>这一章我们学习了 Canvas 和 SVG 两种 Web 绘图技术，同时也简单了解一下绘制条形图的流程，最后解决了前面提出的一个问题。但是可以发现这样用可视化分析数据的效率还是很低的，如果我们在解答后面的问题的时候，还需要这样写这么多代码，那不知道要分析道猴年马月去了。</p>\n<p>大家不要着急，你们存在的顾虑前人早就考虑到啦。下一节我们就从理论上先介绍一种加快我们制作图表的语法：可视化语法，然后在从不同层级上看看世界上目前有哪些优秀的图表制作工具，它们又是怎样简化我们的绘制流程的！</p>\n<p>想看完整代码，点<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fvisualize-sophie-world%2Ftree%2Fmain%2Fcode%2Fch03\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/visualize-sophie-world/tree/main/code/ch03\" ref=\"nofollow noopener noreferrer\">这里</a>。</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "4\n基础：可视化工具概览\n学习时长: 19分32秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>上面一节和大家一起从 0 到 1 实现了一个条形图去回答了我们8个问题中第一个问题：“哲学家、哲学问题和流派的数量关系是怎样的？”。</p>\n<p>在绘制条形图的过程中，因为没有借助任何工具，所以虽然代码行数不是很多，但是也能感觉到不太方便，比如自己实现数据处理过程，调用浏览器原生的绘制 API 等。</p>\n<p>有没有办法可以简化这个流程，让我们能快更好的完成我们的可视分析任务？答案是肯定的。俗话说的好：“工欲善其事，必先利其器”，解决办法就是使用现有的工具。但是几乎所有做可视化的人会面对一个绕不开的问题：</p>\n<p><strong>“我应该使用哪一个可视化工具？”</strong></p>\n<p>要回答这个问题，那么我们就该先了解选择标准是什么？前端领域有哪些有名的可视化工具？它们又有什么特点？使用它们有什么常见的挑战？</p>\n<p>接下来我们就来一一看看。</p>\n<h2 data-id=\"heading-0\">选择标准</h2>\n<p>选择可视化工具的时候，我们的标准不是哪个更好，而是哪个跟适合我们当前想要完成的任务。那么又该如何判断这个工具是否当前的任务呢？那我们首先得看看这些可视化工具解决的核心问题。</p>\n<p>可视化工具要想解决的核心问题是：在<strong>易用</strong>和<strong>灵活</strong>之间找到一个平衡。易用是指用户在实现一个可视化图表的时候只用付出很少的努力，灵活是指用户能用该工具实现更多自定义的效果。</p>\n<p>很容易想象得到，易用性越强的工具越不灵活，越灵活的工具越不易用。因为当你付出努力少的时候，说明很多事情工具已经自己帮你做了，而这些你是没有办法或者只有部分参与的，这无疑降低了灵活性。</p>\n<p>所以我们选择工具的时候就是看这个工具能否在易用和灵活两方面都尽量满足我们的需求。那目前前端领域的可视化工具的易用性和灵活性有如何呢？我们马上来看看。</p>\n<h2 data-id=\"heading-1\">可视化框架概览</h2>\n<p>参考 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fnightingale%2Fnavigating-the-wide-world-of-web-based-data-visualization-libraries-798ea9f536e7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://medium.com/nightingale/navigating-the-wide-world-of-web-based-data-visualization-libraries-798ea9f536e7\" ref=\"nofollow noopener noreferrer\">Navigating the Wide World of Data Visualization Libraries</a> 这篇文章，我们把一些有名的可视化工具用下面这张图整理了一下：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fff4706e9f6f4c92baf8f726ee1b2608~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>垂直方向是按照抽象程度来分类的，越底层的工具抽象程度越低，灵活性越强，易用性越差；越高层的工具抽象程度越高，易用性越强。水平方向是按照归属来分类的，左边的工具是来自于 AntV 技术栈的工具，右边的工具是来自于社区优秀的开源工具。</p>\n<p>大概了解了社区上一些优秀的可视化工具之后，我们接下来就从渲染引擎这一层抽像开始，一层层向上看，看看它们是怎么帮助我们可视化的。</p>\n<h2 data-id=\"heading-2\">渲染引擎</h2>\n<p>首先是渲染引擎，渲染引擎会对浏览器的原生 API 进行封装，主要目的是为了简化我们绘制图形的流程。</p>\n<p>比如我们用 Canvas2D 绘制一个矩形的方式如下，需要一行行的设置属性。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 绘制一个矩形</span>\ncontext.<span class=\"hljs-property\">fillStyle</span> = <span class=\"hljs-string\">\"red\"</span>; <span class=\"hljs-comment\">// 设置填充颜色</span>\ncontext.<span class=\"hljs-property\">strokeStyle</span> = <span class=\"hljs-string\">\"yellow\"</span>; <span class=\"hljs-comment\">// 设置边框的颜色</span>\ncontext.<span class=\"hljs-property\">lineWidth</span> = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// 设置边框的宽度</span>\ncontext.<span class=\"hljs-title function_\">strokeRect</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>); <span class=\"hljs-comment\">// 绘制边框</span>\ncontext.<span class=\"hljs-title function_\">fillRect</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">95</span>, <span class=\"hljs-number\">95</span>); <span class=\"hljs-comment\">// 绘制填充颜色</span>\n</code></pre>\n<p>但是在 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fg\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/g\" ref=\"nofollow noopener noreferrer\">@antv/g</a> 的帮助下，直接把属性通过一个 options 的形式指定就好。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> rect = <span class=\"hljs-keyword\">new</span> G.<span class=\"hljs-title class_\">Rect</span>({\n  <span class=\"hljs-attr\">style</span>: {\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">5</span>,\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">5</span>,\n    <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">100</span>,\n    <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">100</span>,\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'red'</span>,\n    <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'yellow'</span>\n  },\n});\n</code></pre>\n<p>但是在这一抽象层次的工具只是简化了最后的数据绘制流程，没有简化我们的数据处理流程，或者一些通用功能（坐标轴，图例这些），所以我们需要更强大的工具。</p>\n<h2 data-id=\"heading-3\">低级可视化模块</h2>\n<p>低级可视化模块就是上面提到的更强大的工具。它们是一些和可视化相关的工具，各自都是相互独立并且负责数据处理或者数据绘制的某部分。</p>\n<p>比如在上一章我们通过以下的方式去计算每个条的 x 坐标，这样不仅需要我们自己实现计算逻辑，还看上去不直观。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> step = chartWidth / names.<span class=\"hljs-property\">length</span>; \n<span class=\"hljs-keyword\">const</span> barWidth = step * <span class=\"hljs-number\">0.8</span>; \n<span class=\"hljs-keyword\">const</span> xs = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(indices, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> i * step);\n</code></pre>\n<p>如果我们使用 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fd3%2Fd3-scale\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/d3/d3-scale\" ref=\"nofollow noopener noreferrer\">d3-scale</a> 就可以简化这个流程如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> map = d3.<span class=\"hljs-title function_\">scaleBand</span>().<span class=\"hljs-title function_\">domain</span>(indices).<span class=\"hljs-title function_\">range</span>([<span class=\"hljs-number\">0</span>, chartWidth]);\n<span class=\"hljs-keyword\">const</span> xs = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(indices, map);\n</code></pre>\n<p>这一抽象层次的工具简化了图表绘制各个流程，但是难道每一个流程都必须人来参与吗？工具可以自己完成一部分吗？</p>\n<h2 data-id=\"heading-4\">可视化语法</h2>\n<p>可视化语法就能大幅度减少人的参与，同时保持相对可观的灵活性。</p>\n<p>可视化语法的开山鼻祖可以说是：<strong>图形语法</strong>，目前前端有名的在可视化语法这一层级的工具 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FG2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/G2\" ref=\"nofollow noopener noreferrer\">G2</a>，<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvega%2Fvega-lite\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/vega/vega-lite\" ref=\"nofollow noopener noreferrer\">Vega-Lite</a> 等都或多或少借鉴它的思想。</p>\n<p>图形语法这个概念是在 Leland Wilkinson 的《The Grammar of Graphics》被提出的。它的核心就是用一些不同同图表都通用的概念（比例尺，坐标系等）去描述一个可视化图表。下面是书中给出的一个案例，目前大家不用深入了解，只用大概感受一下，我们在后面会深入了解。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d7a2ddb787c477d8fa1f6071f322ce4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>要实现上一章的条形图就可以很简单了，下面用 G2 举例子：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Chart</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@antv/g2'</span>;\n\n<span class=\"hljs-keyword\">const</span> data = [\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"questions\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">17</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"schools\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">25</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"philosophers\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">35</span> },\n];\n\n<span class=\"hljs-keyword\">const</span> chart = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Chart</span>({\n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">480</span>,\n  <span class=\"hljs-attr\">heihgt</span>: <span class=\"hljs-number\">300</span>,\n  <span class=\"hljs-attr\">container</span>: <span class=\"hljs-string\">'container-canvas'</span>\n});\n\nchart.<span class=\"hljs-title function_\">data</span>(data);\n\nchart\n  .<span class=\"hljs-title function_\">interval</span>()\n  .<span class=\"hljs-title function_\">position</span>(<span class=\"hljs-string\">'name*value'</span>)\n  .<span class=\"hljs-title function_\">color</span>(<span class=\"hljs-string\">'name'</span>);\n  \nchart.<span class=\"hljs-title function_\">render</span>();\n</code></pre>\n<p>如果我们希望再简单一点使用呢？那么就需要看看下一层级了。</p>\n<h2 data-id=\"heading-5\">高级可视化绘制模块</h2>\n<p>高级可视化绘制模块和可视化语层级一样，都不会显式指明可视化图表的类型，但是这些模块不一定是所有图表都通用的，同时在不同的可视化工具中功能也不一样。</p>\n<p>在 <a href=\"https://link.juejin.cn?target=\" title=\"\" ref=\"nofollow noopener noreferrer\">ECharts</a> 中就会通过 series 去组合形成不同的可视化图表类型。下面用是 ECharts 去绘制上一节需要的条形图的代码。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> chart = echarts.<span class=\"hljs-title function_\">init</span>(<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'container-canvas'</span>));\n\n<span class=\"hljs-keyword\">const</span> option = {\n  <span class=\"hljs-attr\">xAxis</span>: {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'category'</span>,\n    <span class=\"hljs-attr\">data</span>: [<span class=\"hljs-string\">'questions'</span>, <span class=\"hljs-string\">'schools'</span>, <span class=\"hljs-string\">'philosophers'</span>]\n  },\n  <span class=\"hljs-attr\">yAxis</span>: {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'value'</span>\n  },\n  <span class=\"hljs-attr\">series</span>: [\n    {\n      <span class=\"hljs-attr\">data</span>: [<span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">25</span>, <span class=\"hljs-number\">35</span>],\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'bar'</span>,\n    }\n  ]\n};\n\nchart.<span class=\"hljs-title function_\">setOptions</span>(options);\n</code></pre>\n<h2 data-id=\"heading-6\">图表模板</h2>\n<p>图表模版这一抽象层级一个最大的改变就是需要指定我们选择的图表的类型，不用去考虑如何去组合高级可视化绘制模块。这在意味着非常的方便的同时，丧失了很多灵活性，适合对自定义要求不高的任务。</p>\n<p>下面用 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fg2plot.antv.vision%2Fzh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://g2plot.antv.vision/zh\" ref=\"nofollow noopener noreferrer\">G2Plot</a> 来实现我们上一章对条形图，发现代码确实少了很多。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Column</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@antv/g2plot'</span>;\n\n<span class=\"hljs-keyword\">const</span> data = [\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"questions\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">17</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"schools\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">25</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"philosophers\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">35</span> },\n];\n\n<span class=\"hljs-keyword\">const</span> column = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Column</span>(<span class=\"hljs-string\">'container-canvas'</span>, {\n  data,\n  <span class=\"hljs-attr\">xField</span>: <span class=\"hljs-string\">'name'</span>,\n  <span class=\"hljs-attr\">yField</span>: <span class=\"hljs-string\">'value'</span>,\n  <span class=\"hljs-attr\">seriesField</span>: <span class=\"hljs-string\">'name'</span>,\n});\n\ncolumn.<span class=\"hljs-title function_\">render</span>();\n</code></pre>\n<h2 data-id=\"heading-7\">智能可视化</h2>\n<p>如果你在可视化的过程什么也不愿意参与或者想参与程度很低的话，那么智能化可视化便是你最好的选择。一般来说你只需要把你想要可视化的数据和可视化意图告诉它，它就可以自动可视化出来。</p>\n<p>比如 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fava.antv.vision%2Fzh%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://ava.antv.vision/zh/\" ref=\"nofollow noopener noreferrer\">@antv/AVA</a> 就可以非常简单的完成我们上一章提到的分析任务，我们都不需要去告诉它我们需要条形图，如下的代码就可以帮助我们把条形图做出来。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">AutoChart</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@antv/auto-chart'</span>;\n\n<span class=\"hljs-keyword\">const</span> data = [\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"questions\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">17</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"schools\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">25</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"philosophers\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">35</span> },\n];\n\n<span class=\"hljs-title function_\">autoChart</span>(<span class=\"hljs-string\">'container-canvas'</span>, data);\n</code></pre>\n<p>就这样我们在很短时间内直观感受了前端领域的不同抽象层级的可视化框架。想必大家肯定感觉好像学到了很多东西，却又好像什么都没有学到。</p>\n<p>这是因为我们只是简单了解了其中的一些基本概念，而没有深入理解。如何才能深入理解？那就是自己亲自体验一下：自己从零开一个可视化工具，看完成一个完整的可视化图表到底有哪些需要考虑的。</p>\n<h2 data-id=\"heading-8\">Sparrow</h2>\n<p>我们接下来要开发的框架的名字叫做：Sparrow，是一个基于图形语法的可视化框架。选择开发一个在可视化语法抽象层级工具的考虑有两点：</p>\n<ul>\n<li>可视化语法是很关键的一层，有承上启下的感觉：它不仅仅将一些低层级可视化绘制模块串联起来了，也给上层的高级可视化模块提高了足够灵活和易用的基础。</li>\n<li>我们团队在迭代 G2 的过程中，发现很多 issues 提到的问题都是因为对图形语法不了解导致的的，希望能通过这个过程加深大家对图形语法的理解，可以更好的使用相关的可视化工具，也能对可视化有更加深刻的理解。</li>\n</ul>\n<p>Sparrow 翻译过来就是麻雀。俗话说的好：“麻雀虽小，五脏俱全”，这意味着我们最后完成工具代码量会很少，但是却覆盖了如下图图形语法最核心的东西。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/723fb646abdc4a96acc3e50010abf1e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>开发完成之后，我们可以通过一个如下的 JavaScript 对象去描述我们的图表。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { plot } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@sparrow-vis/sparrow\"</span>;\n\n<span class=\"hljs-keyword\">const</span> data = [\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"questions\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">17</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"schools\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">25</span> },\n  { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"philosophers\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">35</span> },\n];\n\n<span class=\"hljs-keyword\">const</span> chart = <span class=\"hljs-title function_\">plot</span>({\n  data,\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"interval\"</span>,\n  <span class=\"hljs-attr\">encodings</span>: {\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">\"name\"</span>,\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">\"value\"</span>,\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"name\"</span>\n  }\n});\n\n<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">\"container\"</span>).<span class=\"hljs-title function_\">appendChild</span>(chart);\n</code></pre>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/374e2e2ab34b43c58a0cf4285a38c203~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"20211128230231.jpg\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>开发完成之后可以大大的提高我们解决后面问题的速度。</p>\n<h2 data-id=\"heading-9\">小结</h2>\n<p>这一章我们简单给大家展示了目前前端领域流行的可视化工具，并且大概了解了它们的使用方式。为了对它们有更深入的认识，并且能加速我们后面解决问题的速度，我们接下来准备从零开发一个基于图形语法的可视化库 Sparrow。</p>\n<p>基础篇就这样结束了，接下来让我们一起扬帆起航进入实战篇。</p>\n<blockquote>\n<p>参考资料</p>\n<ul>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fnightingale%2Fnavigating-the-wide-world-of-web-based-data-visualization-libraries-798ea9f536e7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://medium.com/nightingale/navigating-the-wide-world-of-web-based-data-visualization-libraries-798ea9f536e7\" ref=\"nofollow noopener noreferrer\">Navigating the Wide World of Data Visualization Libraries</a>, Krist Wongsuphasawat</li>\n<li>The Grammar of Graphics, 2nd Edition, Leland Wilkinson</li>\n</ul>\n</blockquote><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "5\n实战：搭建开发环境\n学习时长: 37分3秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>现在我们就正式进入了我们的实战，也是小册子的核心部分：从 0 到 1 开发一个图表库。前一章对我们要开发的东西 Sparrow已经有了一个简单的介绍，这里就不多说了。</p>\n<p>在正式开发之前，我们先来搭建开发环境：一个合理的开发环境，会大大提高我们写代码的效率，规范性和健壮程度。</p>\n<p>我们将会从初始化环境开始，然后从<strong>检查（Lint）</strong> 、<strong>测试（Test）</strong> 、<strong>构建（Build）</strong> 、<strong>版本管理（Version Control）</strong> 和 <strong>持续化集成（Continuous integration）</strong> 这几方面来搭建我们的开发环境。</p>\n<p>那么首先我们来初始化我们的环境。</p>\n<h2 data-id=\"heading-0\">初始化环境</h2>\n<p>首先在任意位置新建一个名叫 sparrow 的文件夹，然后安装下面对应版本的 <a href=\"https://link.juejin.cn?target=http%3A%2F%2Fnodejs.cn%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"http://nodejs.cn/\" ref=\"nofollow noopener noreferrer\">node</a> 和 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://www.npmjs.com/\" ref=\"nofollow noopener noreferrer\">npm</a>：</p>\n<ul>\n<li>node: 14.17.6</li>\n</ul>\n\n<ul>\n<li>npm: 6.14.15</li>\n</ul>\n<p>接下来运行 <code>npm init -y</code> 来初始化环境，这之后 sparrow 文件夹里会出现一个 <code>package.json</code> 文件。又了它之后，我们就来搭建我们的开发环境！</p>\n<blockquote>\n<p>代码编辑器推荐使用 VSCode</p>\n</blockquote>\n<h2 data-id=\"heading-1\">代码检查（Lint）</h2>\n<p>首先我们来看看代码检查，代码检查是一种静态的分析，常用于寻找有问题的模式或者代码，能帮助我们规范代码和加少出错的可能性。这里我们将使用 <strong><a href=\"https://link.juejin.cn?target=http%3A%2F%2Feslint.cn%2Fdocs%2Fuser-guide%2Fgetting-started\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"http://eslint.cn/docs/user-guide/getting-started\" ref=\"nofollow noopener noreferrer\">ESlint</a></strong> 来作为代码检查的工具。</p>\n<pre><code class=\"hljs language-css\" lang=\"css\">$ npm install eslint <span class=\"hljs-attr\">--save-dev</span>\n</code></pre>\n<p>我们可以通过下面的命令来初始化 ESlint 的配置，它会问你一些问题，根据你的选择去生成对应的配置文件。</p>\n<pre><code class=\"hljs language-csharp\" lang=\"csharp\">$ npx eslint --<span class=\"hljs-keyword\">init</span>\n</code></pre>\n<p>这里把问题和答案都记录下来了。</p>\n<ul>\n<li>How would you like to use ESLint? &gt; <em>To check syntax, find problems, and enforce code style</em></li>\n</ul>\n\n<ul>\n<li>What type of modules does your project use? &gt; <em>JavaScript modules (import/export)</em></li>\n</ul>\n\n<ul>\n<li>Which framework does your project use? &gt; <em>None of these</em></li>\n</ul>\n\n<ul>\n<li>Does your project use TypeScript? &gt; <em>NO</em></li>\n</ul>\n\n<ul>\n<li>Where does your code run? &gt; <em>Browser, Node</em></li>\n</ul>\n\n<ul>\n<li>How would you like to define a style for your project &gt; <em>Use a popular style guide</em></li>\n</ul>\n\n<ul>\n<li>Which style guide do you want to follow? &gt; <em>Airbnb: <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fairbnb%2Fjavascript\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/airbnb/javascript\" ref=\"nofollow noopener noreferrer\">github.com/airbnb/java…</a></em></li>\n</ul>\n\n<ul>\n<li>What format do you want your config file to be in? &gt; <em>JavaScript</em></li>\n</ul>\n\n<ul>\n<li>Would you like to install them now with npm? &gt; <em>Yes</em></li>\n</ul>\n<p>最后对生成的配置文件进行简单修改后如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">env</span>: {\n    <span class=\"hljs-attr\">browser</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">es2021</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">node</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-comment\">// 这里增加一行，用于支持后面的测试环境</span>\n    <span class=\"hljs-attr\">jest</span>: <span class=\"hljs-literal\">true</span>,\n  },\n  <span class=\"hljs-attr\">extends</span>: [<span class=\"hljs-string\">\"airbnb-base\"</span>],\n  <span class=\"hljs-attr\">parserOptions</span>: {\n    <span class=\"hljs-attr\">ecmaVersion</span>: <span class=\"hljs-number\">13</span>,\n    <span class=\"hljs-attr\">sourceType</span>: <span class=\"hljs-string\">\"module\"</span>,\n  },\n  <span class=\"hljs-attr\">rules</span>: {\n    <span class=\"hljs-comment\">// 这里添加一行规则把这条规则隐藏</span>\n    <span class=\"hljs-string\">\"import/prefer-default-export\"</span>: <span class=\"hljs-number\">0</span>,\n  },\n};\n</code></pre>\n<p>因为我们需要使用 airbnb 的规则集合，所以需要额外安装下面的包：</p>\n<pre><code class=\"hljs language-arduino\" lang=\"arduino\">$ npm install eslint-plugin-<span class=\"hljs-keyword\">import</span> eslint-config-airbnb-base@latest --save-dev\n</code></pre>\n<p>为了验证 eslint 已经正确使用了，我们在项目的根目录下增加：<code>src/index.js</code> 和 <code>src/drawRedRect.js</code>，并且输入以下的代码：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/index.js</span>\n\n<span class=\"hljs-keyword\">export</span> { drawRedRect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./drawRedRect'</span>;\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/drawRedRect.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">drawRedRect</span>(<span class=\"hljs-params\">svg</span>) {\n  <span class=\"hljs-keyword\">var</span> rect = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElementNS</span>(<span class=\"hljs-string\">'http://www.w3.org/2000/svg'</span>, <span class=\"hljs-string\">'rect'</span>)\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'x'</span>, <span class=\"hljs-number\">0</span>)\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'y'</span>, <span class=\"hljs-number\">0</span>)\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'fill'</span>, <span class=\"hljs-string\">'red'</span>)\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'width'</span>, <span class=\"hljs-number\">100</span>)\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'height'</span>, <span class=\"hljs-number\">100</span>)\n  svg.<span class=\"hljs-title function_\">appendChild</span>(rect)\n}\n</code></pre>\n<p>在控制台输入命令：<code>npx eslint src/drawRedRect.js</code> 会去检测 <code>src/drawRedRect.js</code> 文件存在的规则问题，如果加上 <code>--fix</code> 选项会修复在<a href=\"https://link.juejin.cn?target=https%3A%2F%2Feslint.bootcss.com%2Fdocs%2Frules%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://eslint.bootcss.com/docs/rules/\" ref=\"nofollow noopener noreferrer\">规则列表</a>有黄色 🔧 标记的规则。这里我们输入 <code>npx eslint src/drawRedRect.js --fix</code>，这个时候打开 <code>src/drawRedRect</code>，会发现 <code>var</code> 被修复成了 <code>const</code>，并且每一条语句末尾都被添加上了 <code>;</code>。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/drawRedRect.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">drawRedRect</span>(<span class=\"hljs-params\">svg</span>) {\n  <span class=\"hljs-keyword\">const</span> rect = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElementNS</span>(<span class=\"hljs-string\">'http://www.w3.org/2000/svg'</span>, <span class=\"hljs-string\">'rect'</span>);\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'x'</span>, <span class=\"hljs-number\">0</span>);\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'y'</span>, <span class=\"hljs-number\">0</span>);\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'fill'</span>, <span class=\"hljs-string\">'red'</span>);\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'width'</span>, <span class=\"hljs-number\">100</span>);\n  rect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'height'</span>, <span class=\"hljs-number\">100</span>);\n  svg.<span class=\"hljs-title function_\">appendChild</span>(rect);\n}\n</code></pre>\n<p>这之后我们给 <code>package.json</code> 增加 <code>lint</code> 命令如下：</p>\n<pre><code class=\"hljs language-json\" lang=\"json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"scripts\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">\"lint\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"eslint --fix\"</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>为了更好的开发体验，如果使用 VSCode 话可以安装 eslint 插件（直接在应用商店搜索即可）。一方面插件会直接在文件中把问题高亮出来，另一方面我们可以通过命令来直接修复问题：<code>cmd + p</code> + <code>&gt; ESlint: Fix all auto-fixable Problems</code>。更多 <a href=\"https://link.juejin.cn?target=http%3A%2F%2Feslint.cn%2Fdocs%2Fuser-guide%2Fgetting-started\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"http://eslint.cn/docs/user-guide/getting-started\" ref=\"nofollow noopener noreferrer\">ESlint</a> 相关的东西可以去官网学习。</p>\n<h2 data-id=\"heading-2\">代码测试（Test）</h2>\n<p>代码检测之后就是代码测试了，优秀的单元测试能保证我们的项目在迭代的过程中不出问题，这里我们将使用 <strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.jestjs.cn%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://www.jestjs.cn/\" ref=\"nofollow noopener noreferrer\">Jest</a></strong> 和 <strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhustcc%2Fjest-electron\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/hustcc/jest-electron\" ref=\"nofollow noopener noreferrer\">Jest Electron</a></strong> 来搭建我们的测试环境。</p>\n<p>Jest 是一个流行的 JavaScript 的测试框架，一般都运行在 node 或者模拟出来的浏览器环境，但是因为我们开发的是一个图表库，真实的浏览器环境会更加易于我们调试，所以我们需要 Jest Electron。我们用如下命令安装，这里需要注意的是一定要安装下面版本的 Jest，否者会出问题。</p>\n<pre><code class=\"hljs language-css\" lang=\"css\">$ npm <span class=\"hljs-selector-tag\">i</span> jest<span class=\"hljs-keyword\">@26</span>.0.1 jest-electron --save-dev\n</code></pre>\n<p>然后增加一个名叫 <code>jest.config.js</code> 并且增加内容如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">testMatch</span>: [<span class=\"hljs-string\">'**/__tests__/**/*.spec.js'</span>], <span class=\"hljs-comment\">// 只测试后缀为 .spec.js 的文件</span>\n  <span class=\"hljs-attr\">runner</span>: <span class=\"hljs-string\">'jest-electron/runner'</span>, <span class=\"hljs-comment\">// 指定测试的 runner</span>\n  <span class=\"hljs-attr\">testEnvironment</span>: <span class=\"hljs-string\">'jest-electron/environment'</span>, <span class=\"hljs-comment\">//  制定测试的环境</span>\n};\n</code></pre>\n<p>在真正开始测试之前我们还需要将代码编译成可以在 node 环境下面可以运行的代码，这个时候我们就需要 <strong><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fbabel.docschina.org%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://babel.docschina.org/\" ref=\"nofollow noopener noreferrer\">Babel</a></strong> 了。Babel 是一个 JavaScript 编译器，主要用于在当前和旧的浏览器或环境中，将 ECMAScript 2015+ 代码转换为 JavaScript 向后兼容版本的代码。</p>\n<pre><code class=\"hljs language-ruby\" lang=\"ruby\"><span class=\"hljs-variable\">$ </span>npm install --save-dev <span class=\"hljs-variable\">@babel</span>/core <span class=\"hljs-variable\">@babel</span>/cli <span class=\"hljs-variable\">@babel</span>/preset-env\n</code></pre>\n<p>然后增加一个名叫 <code>.babelrc</code> 的文件并且输入以下内容：</p>\n<pre><code class=\"hljs language-json\" lang=\"json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"presets\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n    <span class=\"hljs-punctuation\">[</span>\n      <span class=\"hljs-string\">\"@babel/preset-env\"</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">\"useBuiltIns\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"entry\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"corejs\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"3.6.4\"</span>\n      <span class=\"hljs-punctuation\">}</span>\n    <span class=\"hljs-punctuation\">]</span>\n  <span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"exclude\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"node_modules/**\"</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>这个时候我们在根目录下增加 <code>__tests__</code> 文件夹，并且增加 <code>index.spec.js</code> 和 <code>utils.js</code> 文件:</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// __tests__/index.spec.js</span>\n\n<span class=\"hljs-keyword\">import</span> { drawRedRect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../src'</span>;\n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">'test'</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-title function_\">test</span>(<span class=\"hljs-string\">'drawRedRect()'</span>, <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> svg = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElementNS</span>(<span class=\"hljs-string\">'http://www.w3.org/2000/svg'</span>, <span class=\"hljs-string\">'svg'</span>);\n    svg.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'width'</span>, <span class=\"hljs-number\">400</span>);\n    svg.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'height'</span>, <span class=\"hljs-number\">400</span>);\n    svg.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'viewBox'</span>, [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">400</span>]);\n    <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">appendChild</span>(svg);\n    \n    <span class=\"hljs-title function_\">drawRedRect</span>(svg);\n    <span class=\"hljs-title function_\">expect</span>(svg.<span class=\"hljs-title function_\">getElementsByTagName</span>(<span class=\"hljs-string\">'rect'</span>).<span class=\"hljs-property\">length</span>).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-number\">1</span>);\n  });\n\n});\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// __tests__/utils.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createDiv</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">const</span> div = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">'div'</span>);\n  <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title function_\">appendChild</span>(div);\n  <span class=\"hljs-keyword\">return</span> div;\n}\n</code></pre>\n<p>如果一切顺利的话我们运行：<code>npx jest</code> 和普通的测试测试没有太多的区别，但是 <code>DEBUG_MODE=1 npx jest</code> 会额外打开一个基于 Electron 真实的浏览器，并且输出如下：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/037eed6c95114c4d83f61b6dc736b4f1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>为了兼容 Windows 和 Mac 系统，我们需要额外安装一个 cross-env 这个库。</p>\n<pre><code class=\"hljs language-bash\" lang=\"bash\">$ npm install --save-dev cross-env\n</code></pre>\n<p>这样需要打开 Electron 测试的时候输入：<code>cross-env DEBUG_MODE=1 npx jest</code>。</p>\n<p>这个过程中 Jest 会首先读取 <code>.babelrc</code> 的内容，用 Babel 将代码编译之后再测试。之后我们给 <code>package.json</code> 增加 <code>test</code> 和 <code>test-live</code> 命令如下：</p>\n<pre><code class=\"hljs language-json\" lang=\"json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"scripts\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">\"test\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"jest --coverage\"</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">\"test-live\"</span><span class=\"hljs-punctuation\">:</span><span class=\"hljs-string\">\"cross-env DEBUG_MODE=1 jest --coverage\"</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<h2 data-id=\"heading-3\">代码构建（Build）</h2>\n<p>因为我们最后是完成一个库并且发布在 npm 上供大家使用，所以我们需要对我们的代码进行构建，这个时候我们需要对编译好的代码进行打包: 将小块代码编译成大块复杂的代码，然后在不同的环境下运行。这个地方我们选择 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.rollupjs.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://www.rollupjs.com/\" ref=\"nofollow noopener noreferrer\">Rollup</a> 来作为我们的打包器。</p>\n<p>在打包之前我们需要 Rollup 用 Babel 对代码进行编译，所以我们还需要安装 <code>rollup-plugin-babel</code> 这个插件。</p>\n<pre><code class=\"hljs language-css\" lang=\"css\">$ npm install <span class=\"hljs-attr\">--save-dev</span> rollup rollup-plugin-babel\n</code></pre>\n<p>另一方面我们还需要 <code>rollup-plugin-node-resolve</code> 这个插件来保证打包过程能正确加载文件。</p>\n<pre><code class=\"hljs language-css\" lang=\"css\">$ npm install <span class=\"hljs-attr\">--save-dev</span> rollup-plugin-node-resolve\n</code></pre>\n<p>安装完成之后我们新建 <code>rollup.config.js</code> 文件，输入以下的内容：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> babel <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rollup-plugin-babel'</span>;\n<span class=\"hljs-keyword\">import</span> resolve <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rollup-plugin-node-resolve'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">'src/index.js'</span>, <span class=\"hljs-comment\">// 打包入口</span>\n  <span class=\"hljs-attr\">output</span>: [\n    {\n      <span class=\"hljs-attr\">file</span>: <span class=\"hljs-string\">'lib/sparrow.js'</span>, <span class=\"hljs-comment\">// 对于 Nodejs，打包成 commonjs</span>\n      <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'cjs'</span>,\n    },\n    {\n      <span class=\"hljs-attr\">file</span>: <span class=\"hljs-string\">'esm/sparrow.js'</span>, <span class=\"hljs-comment\">// 对于浏览器，打包成 ES module</span>\n      <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'es'</span>,\n    },\n    {\n      <span class=\"hljs-attr\">file</span>: <span class=\"hljs-string\">'dist/sparrow.min.js'</span>,\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'sp'</span>,\n      <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'umd'</span>, <span class=\"hljs-comment\">// 对于 Nodejs 和浏览器，打包成混合模式</span>\n    },\n  ],\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-title function_\">resolve</span>(),\n    <span class=\"hljs-title function_\">babel</span>(), <span class=\"hljs-comment\">// 使用 babel 插件</span>\n  ],\n};\n</code></pre>\n<p>这个时候我们运行 <code>npx rollup --config</code> 就可以发现目录中多了三个 <code>dist</code>、<code>esm</code> 和 <code>lib</code> 文件夹就是我们的打包结果。当然这里我们还需要安装一个小工具 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fisaacs%2Frimraf\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/isaacs/rimraf\" ref=\"nofollow noopener noreferrer\">rimraf</a>，在每次打包之前把以往的打包代码删除。</p>\n<pre><code class=\"hljs language-css\" lang=\"css\">$ npm <span class=\"hljs-selector-tag\">i</span> rimraf <span class=\"hljs-attr\">--save-dev</span>\n</code></pre>\n<p>使用方法也很简单：<code>npx rimraf -rf ./dist ./lib ./esm</code> 就可以把之前生成的文件删除了。之后我们给 <code>package.json</code> 增加 <code>build</code> 命令如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\">{\n  <span class=\"hljs-string\">\"scripts\"</span>: {\n    <span class=\"hljs-string\">\"build\"</span>: <span class=\"hljs-string\">\"rimraf -rf ./dist ./lib ./esm &amp;&amp; rollup --config\"</span>\n  }\n}\n</code></pre>\n<h2 data-id=\"heading-4\">版本管理（VC）</h2>\n<p>接下来看看我们的版本管理工具，这里当然使用 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgit-scm.com%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://git-scm.com/\" ref=\"nofollow noopener noreferrer\">Git</a>。我们首先运行 <code>git init</code>，然后添加一个如下的 <code>.gitignore</code> 文件来指定不加入版本管理的文件。</p>\n<pre><code class=\"hljs language-lua\" lang=\"lua\"># Logs\nlogs\n*.<span class=\"hljs-built_in\">log</span>\nnpm-<span class=\"hljs-built_in\">debug</span>.<span class=\"hljs-built_in\">log</span>*\nyarn-<span class=\"hljs-built_in\">debug</span>.<span class=\"hljs-built_in\">log</span>*\nyarn-<span class=\"hljs-built_in\">error</span>.<span class=\"hljs-built_in\">log</span>*\n\n# Sys\n.DS_Store\n\n# Node\nnode_modules/\n\n# Build\ndist\nlib\nesm\n\n# Test\ncoverage\n</code></pre>\n<p>往往在使用 Git 提交（Commit）代码之前，我们希望先对新加入暂存区代码进行一下检查，并且规范提交信息（Commit Message），这个时候我们需要三个工具：</p>\n<ul>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Ftypicode.github.io%2Fhusky%2F%23%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://typicode.github.io/husky/#/\" ref=\"nofollow noopener noreferrer\">husky</a>： husky 能让你创建勾子（Hook），这些钩子会在指定时候执行。</li>\n</ul>\n\n<ul>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fcommitlint.js.org%2F%23%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://commitlint.js.org/#/\" ref=\"nofollow noopener noreferrer\">commitlint</a>：commitlint 会按照一定的规则对你的提交信息进行检查。</li>\n</ul>\n\n<ul>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fokonet%2Flint-staged\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/okonet/lint-staged\" ref=\"nofollow noopener noreferrer\">lint-staged</a>：lint-staged 只会对你的新加入暂存区的文件进行指定的操作。</li>\n</ul>\n<p>我们首先安装 husky：</p>\n<pre><code class=\"hljs language-csharp\" lang=\"csharp\">$ npx husky-<span class=\"hljs-keyword\">init</span> &amp;&amp; npm install\n</code></pre>\n<p>然后初始化两个钩子：pre-commit（在提交前执行后面的命令）和 commit-msg（在提交的时候执行后面的命令）：</p>\n<pre><code class=\"hljs language-shell\" lang=\"shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"bash\">npx husky add .husky/pre-commit <span class=\"hljs-string\">'npx lint-staged'</span></span>\n</code></pre>\n<pre><code class=\"hljs language-shell\" lang=\"shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"bash\">npx husky add .husky/commit-msg <span class=\"hljs-string\">'npx --no-install commitlint --edit \"$1\"'</span></span>\n</code></pre>\n<p>然后我们来安装上面提到的 lint-staged，并且修改 <code>package.json</code> 如下：</p>\n<pre><code class=\"hljs language-ruby\" lang=\"ruby\"><span class=\"hljs-variable\">$ </span>npx mrm<span class=\"hljs-variable\">@2</span> lint-staged --save-dev\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\">{\n  <span class=\"hljs-string\">\"lint-staged\"</span>: {\n    <span class=\"hljs-string\">\"*.js\"</span>: [<span class=\"hljs-string\">\"eslint --fix\"</span>] <span class=\"hljs-comment\">// 在提交前用 eslint 修复所有 js 文件</span>\n  }\n}\n</code></pre>\n<p>最后安装 commitlint 并且生成配置文件：</p>\n<pre><code class=\"hljs language-bash\" lang=\"bash\"><span class=\"hljs-comment\"># Mac 等系统</span>\n$ npm install --save-dev @commitlint/{cli,config-conventional}\n\n<span class=\"hljs-comment\"># Windows 系统</span>\n$ npm install --save-dev @commitlint/config-conventional @commitlint/cli\n</code></pre>\n<pre><code class=\"hljs language-ini\" lang=\"ini\">$ echo \"<span class=\"hljs-attr\">module.exports</span> = { extends: [<span class=\"hljs-string\">'@commitlint/config-conventional'</span>] }<span class=\"hljs-comment\">;\" &gt; commitlint.config.js</span>\n</code></pre>\n<p>上面我们使用的 <code>config-conventional</code> 这个规则，具体可以参考<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fconventional-changelog%2Fcommitlint%2Ftree%2Fmaster%2F%40commitlint%2Fconfig-conventional\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/conventional-changelog/commitlint/tree/master/@commitlint/config-conventional\" ref=\"nofollow noopener noreferrer\">这里</a>。</p>\n<p>这之后我们来提交第一次提交代码：<code>git add . &amp;&amp; git commit -m \"chore: init local env\"</code>，一切正常的话控制台输出图如下：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d28a7a789ec6474081578caacfc8b41a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-5\">持续化集成（CI）</h2>\n<p>最后来到我们的持续化集成（CI）：频繁地（一天多次）将代码集成到主干。持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。更多 CI 的概念可以参考阮一峰老师的<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F09%2Fcontinuous-integration.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" ref=\"nofollow noopener noreferrer\">这篇文章</a>。</p>\n<p>所以我希望每次我们 push 代码，或者提交 PR（Pull Request）的时候都对代码进行检测（Lint），测试（Test）和构建（Build）。如果任何一个不成功就显示失败。</p>\n<p>首先我们需要 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fnpm-run-all\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://www.npmjs.com/package/npm-run-all\" ref=\"nofollow noopener noreferrer\">npm-run-all</a> 来顺序或者并行执行多个 npm 脚本命令：</p>\n<pre><code class=\"hljs language-css\" lang=\"css\">$ npm install npm-run-<span class=\"hljs-attribute\">all</span> <span class=\"hljs-attr\">--save-dev</span>\n</code></pre>\n<p>然后在 <code>package.json</code> 里面添加对应的 CI 命令，<code>run-s</code> 是指顺序执行：</p>\n<pre><code class=\"hljs language-json\" lang=\"json\"><span class=\"hljs-punctuation\">{</span>\n   <span class=\"hljs-attr\">\"scripts\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">\"ci\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"run-s lint test build\"</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>然后我们使用 Github Action 来完成持续化集成。Action（动作）是指持续化集成的操作，比如上面提到的测试、构建和检测等等。Github 需要配置文件来知道 CI 的流程。</p>\n<p>我们在项目的根目录新建一个 <code>.github</code> 的文件夹，然后在里面新建一个名叫 <code>workflows</code> 的文件夹，最后新建一个 <code>ci.yml</code> 的文件并且输入以下的内容。</p>\n<pre><code class=\"hljs language-yaml\" lang=\"yaml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">ci</span>\n\n<span class=\"hljs-attr\">on:</span> [<span class=\"hljs-string\">push</span>, <span class=\"hljs-string\">pull_request</span>]\n\n<span class=\"hljs-attr\">jobs:</span>\n  <span class=\"hljs-attr\">build:</span>\n    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">macOS-latest</span>\n    \n    <span class=\"hljs-attr\">steps:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2.3.4</span>\n        \n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Setup</span> <span class=\"hljs-string\">Node.js</span> <span class=\"hljs-string\">environment</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/setup-node@v2.1.5</span>\n        <span class=\"hljs-attr\">with:</span>\n          <span class=\"hljs-attr\">node-version:</span> <span class=\"hljs-string\">\"12\"</span>\n          \n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Cache</span> <span class=\"hljs-string\">node</span> <span class=\"hljs-string\">modules</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/cache@v2</span>\n        <span class=\"hljs-attr\">env:</span>\n          <span class=\"hljs-attr\">cache-name:</span> <span class=\"hljs-string\">cache-node-modules</span>\n        <span class=\"hljs-attr\">with:</span>\n          <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">./node_modules</span>\n          <span class=\"hljs-attr\">key:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">runner.os</span> <span class=\"hljs-string\">}}-build-cache-node-modules-${{</span> <span class=\"hljs-string\">hashFiles('**/package.json')</span> <span class=\"hljs-string\">}}</span>\n          <span class=\"hljs-attr\">restore-keys:</span> <span class=\"hljs-string\">|\n            cache-node-modules-\n</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Run</span> <span class=\"hljs-string\">ci</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">|\n          npm install\n          npm run ci\n</span></code></pre>\n<p>上面有几个地方很关键：首先是 <code>on: [push, pull_request]</code>，说明是在 push 和 pull_request 的时候会触发当前的这个工作流（Workflow）：持续集成一次运行的过程。然后每一个工作流包含多个步骤（Step），我们重点关注最后一个步骤：<code>Run ci</code>。可以发现这个步骤主要由两个动作构成：<code>npm install</code> 用来安装依赖，<code>npm run ci</code> 来真正执行我们的 CI 流程。</p>\n<p>这个时候我们在 Github 上新建一个名叫 Sparrow 的仓库，并且和本地这个仓库关联起来。接下来提交代码并且推到远程仓库：</p>\n<p><code>git commit -m \"chore: add ci\" &amp;&amp; git push</code></p>\n<p>这个时候就会自动触发 CI 了：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e04b1468a6149cd8ef7123a1513fe56~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>CI 结束之后如下就说明没有问题了！</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe3d455546274b1d99a9d98d52668b95~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>Github Action 的深入学习同样可以参考阮一峰老师的<a href=\"https://link.juejin.cn?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2019%2F09%2Fgetting-started-with-github-actions.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html\" ref=\"nofollow noopener noreferrer\">另一篇文章</a>。</p>\n<h2 data-id=\"heading-6\">总结</h2>\n<p>目前为止我们的开发环境就搭建完成了，此刻的代码可以在这个<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fchore%2Fenv\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/chore/env\" ref=\"nofollow noopener noreferrer\">分支</a>查看。总结一下一个比较完整的开发环境可以让我们有以下能力：</p>\n<ul>\n<li>代码检测：来保证代码的风格正确</li>\n<li>代码测试：保证代码的功能正确</li>\n<li>代码构建：保证我们的代码可以在不同环境里面运行</li>\n<li>版本管理：保证协同开发的统一性</li>\n<li>持续化集：成保证代码高质量快速迭代</li>\n</ul>\n<p>下一章我们将开发用于 Sparrow 的数据渲染模块：渲染器（Renderer）。</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "6\n实战：渲染引擎 - Renderer\n学习时长: 54分37秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><blockquote>\n<p>感谢<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FAarebecca\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/Aarebecca\" ref=\"nofollow noopener noreferrer\">厨神</a>参与这篇文章：什么是渲染引擎、为什么需要渲染引擎以及 @antv/g 相关部分的写作！</p>\n</blockquote>\n<p>之前在使用 SVG 开发一个条形图的过程中，我们发现有一些地方不方便。比如我们每次绘制一个元素，都需要三步：创建元素，设置元素属性，最后再挂载元素。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 创建元素 </span>\n<span class=\"hljs-keyword\">const</span> rect = <span class=\"hljs-title function_\">createSVGElement</span>(<span class=\"hljs-string\">'rect'</span>); \n\n<span class=\"hljs-comment\">// 设置属性 </span>\nrect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'x'</span>, <span class=\"hljs-number\">10</span>); \nrect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'y'</span>, <span class=\"hljs-number\">10</span>); \nrect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'fill'</span>, <span class=\"hljs-string\">'red'</span>); \nrect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'width'</span>, <span class=\"hljs-number\">50</span>); \nrect.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'height'</span>, <span class=\"hljs-number\">50</span>); \n\n<span class=\"hljs-comment\">// 挂载元素 </span>\ng.<span class=\"hljs-title function_\">appendChild</span>(<span class=\"hljs-string\">'rect'</span>);\n</code></pre>\n<p>当画布中元素较少时，这种方式还可以忍受。但随着元素数量的增长，这会变得非常冗余和繁琐。所以我们需要开发一个非常简单和轻量级的<strong>渲染引擎（Renderer)</strong> &nbsp;，用它简化我们绘图的流程。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c6c10529aa1492eaffaa83d9dc2688a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>通过上图可以发现：Sparrow 将选择 SVG 而不是 Canvas2D 来作为绘图技术，这是因为 Sparrow 对性能没有要求，同时 SVG 相对于 Canvas2D 更好测试一点（SVG 有 DOM 结构，可以直接检查 DOM 来进行调试）。</p>\n<p>接下来我们先从什么是渲染引擎讲起以及可视化需要它的原因，然后实现一个简单的渲染引擎，最后会简单拓展一下开源社区一些优秀的渲染引擎。</p>\n<h2 data-id=\"heading-0\">什么是渲染引擎</h2>\n<p>渲染引擎这一概念在不同领域有着不同的含义。对于前端开发者来数，渲染引擎是&nbsp;<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fwebkit.org%2F\" title=\"https://link.juejin.cn/?target=https%3A%2F%2Fwebkit.org%2F\" target=\"_blank\">WebKit</a>、<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fwww.chromium.org%2Fblink\" title=\"https://link.juejin.cn/?target=https%3A%2F%2Fwww.chromium.org%2Fblink\" target=\"_blank\">Blink</a>&nbsp;这样的浏览器排版引擎（或者说是内核），它负责解析 HTML 和 CSS 文档，并决定了文档里的元素将以怎样的形式放置在页面中的什么位置（即排版）。</p>\n<p>对于艺术和计算机动画工作者来说，渲染引擎是基础图形绘制库，一般具有以下特点：</p>\n<ul>\n<li>能够绘制基本图形，如：点、直线、多边形、曲线等</li>\n<li>支持图形内部填充、阴影效果等</li>\n<li>支持纹理与贴图</li>\n<li>抗锯齿以及亚像素优化</li>\n<li>跨平台运行</li>\n</ul>\n<p>更高阶的渲染引擎甚至支持粒子系统、光线追踪等效果。</p>\n<p>在数据可视化与可视分析领域，尤其是前端可视化方向，我们所使用的渲染引擎更偏向后者，但又有所区别。受平台及场景制约，前端可视化渲染引擎在具备上述特点的同时，还需要具备高性能、轻量化的特性，以满足在低网络传输带宽、低绘制性能等极端场景下的图形渲染需求。此外，在面向分析的可视化领域，3D 视图可能会导致意料之外的错误感知与洞察，因此 2D 渲染引擎得到了更大规模的应用。</p>\n<h2 data-id=\"heading-1\">为什么需要渲染引擎</h2>\n<p>用户大可直接在浏览器提供的 Canvas2D, SVG 和 WebGL 中使用原生语法直接绘制想要的图形，那么为什么还需要渲染引擎呢？包括上面提到的，这里给出几点原因：</p>\n<ul>\n<li>管理图元：使用渲染引擎能够更轻松的绘制并管理图形元素。</li>\n<li>提供完善的动画与事件机制：原生语法绘制动画相对比较麻烦。</li>\n<li>性能优化：渲染引擎基于底层渲染器的特性进行了大量优化工作，如脏矩阵渲染、分层渲染等，能够取得更好的渲染性能。使得开发者能够专注于视图的构建。</li>\n<li>多个渲染器之间任意切换：如果有同时在这两种渲染器中进行绘制的需求，需要针对不同的渲染器进行单独开发，提高工作量的同时也难以保证其一致性。使用渲染引擎绘制时只需要指定所需的渲染器即可完成切换。</li>\n</ul>\n<p>现在我们从概念上简单聊了一下渲染引擎，就像我们一直强调的：具体的实战能帮助我们更好的理解概念，所以接下来我们就来开发 Sparrow 需要的渲染引擎。</p>\n<h2 data-id=\"heading-2\">功能设计</h2>\n<p>每一次开发都伴随着功能设计，它是我们接下来开发时候依据的蓝图。</p>\n<p>因为 Sparrow 的功能相对简单，所以我们渲染器的功能用不复杂，主要侧重于更加轻松地绘制并且管理图形元素，简化我们绘制图形的流程。它主要有两个功能：</p>\n<ul>\n<li>绘制基本图形：支持 <code>rect</code>、<code>circle</code>、<code>line</code>、<code>path</code>、<code>text</code>、<code>ring</code> 这几种基本图形的绘制。</li>\n<li>进行坐标系变换：支持&nbsp;<code>translate</code>，<code>scale</code>，<code>rotate</code>&nbsp;这三种变换，同时可以使用类似&nbsp;<code>Canvas2D</code>&nbsp;的&nbsp;<code>save</code>&nbsp;和&nbsp;<code>restore</code>&nbsp;去管理坐标系变换的状态。</li>\n</ul>\n<p>具体期望的使用方法如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { createRenderer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'renderer'</span>; \n\n<span class=\"hljs-comment\">// 创建渲染器</span>\n<span class=\"hljs-keyword\">const</span> renderer = <span class=\"hljs-title function_\">createRenderer</span>(<span class=\"hljs-number\">600</span>, <span class=\"hljs-number\">400</span>);\n\n<span class=\"hljs-comment\">// 绘制基本图形 </span>\nrenderer.<span class=\"hljs-title function_\">rect</span>({\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">10</span>, \n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">10</span>, \n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">50</span>, \n  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">50</span>, \n  <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'red'</span>, \n});\n\n<span class=\"hljs-comment\">// 坐标变换 </span>\nrenderer.<span class=\"hljs-title function_\">save</span>(); \nrenderer.<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>); \nrenderer.<span class=\"hljs-title function_\">rect</span>({ \n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">10</span>, \n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">10</span>, \n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">50</span>, \n  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">50</span> \n}); \nrenderer.<span class=\"hljs-title function_\">restore</span>();\n</code></pre>\n<p>在开始将我们的功能设计落地之前，我们再来看看额外的一个和测试相关的约定。</p>\n<h2 data-id=\"heading-3\">测试约定</h2>\n<p><strong>本项目是测试驱动的，所以会有测试代码，但是不会在文章里面介绍它们。</strong> &nbsp;这主要是因为是因为篇幅有限，同时不是小册子的核心内容。当然每当我们新增一个功能的时候，会给出测试代码的仓库地址，大家完成相应的功能可以用提供的测试代码来验证功能是否正确。</p>\n<p>比如大家开发完成了&nbsp;<code>foo</code>&nbsp;这个函数，就可以增加以下的测试代码，然后运行：<code>npx jest __tests__/hello.spec.js</code>&nbsp;看是否有问题。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// __tests__/hello.spec.js </span>\n\n<span class=\"hljs-keyword\">import</span> { foo } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../src/foo'</span>; \n\n<span class=\"hljs-title function_\">describe</span>(<span class=\"hljs-string\">'test foo'</span>, <span class=\"hljs-function\">() =&gt;</span> { \n  <span class=\"hljs-title function_\">it</span>(<span class=\"hljs-string\">'should returns foo'</span>, <span class=\"hljs-function\">() =&gt;</span> { \n    <span class=\"hljs-title function_\">expect</span>(<span class=\"hljs-title function_\">hello</span>()).<span class=\"hljs-title function_\">toBe</span>(<span class=\"hljs-string\">'foo'</span>); \n  }); \n});\n</code></pre>\n<p>同时我们在写代码的过程中不会完全遵循 <code>airbnb-base</code> 的规范，所以需要修改 .eslintrc.js 如下，关闭一些规则的校验。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// .eslintrc.js</span>\n<span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = {\n  <span class=\"hljs-attr\">env</span>: {\n    <span class=\"hljs-attr\">browser</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">es2021</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">node</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">jest</span>: <span class=\"hljs-literal\">true</span>,\n  },\n  <span class=\"hljs-attr\">extends</span>: [<span class=\"hljs-string\">'airbnb-base'</span>],\n  <span class=\"hljs-attr\">parserOptions</span>: {\n    <span class=\"hljs-attr\">ecmaVersion</span>: <span class=\"hljs-number\">13</span>,\n    <span class=\"hljs-attr\">sourceType</span>: <span class=\"hljs-string\">'module'</span>,\n  },\n  <span class=\"hljs-attr\">rules</span>: {\n    <span class=\"hljs-comment\">// 关闭 eslint 的如下功能</span>\n    <span class=\"hljs-string\">'import/prefer-default-export'</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-string\">'no-use-before-define'</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-string\">'no-shadow'</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-string\">'no-restricted-syntax'</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-string\">'no-return-assign'</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-string\">'no-param-reassign'</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-string\">'no-sequences'</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-string\">'no-loop-func'</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-string\">'no-nested-ternary'</span>: <span class=\"hljs-number\">0</span>,\n  },\n};\n</code></pre>\n<p>不小心又说了这么多废话，接下来我们直接进入开发！</p>\n<h2 data-id=\"heading-4\">创建渲染引擎（createRenderer）</h2>\n<p>我们首先来实现 <code>createRenderer</code> 这个函数来返回我们的渲染器对象。它的所有功能都是通过这个对象对外暴露的。根据上面的功能设计，我们不难得到以下的代码。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/renderer/renderer.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createContext } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./context'</span>;\n<span class=\"hljs-keyword\">import</span> {\n  line, circle, text, rect, path, ring,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./shape'</span>;\n<span class=\"hljs-keyword\">import</span> {\n  restore, save, scale, translate, rotate,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./transform'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createRenderer</span>(<span class=\"hljs-params\">width, height</span>) {\n  <span class=\"hljs-keyword\">const</span> context = <span class=\"hljs-title function_\">createContext</span>(width, height); <span class=\"hljs-comment\">// 创建上下文信息</span>\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">line</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">options</span>) =&gt;</span> <span class=\"hljs-title function_\">line</span>(context, options), \n    <span class=\"hljs-attr\">circle</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">options</span>) =&gt;</span> <span class=\"hljs-title function_\">circle</span>(context, options),\n    <span class=\"hljs-attr\">text</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">options</span>) =&gt;</span> <span class=\"hljs-title function_\">text</span>(context, options),\n    <span class=\"hljs-attr\">rect</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">options</span>) =&gt;</span> <span class=\"hljs-title function_\">rect</span>(context, options),\n    <span class=\"hljs-attr\">path</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">options</span>) =&gt;</span> <span class=\"hljs-title function_\">path</span>(context, options),\n    <span class=\"hljs-attr\">ring</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">options</span>) =&gt;</span> <span class=\"hljs-title function_\">ring</span>(context, options), <span class=\"hljs-comment\">// 绘制圆环</span>\n    <span class=\"hljs-attr\">restore</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">restore</span>(context),\n    <span class=\"hljs-attr\">save</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">save</span>(context),\n    <span class=\"hljs-attr\">scale</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =&gt;</span> <span class=\"hljs-title function_\">scale</span>(context, ...args),\n    <span class=\"hljs-attr\">rotate</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =&gt;</span> <span class=\"hljs-title function_\">rotate</span>(context, ...args),\n    <span class=\"hljs-attr\">translate</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =&gt;</span> <span class=\"hljs-title function_\">translate</span>(context, ...args),\n    <span class=\"hljs-attr\">node</span>: <span class=\"hljs-function\">() =&gt;</span> context.<span class=\"hljs-property\">node</span>, <span class=\"hljs-comment\">// 下面会讲解</span>\n    <span class=\"hljs-attr\">group</span>: <span class=\"hljs-function\">() =&gt;</span> context.<span class=\"hljs-property\">group</span>, <span class=\"hljs-comment\">// 下面会讲解</span>\n  };\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/renderer/index.js</span>\n\n<span class=\"hljs-keyword\">export</span> { createRenderer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./renderer'</span>;\n</code></pre>\n<p>通过上面的代码我们可以发现：在初始化一个渲染器的时候，首先会去创建一个上下文 ，然后再把它给其他函数使用。接下来我们先看看上下文的创建，之后再实现其他函数。</p>\n<h2 data-id=\"heading-5\">创建上下文（createContext）</h2>\n<p>对于渲染引擎来说，上下文（Context）主要用于保存一些绘制或者其他功能需要的全局的信息，比如挂载画布的容器，当前的填充颜色，边框粗细等。</p>\n<p>对于 Sparrow 需要的渲染器来说，它需要的 Context 比较简单：</p>\n<ul>\n<li>画布节点：这是一个 svg 节点，方便使用者将其挂载到 DOM 需要的位置。</li>\n<li>挂载节点：这是一个 g 节点，是当前可以挂载新元素的节点。后面可以看到，我们可以通过更新它来到达管理坐标系变换的功能。</li>\n</ul>\n<p>Context 的创建是由如下的&nbsp;<code>createContext(width, height)</code>&nbsp;这个函数实现的。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/renderer/context.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createSVGElement, mount } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createContext</span>(<span class=\"hljs-params\">width, height</span>) {\n  <span class=\"hljs-comment\">// 创建画布 svg 节点，并且设置宽高</span>\n  <span class=\"hljs-keyword\">const</span> svg = <span class=\"hljs-title function_\">createSVGElement</span>(<span class=\"hljs-string\">'svg'</span>);\n  svg.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'width'</span>, width);\n  svg.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'height'</span>, height);\n  svg.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'viewBox'</span>, <span class=\"hljs-string\">`0 0 <span class=\"hljs-subst\">${width}</span> <span class=\"hljs-subst\">${height}</span>`</span>);\n\n  <span class=\"hljs-comment\">// 创建挂载 g 节点，并且把该 g 节点挂载到 svg 节点上</span>\n  <span class=\"hljs-keyword\">const</span> g = <span class=\"hljs-title function_\">createSVGElement</span>(<span class=\"hljs-string\">'g'</span>);\n  <span class=\"hljs-title function_\">mount</span>(svg, g);\n\n  <span class=\"hljs-comment\">//返回画布节点和挂载节点</span>\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">node</span>: svg,\n    <span class=\"hljs-attr\">group</span>: g,\n  };\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/renderer/utils.js</span>\n\n<span class=\"hljs-comment\">// 创建 SVG 元素</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createSVGElement</span>(<span class=\"hljs-params\">type</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElementNS</span>(<span class=\"hljs-string\">'http://www.w3.org/2000/svg'</span>, type);\n}\n\n<span class=\"hljs-comment\">// 将 child 节点挂载到 parent 节点上面</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">mount</span>(<span class=\"hljs-params\">parent, child</span>) {\n  <span class=\"hljs-keyword\">if</span> (parent) {\n    parent.<span class=\"hljs-title function_\">appendChild</span>(child);\n  }\n}\n</code></pre>\n<p>在<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Fblob%2Fmain%2F__tests__%2Frenderer%2Frenderer.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/blob/main/__tests__/renderer/renderer.spec.js\" ref=\"nofollow noopener noreferrer\">这里</a>复制测试代码到本地，通过 <code>DEBUG_MODE=1 npx jest __tests__/renderer/renderer.spec.js</code> 运行它们，如果能得到下面的效果，那么就没有什么问题了。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9be0781bc77f4f97bf96c05dbd7bfb67~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>创建 Context 大概就是这样，接下来我们就看看如何基于这个 Context 去绘制基础图形。</p>\n<h2 data-id=\"heading-6\">绘制基本图形</h2>\n<p>像文章开头说的那样，在 SVG 环境下我们绘制一个基本图形需要三步：创建元素、设置属性和挂载元素。</p>\n<p>因为绘制不同的图形只是在创建元素阶段指定不同的元素类型，所以我们把上面三步封装成一个通用的&nbsp;<code>shape</code>&nbsp;函数：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/renderer/shape.js</span>\n\n<span class=\"hljs-keyword\">import</span> { applyAttributes, createSVGElement, mount } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">shape</span>(<span class=\"hljs-params\">type, context, attributes</span>) {\n  <span class=\"hljs-keyword\">const</span> { group } = context; <span class=\"hljs-comment\">// 挂载元素</span>\n  <span class=\"hljs-keyword\">const</span> el = <span class=\"hljs-title function_\">createSVGElement</span>(type); <span class=\"hljs-comment\">// 创建对应的元素</span>\n  <span class=\"hljs-title function_\">applyAttributes</span>(el, attributes); <span class=\"hljs-comment\">// 设置属性</span>\n\n  <span class=\"hljs-title function_\">mount</span>(group, el); <span class=\"hljs-comment\">// 挂载</span>\n  <span class=\"hljs-keyword\">return</span> el; <span class=\"hljs-comment\">// 返回该元素</span>\n\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/renderer/utils.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">applyAttributes</span>(<span class=\"hljs-params\">element, attributes</span>) {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(attributes)) {\n    <span class=\"hljs-comment\">// 这里需要把类似 strokeWidth 的属性转换成 stroke-width 的形式</span>\n    <span class=\"hljs-comment\">// 思路就是将大写字母替成 - + 对应的小写字母的形式</span>\n    <span class=\"hljs-comment\">// 下面涉及到正则匹配，不太了解的同学可以去下面的链接学习：</span>\n    <span class=\"hljs-comment\">// https://juejin.cn/post/6844903487155732494</span>\n    <span class=\"hljs-keyword\">const</span> kebabCaseKey = key.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-regexp\">/[A-Z]/g</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> <span class=\"hljs-string\">`-<span class=\"hljs-subst\">${d.toLocaleLowerCase()}</span>`</span>);\n    element.<span class=\"hljs-title function_\">setAttribute</span>(kebabCaseKey, value);\n  }\n}\n</code></pre>\n<p>当我们完成了 shape 函数之后，那么绘制 <code>line</code>、<code>rect</code>，<code>circle</code> 等这些基本元素就非常容易了，只要给&nbsp;<code>shape</code>&nbsp;传入不同的元素的种类并且根据需要进行简单增强即可。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/renderer/shape.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">line</span>(<span class=\"hljs-params\">context, attributes</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">shape</span>(<span class=\"hljs-string\">'line'</span>, context, attributes);\n}\n\n<span class=\"hljs-comment\">// rect 不支持 width 和 height 是负数，下面这种情况将绘制不出来</span>\n<span class=\"hljs-comment\">// &lt;rect width=\"-60\" height=\"-60\" x=\"100\" y=\"100\" /&gt; ❌</span>\n<span class=\"hljs-comment\">// 为了使其支持负数的 width 和 height，我们转换成如下的形式</span>\n<span class=\"hljs-comment\">// &lt;rect width=\"60\" height=\"60\" x=\"40\" y=\"40\" /&gt; ✅</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">rect</span>(<span class=\"hljs-params\">context, attributes</span>) {\n  <span class=\"hljs-keyword\">const</span> {\n    width, height, x, y,\n  } = attributes;\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">shape</span>(<span class=\"hljs-string\">'rect'</span>, context, {\n    ...attributes,\n    <span class=\"hljs-attr\">width</span>: <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">abs</span>(width),\n    <span class=\"hljs-attr\">height</span>: <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">abs</span>(height),\n    <span class=\"hljs-attr\">x</span>: width &gt; <span class=\"hljs-number\">0</span> ? x : x + width,\n    <span class=\"hljs-attr\">y</span>: height &gt; <span class=\"hljs-number\">0</span> ? y : y + height,\n  });\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">circle</span>(<span class=\"hljs-params\">context, attributes</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">shape</span>(<span class=\"hljs-string\">'circle'</span>, context, attributes);\n}\n\n<span class=\"hljs-comment\">// text 元素是将展示内容放在标签内部，而不是作为标签的属性</span>\n<span class=\"hljs-comment\">// &lt;text text='content' /&gt; ❌</span>\n<span class=\"hljs-comment\">// &lt;text&gt;content&lt;/text&gt; ✅</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">text</span>(<span class=\"hljs-params\">context, attributes</span>) {\n  <span class=\"hljs-keyword\">const</span> { text, ...rest } = attributes;\n  <span class=\"hljs-keyword\">const</span> textElement = <span class=\"hljs-title function_\">shape</span>(<span class=\"hljs-string\">'text'</span>, context, rest);\n  textElement.<span class=\"hljs-property\">textContent</span> = text; <span class=\"hljs-comment\">// 通过 textContent 设置标签内的内容</span>\n  <span class=\"hljs-keyword\">return</span> textElement;\n}\n\n<span class=\"hljs-comment\">// 对 path 不熟悉的同学可以去这里学习</span>\n<span class=\"hljs-comment\">// https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths</span>\n<span class=\"hljs-comment\">// path 的属性 d （路径）是一个字符串，拼接起来比较麻烦，这里我们通过数组去生成</span>\n<span class=\"hljs-comment\">// [</span>\n<span class=\"hljs-comment\">//  ['M', 10, 10],</span>\n<span class=\"hljs-comment\">//  ['L', 100, 100],</span>\n<span class=\"hljs-comment\">//  ['L', 100, 10],</span>\n<span class=\"hljs-comment\">//  ['Z'],</span>\n<span class=\"hljs-comment\">// ];</span>\n<span class=\"hljs-comment\">// 上面的二维数组会被转换成如下的字符串</span>\n<span class=\"hljs-comment\">// 'M 10 10 L 100 100 L 100 10 Z'</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">path</span>(<span class=\"hljs-params\">context, attributes</span>) {\n  <span class=\"hljs-keyword\">const</span> { d } = attributes;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">shape</span>(<span class=\"hljs-string\">'path'</span>, context, { ...attributes, <span class=\"hljs-attr\">d</span>: d.<span class=\"hljs-title function_\">flat</span>().<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">' '</span>) });\n}\n</code></pre>\n<p>除了支持 SVG 本来就有的图形之外，我们还需要额外支持一个图形（后面 Dount 图表会使用）：圆环（Ring）。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e57f063bc06745929e76004257799e90~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>我们将用三个圆去模拟一个圆环，它们的填充色都是透明的，其中两个圆的边框去模拟圆环的边框(上面的红色部分），用一个圆的边框去模拟圆环本身（上面蓝色部分）。实现细节如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ring</span>(<span class=\"hljs-params\">context, attributes</span>) {\n  <span class=\"hljs-comment\">// r1 是内圆的半径，r2 是外圆的半径</span>\n  <span class=\"hljs-keyword\">const</span> {\n    cx, cy, r1, r2, ...styles\n  } = attributes;\n  <span class=\"hljs-keyword\">const</span> { stroke, strokeWidth, fill } = styles;\n  <span class=\"hljs-keyword\">const</span> defaultStrokeWidth = <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">const</span> innerStroke = <span class=\"hljs-title function_\">circle</span>(context, {\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'transparent'</span>,\n    <span class=\"hljs-attr\">stroke</span>: stroke || fill,\n    strokeWidth,\n    cx,\n    cy,\n    <span class=\"hljs-attr\">r</span>: r1,\n  });\n  <span class=\"hljs-keyword\">const</span> ring = <span class=\"hljs-title function_\">circle</span>(context, {\n    ...styles,\n    <span class=\"hljs-attr\">strokeWidth</span>: r2 - r1 - (strokeWidth || defaultStrokeWidth),\n    <span class=\"hljs-attr\">stroke</span>: fill,\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'transparent'</span>,\n    cx,\n    cy,\n    <span class=\"hljs-attr\">r</span>: (r1 + r2) / <span class=\"hljs-number\">2</span>,\n  });\n  <span class=\"hljs-keyword\">const</span> outerStroke = <span class=\"hljs-title function_\">circle</span>(context, {\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'transparent'</span>,\n    <span class=\"hljs-attr\">stroke</span>: stroke || fill,\n    strokeWidth,\n    cx,\n    cy,\n    <span class=\"hljs-attr\">r</span>: r2,\n  });\n  <span class=\"hljs-keyword\">return</span> [innerStroke, ring, outerStroke];\n}\n</code></pre>\n<p>同样复制<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Fblob%2Fmain%2F__tests__%2Frenderer%2Fshape.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/blob/main/__tests__/renderer/shape.spec.js\" ref=\"nofollow noopener noreferrer\">这里</a>的测试代码并且运行，如果运行测试代码能得到如下的效果，那么就也没有什么大问题了。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2cb1d69390c4588a72ca36606976aac~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>实现了绘制图形就这个功能，那么接下来我们就来完成坐标系变换这个功能。</p>\n<h2 data-id=\"heading-7\">坐标系变换</h2>\n<p>通过前面的学习，我们了解到：在 SVG 中使用坐标变换的能力其实就是给 g 元素添加对应的 transform 属性，然后被 g 元素包裹的所有子元素都会应用这个 transform 属性所指定的变换。</p>\n<p>我们的目标让我们的渲染引擎支持：平移（translate）、放缩（Scale) 旋转（Rotate）这三种变换。这三种变换虽然名字和参数不同，但添加流程都是一样的，所以我们可以创建一个名叫&nbsp;<code>transform</code>&nbsp;的函数来统一这个流程。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/renderer/transform.js</span>\n\n<span class=\"hljs-keyword\">import</span> { applyTransform, createSVGElement, mount } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-params\">type, context, ...params</span>) {\n  <span class=\"hljs-comment\">// type 是希望的变换种类：scale，translate，rotate 等</span>\n  <span class=\"hljs-keyword\">const</span> { group } = context;\n  <span class=\"hljs-title function_\">applyTransform</span>(group, <span class=\"hljs-string\">`<span class=\"hljs-subst\">${type}</span>(<span class=\"hljs-subst\">${params.join(<span class=\"hljs-string\">', '</span>)}</span>)`</span>);\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/renderer/utils.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">applyTransform</span>(<span class=\"hljs-params\">element, transform</span>) {\n  <span class=\"hljs-keyword\">const</span> oldTransform = element.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">'transform'</span>) || <span class=\"hljs-string\">''</span>;\n  <span class=\"hljs-comment\">// 将新的变换指定到后面的变换后，这里需要字符串拼接</span>\n  <span class=\"hljs-keyword\">const</span> prefix = oldTransform ? <span class=\"hljs-string\">`<span class=\"hljs-subst\">${oldTransform}</span> `</span> : <span class=\"hljs-string\">''</span>;\n  element.<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">'transform'</span>, <span class=\"hljs-string\">`<span class=\"hljs-subst\">${prefix}</span><span class=\"hljs-subst\">${transform}</span>`</span>);\n}\n</code></pre>\n<p>这之后就不难实现如下的坐标系变换了。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/renderer/transform.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-params\">context, tx, ty</span>) {\n  <span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-string\">'translate'</span>, context, tx, ty);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">rotate</span>(<span class=\"hljs-params\">context, theta</span>) {\n  <span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-string\">'rotate'</span>, context, theta);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-params\">context, sx, sy</span>) {\n  <span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-string\">'scale'</span>, context, sx, sy);\n}\n</code></pre>\n<p>在使用坐标系变换的时候，除了应用对应变换之外，还应该实现对变换状态的管理。这个地方的核心就是控制当前变换影响的元素范围。基于 SVG 通过 g 元素来指定变换的特点，我们只用更新当前挂载节点，使得当前变换只会影响当前挂载节点下面的元素即可。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/renderer/transform.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">save</span>(<span class=\"hljs-params\">context</span>) {\n  <span class=\"hljs-keyword\">const</span> { group } = context;\n  <span class=\"hljs-keyword\">const</span> newGroup = <span class=\"hljs-title function_\">createSVGElement</span>(<span class=\"hljs-string\">'g'</span>);\n  <span class=\"hljs-title function_\">mount</span>(group, newGroup);\n  context.<span class=\"hljs-property\">group</span> = newGroup;\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/renderer/transform.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">restore</span>(<span class=\"hljs-params\">context</span>) {\n  <span class=\"hljs-keyword\">const</span> { group } = context;\n  <span class=\"hljs-keyword\">const</span> { parentNode } = group;\n  context.<span class=\"hljs-property\">group</span> = parentNode;\n}\n</code></pre>\n<p>一切正常的话，运行<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Fblob%2Fmain%2F__tests__%2Frenderer%2Ftransform.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/blob/main/__tests__/renderer/transform.spec.js\" ref=\"nofollow noopener noreferrer\">这里</a>的测试代码会有以下效果：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f77b14702d64565879b080bebe455de~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>Sparrow 需要的渲染引擎我们已经完成啦，完整的代码可以在<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2Fsrc%2Frenderer\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/src/renderer\" ref=\"nofollow noopener noreferrer\">这里</a>查看。</p>\n<h2 data-id=\"heading-8\">拓展</h2>\n<p>虽然上面渲染引擎的开发很简单，但是一个真正优秀的渲染引擎远不如此。接下来我们就来了解几个社区上优秀且强大的渲染引擎。</p>\n<p>首先我们来看看 <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fg\" title=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fg\" target=\"_blank\">@antv/g</a>&nbsp;，它是 AntV 技术栈&nbsp;<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fg2\" title=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fg2\" target=\"_blank\">G2</a>、<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fg6\" title=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fg6\" target=\"_blank\">G6</a>&nbsp;等成员的底层渲染引擎（最近 @antv/g 也发布了5.0，大家可以去了解一下！），它具有以下特点：</p>\n<ul>\n<li>强大、可扩展的渲染能力，并内置常用的基础图形。</li>\n<li>极致的渲染性能，支持大数据量的可视化场景。</li>\n<li>完整模拟浏览器 DOM 的事件，与原生事件的表现无差异。</li>\n<li>流畅的动画实现，以及丰富的配置接口。</li>\n<li>同时提供 Canvas 和 SVG 版本的实现，且两者的 API 基本保持一致。</li>\n</ul>\n<p>用 @antv/g 绘制一个简单的红色的圆形的代码如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 引入并选择渲染器</span>\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Renderer</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">CanvasRenderer</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@antv/g-svg'</span>;\n<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Canvas</span>, <span class=\"hljs-title class_\">Circle</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@antv/g'</span>;\n\n\n<span class=\"hljs-comment\">// 实例化渲染器</span>\n<span class=\"hljs-keyword\">const</span> canvasRenderer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CanvasRenderer</span>();\n\n<span class=\"hljs-comment\">// 创建一个新的 G 画布</span>\n<span class=\"hljs-keyword\">const</span> canvas = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Canvas</span>({\n  <span class=\"hljs-attr\">container</span>: <span class=\"hljs-string\">'container'</span>, <span class=\"hljs-comment\">// 画布的 DOM ID</span>\n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">500</span>, <span class=\"hljs-comment\">// 画布宽度</span>\n  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">500</span>, <span class=\"hljs-comment\">// 画布高度</span>\n  <span class=\"hljs-attr\">renderer</span>: canvasRenderer, <span class=\"hljs-comment\">// 渲染器实例化对象</span>\n});\n\n<span class=\"hljs-comment\">// 创建一个圆形</span>\n<span class=\"hljs-keyword\">const</span> circle = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Circle</span>({\n  <span class=\"hljs-attr\">style</span>: {\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">250</span>,\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">250</span>,\n    <span class=\"hljs-attr\">r</span>: <span class=\"hljs-number\">100</span>,\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'red'</span>,\n  },\n});\n\n<span class=\"hljs-comment\">// 绘制圆形</span>\ncanvas.<span class=\"hljs-title function_\">appendChild</span>(circle);\n</code></pre>\n<p>如果说 @antv/g 更注重性能上的提升，那么<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fp5js.org%2Fzh-Hans%2F\" title=\"https://link.juejin.cn/?target=https%3A%2F%2Fp5js.org%2Fzh-Hans%2F\" target=\"_blank\">p5.js</a>&nbsp;就更注重易用性。</p>\n<p>p5.js 表面上说是一个面向艺术家、设计师、教育家、初学者以及任何其他人的创意编程库，但是它本身其实是一个渲染引擎。它不仅提供了一套完整，简洁的绘制接口，还对 HTML5 元素（如文字、输入框、视屏、摄像头及音频）的使用有支持。</p>\n<p>下面我们同样来看看 p5.js 是如何绘制一个圆形的。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">setup</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title function_\">createCanvas</span>(<span class=\"hljs-number\">400</span>, <span class=\"hljs-number\">400</span>);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">draw</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title function_\">background</span>(<span class=\"hljs-number\">220</span>);\n  <span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-string\">'red'</span>);\n  <span class=\"hljs-title function_\">circle</span>(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span>);\n}\n</code></pre>\n<p>@antv/g 和 p5js 都是绘制常规风格元素的渲染引擎，<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Froughjs.com%2F\" title=\"https://link.juejin.cn/?target=https%3A%2F%2Froughjs.com%2F\" target=\"_blank\">rough.js</a>&nbsp;就不一样了：它绘制出来元素的效果都是手绘风格！</p>\n<pre><code class=\"hljs language-js\" lang=\"js\">rc.<span class=\"hljs-title function_\">circle</span>(<span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">80</span>, { <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'red'</span> }); <span class=\"hljs-comment\">// fill with red hachure</span>\nrc.<span class=\"hljs-title function_\">rectangle</span>(<span class=\"hljs-number\">120</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">80</span>, <span class=\"hljs-number\">80</span>, { <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'red'</span> });\nrc.<span class=\"hljs-title function_\">circle</span>(<span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">150</span>, <span class=\"hljs-number\">80</span>, {\n  <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"rgb(10,150,10)\"</span>,\n  <span class=\"hljs-attr\">fillWeight</span>: <span class=\"hljs-number\">3</span> <span class=\"hljs-comment\">// thicker lines for hachure</span>\n});\nrc.<span class=\"hljs-title function_\">rectangle</span>(<span class=\"hljs-number\">220</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">80</span>, <span class=\"hljs-number\">80</span>, {\n  <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'red'</span>,\n  <span class=\"hljs-attr\">hachureAngle</span>: <span class=\"hljs-number\">60</span>, <span class=\"hljs-comment\">// angle of hachure,</span>\n  <span class=\"hljs-attr\">hachureGap</span>: <span class=\"hljs-number\">8</span>\n});\nrc.<span class=\"hljs-title function_\">rectangle</span>(<span class=\"hljs-number\">120</span>, <span class=\"hljs-number\">105</span>, <span class=\"hljs-number\">80</span>, <span class=\"hljs-number\">80</span>, {\n  <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'rgba(255,0,200,0.2)'</span>,\n  <span class=\"hljs-attr\">fillStyle</span>: <span class=\"hljs-string\">'solid'</span> <span class=\"hljs-comment\">// solid fill</span>\n});\n</code></pre>\n<p>上面的代码绘制出来的效果如下：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7ca89ab5f4c485683a26feace1e8ced~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"68747470733a2f2f726f7567686a732e636f6d2f696d616765732f6d332e706e67.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-9\">作业</h2>\n<p>其实基于 roughjs 我们可以做出很多有意思的效果，比如我们可以基于 roughjs 封装和我们上面渲染器相同的 API 的手绘风格渲染器。这样当后面我们把 Sparrow 开发完成之后，我们只用修改渲染器就可以转换图表的绘制风格了。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { plot } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@sparrow-vis/sparrow\"</span>;\n<span class=\"hljs-keyword\">import</span> { createPlugin } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@sparrow-vis/rough-renderer\"</span>\n\n<span class=\"hljs-keyword\">const</span> data = [\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">\"Sports\"</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">275</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">\"Strategy\"</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">115</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">\"Action\"</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">120</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">\"Shooter\"</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">350</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">\"Other\"</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">150</span> },\n];\n\n<span class=\"hljs-keyword\">const</span> chart = <span class=\"hljs-title function_\">plot</span>({\n  data,\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"interval\"</span>,\n  <span class=\"hljs-attr\">renderer</span>: <span class=\"hljs-title function_\">createPlugin</span>(), <span class=\"hljs-comment\">// 使用自定义的渲染器</span>\n  <span class=\"hljs-attr\">encodings</span>: {\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">\"genre\"</span>,\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">\"sold\"</span>,\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"genre\"</span>\n  },\n});\n\n<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">\"container\"</span>).<span class=\"hljs-title function_\">appendChild</span>(chart);\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2c2f7e0f2dc445bab8eebed6dce660a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>这个作为作业大家可以自己尝试实现一下，也可以参考官方的<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Frough-renderer%2Ftree%2Fmain\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/rough-renderer/tree/main\" ref=\"nofollow noopener noreferrer\">实现</a>。</p>\n<h2 data-id=\"heading-10\">小结</h2>\n<p>这一章我们了解了什么是渲染引擎，并且也知道了它想要解决的问题，了解到一个比较完整的渲染引擎应该具有以下特点：</p>\n<ul>\n<li>轻松绘制和管理图形元素</li>\n<li>优秀的渲染性能</li>\n<li>对动画有比较好的支持</li>\n<li>兼容不同渲染技术</li>\n<li>完善的事件机制</li>\n</ul>\n<p>这之后我们通过开发一个简单的渲染引擎，完成了绘制元素和坐标变换这两个功能。不仅加深了对渲染引擎的理解，也为后面 Sparrow 的更加轻松地绘制图形打下基础。</p>\n<p>那么下一篇我们将进入第一个可视化模块的开发：比例尺（Scale），看看它是如何把数据属性映射为视觉属性的。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e93df0e7d1af400aa64f4ff03076c1b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>最后的最后，这章我们算是正式进入 Sparrow 的开发了!</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "7\n实战：比例尺 - Scale\n学习时长: 69分12秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>上一章我们认识并且开发了一个简单的渲染引擎。我们了解到渲染引擎主要负责数据可视化中的绘制部分，而接下来的比例尺（Scale），是就负责数据处理部分了。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e93df0e7d1af400aa64f4ff03076c1b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>比例尺是可视化中一个很重要且有用的抽象，主要用于将数据的某一个属性映射为图形的视觉属性，比如名字属性映射图形的颜色属性，身高属性映射为图形的位置属性。</p>\n<p>在<a href=\"https://juejin.cn/book/7031893648145186824/section/7032095221731033125\" target=\"_blank\" title=\"https://juejin.cn/book/7031893648145186824/section/7032095221731033125\">数据分析模型</a>那一章的最后我们提到，在设计一个可视化方案的时候，其中一个强有力的手段是“编码”，而编码就是通过比例尺完成。不同的数据需要不同的的编码方式，如何根据当前的数据选择合适的比例尺就是我们在可视化中遇见的一个常见的挑战。</p>\n<p>同时比例尺也是我们在使用一些图表库中比较难以理解、容易引起困惑的部分，比如有如下常见的问题：</p>\n<ul>\n<li>为啥最后坐标轴生成的刻度的数量和希望的不一样？</li>\n<li>nice 到底有什么用？</li>\n<li>Threshold, Quantile, Quantile 比例尺有什么区别？</li>\n</ul>\n<p>为了帮助大家更好的理解上面的这些问题，同时也为了给 Sparrow 提供数据映射的能力，我们接下来先从比例尺理论讲起，从根本上理解比例尺，然后通过实战加深对其理解，最后通过拓展去了解更多和比例尺相关的东西。</p>\n<h2 data-id=\"heading-0\">比例尺理论</h2>\n<p>比例尺的概念其实早就藏在我们的日常生活中了，比如我们有度量长度的比例尺：把空间上的一段距离映射为一个数字，有度量重量的比例尺：把一定重量映射为一个数字。</p>\n<p><strong>而在可视化中的比例尺，就是用来度量数据属性的，将数据抽象的属性映射为一个视觉属性</strong>。这决定了我们如何理解图形的颜色、大小、形状和位置等。选择一个比例尺的时候，需要我们去思考度量的是什么以及这些度量的含义，最终这些选择将决定我们如何理解一个图形。</p>\n<p>比如我们希望用点来代表某个数据集中的每一条数据，数据中有 sex 这一个属性，对应有两个值：male 和 female。我们选择用点的颜色去度量 sex 这个数据属性，如果一条数据的 sex 属性是 male 那么对应的点是红色，否者是绿色。所以在理解每一个点的时候，如果这个点是红色，那么它对应的数据的 sex 属性就是 male，否者就是 female。</p>\n<p>如果用代码把上面的功能如下描述：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-params\">value</span>) {\n  <span class=\"hljs-keyword\">return</span> value === <span class=\"hljs-string\">'male'</span> ? <span class=\"hljs-string\">'red'</span>: <span class=\"hljs-string\">'green'</span>;\n}\n\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">'male'</span>); <span class=\"hljs-comment\">// 'red'</span>\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">'female'</span>); <span class=\"hljs-comment\">// 'green'</span>\n</code></pre>\n<p>上面的代码非常的简单，但是通用性太差，只适用于这个特例。有没有什么通用的办法呢？当然是有的。</p>\n<p>其实不难发现，<strong>比例尺本质上是一个函数</strong>，会将一个值（变量）从一个特定的范围（定义域）映射到另一个特定的范围（值域）。定义域（Domain）是由数据的属性决定，值域（Range）是由图形的视觉属性决定。根据定义域和值域的不同，我们需要选择不同的比例尺。</p>\n<p>上面的 sex 和 颜色都是分类属性，所以会使用到我们之后要介绍的 Ordinal 比例尺，具体的使用方式如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 根据 options 返回一个函数</span>\n<span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createOrdinal</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-string\">'male'</span>, <span class=\"hljs-string\">'female'</span>], <span class=\"hljs-comment\">// 定义域</span>\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-string\">'red'</span>, <span class=\"hljs-string\">'green'</span>], <span class=\"hljs-comment\">// 值域</span>\n});\n\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">'male'</span>); <span class=\"hljs-comment\">// 'red'</span>\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">'female'</span>); <span class=\"hljs-comment\">// 'green'</span>\n</code></pre>\n<p>那么接下来我们就来看看不同的比例尺，分别了解它们的定义域和值域的类型、映射规则和使用场景。</p>\n<h2 data-id=\"heading-1\">Identity</h2>\n<p>我们首先看一个最简单的比例尺：Identity 比例尺。它的功能和它的名字一样：“恒等映射”，也就是将输入原封不动的返回。</p>\n<p>当希望数据的属性和图形的视觉属性保持一致的时候，我们就可以使用 Identity 比例尺，比如数据有一个属性是 color，而我们又希望我们图形的填充颜色和 color 保持一致，这个时候我们就可以使用 Identity 比例尺。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adfdfe54e4a74aae8dc650b23c759bd6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>Identity 比例尺的使用方式如下，它能保证输入和输出总是保持一致。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// Identity 是恒等映射，所以不需要指定定义域和值域</span>\n<span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createIdentity</span>();\n\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-title function_\">scale</span>({ <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> }); <span class=\"hljs-comment\">// { a: 1 }</span>\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">'sparrow'</span>); <span class=\"hljs-comment\">// 'sparrow'</span>\n</code></pre>\n<p>不难发现 Identity 比例尺可以表示为：<code>y = x</code>，而它的实现也非常的简单。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/identity.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createIdentity</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> x;\n}\n</code></pre>\n<h2 data-id=\"heading-2\">连续比例尺</h2>\n<p>看完了最简单的比例尺，我们来看看最常用的一类比例尺：连续比例尺（Continuous）。连续比例尺主要用于数值属性的映射，它的特点是定义域和值域都是连续的，它们之间的关系可以表示为：<code>y = a * f(x) + b</code>。</p>\n<p>对于所有的连续比例尺来说，除了拥有映射功能之外，还有一个很重要的功能：<strong>生成坐标轴需要的坐标刻度</strong>。在理解可视化图表的过程中，坐标轴往往是一个很好的辅助，因为它能给我们提供更多辅助信息。</p>\n<p>在知道了连续比例尺的两个主要功能后，接下来将给大家介绍并且实现 Linear 和 Time 两个比例尺，另外一个 Log 比例尺的实现将作为大家的练习。</p>\n<h3 data-id=\"heading-3\">Linear</h3>\n<p>(1) 线性映射</p>\n<p>Linear 比例尺是支持线性映射的比例尺，它的表达式 <code>y = a * f(x) + b</code> 中的 <code>f(x)</code> 应该为 <code>f(x) = x</code>。</p>\n<p>Linear 比例尺常常用于视觉元素的布局，比如在做散点图的时候，可以用 Linear 比例尺来完成对点的布局，比如将数据的某个数值属性映射为点的 x 坐标，将数据的另一个个数值属性映射为点的 y 坐标。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a96087ae573046158182330f405db527~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>它期望的使用方式如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createLinear</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>], <span class=\"hljs-comment\">// 输入的范围是 [0, 1]</span>\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>], <span class=\"hljs-comment\">// 输出的范围是 [0, 10]</span>\n})\n\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-number\">0.2</span>); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-number\">0.5</span>); <span class=\"hljs-comment\">// 5</span>\n</code></pre>\n<p>通过使用方式我们不难看出：<strong>输入在定义域里到两端的比例，应该和输出在值域到两端的比例相同</strong>，比如 <code>(0.2 - 0) / (1 - 0.2) </code>其实是和<code>(2 - 0) / (10 -2)</code> 一样的。</p>\n<p>基于这个发现我们首先通过计算出输入在定义域的位置（归一化），然后根据这个结果在值域计算出相应的输出（插值），具体实现如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/linear.js</span>\n\n<span class=\"hljs-keyword\">import</span> { normalize } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createLinear</span>(<span class=\"hljs-params\">{\n  domain: [d0, d1],\n  range: [r0, r1],\n  interpolate = interpolateNumber,\n}</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> t = <span class=\"hljs-title function_\">normalize</span>(x, d0, d1);\n    <span class=\"hljs-comment\">// 默认是使用线性的数值插值器</span>\n    <span class=\"hljs-comment\">// 如果是颜色可以使用颜色插入器</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">interpolate</span>(t, r0, r1);\n  };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">interpolateNumber</span>(<span class=\"hljs-params\">t, start, stop</span>) {\n  <span class=\"hljs-keyword\">return</span> start * (<span class=\"hljs-number\">1</span> - t) + stop * t;\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/utils.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">normalize</span>(<span class=\"hljs-params\">value, start, stop</span>) {\n  <span class=\"hljs-keyword\">return</span> (value - start) / (stop - start);\n}\n</code></pre>\n<p>最后将其可视化出来的结果如下图，可以发现输入 x 和输入 y 确实是线性相关的。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7851d519a2574addb9ed561e167dc422~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>如果将上面的数值插值器（interpolateNumber）换成颜色插值器的话，就会得到以下的效果，可以发现颜色是均匀变化的。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { interpolateNumber } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./linear'</span>;\n\n<span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createLinear</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n  <span class=\"hljs-attr\">range</span>: [\n    [<span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">255</span>], <span class=\"hljs-comment\">// 白色</span>\n    [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">255</span>], <span class=\"hljs-comment\">// 浅蓝色</span>\n  ],\n  <span class=\"hljs-attr\">interpolate</span>: interolateColor\n});\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">interolateColor</span>(<span class=\"hljs-params\">t, start, stop</span>) {\n  <span class=\"hljs-keyword\">const</span> r = <span class=\"hljs-title function_\">interpolateNumber</span>(t, start[<span class=\"hljs-number\">0</span>], stop[<span class=\"hljs-number\">0</span>]);\n  <span class=\"hljs-keyword\">const</span> g = <span class=\"hljs-title function_\">interpolateNumber</span>(t, start[<span class=\"hljs-number\">1</span>], stop[<span class=\"hljs-number\">1</span>]);\n  <span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-title function_\">interpolateNumber</span>(t, start[<span class=\"hljs-number\">2</span>], stop[<span class=\"hljs-number\">2</span>]);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`rgb(<span class=\"hljs-subst\">${r}</span>, <span class=\"hljs-subst\">${g}</span>, <span class=\"hljs-subst\">${b}</span>)`</span>;\n}\n</code></pre>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9999c22f70f64d35b980224c52d1b479~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>（2）ticks 和 nice</p>\n<p>介绍完 Linear 比例尺的映射功能，接下来我们来看看它生成坐标刻度的方法。下面我们首先来看看一个简单版本，看看它有啥问题。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// min: 定义域的最小值</span>\n<span class=\"hljs-comment\">// max: 定义域的最大值</span>\n<span class=\"hljs-comment\">// count: 坐标刻度的数量</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">simpleTicks</span>(<span class=\"hljs-params\">min, max, count</span>) {\n  <span class=\"hljs-keyword\">const</span> step = (max - min) / tickCount;\n  <span class=\"hljs-keyword\">const</span> values = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(count);\n  <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; count; i++) { \n    values[i] = min + step * i;\n  }\n  <span class=\"hljs-keyword\">return</span> values;\n}\n</code></pre>\n<p>上面的代码非常直觉，现在让我们来看看它的效果。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> ticks = <span class=\"hljs-title function_\">simpleTicks</span>(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">9.9</span>, <span class=\"hljs-number\">6</span>);\nticks <span class=\"hljs-comment\">// [0.1, 1.7333333333333336, 3.366666666666667, 5, 6.633333333333334, 8.266666666666667]</span>\n</code></pre>\n<p><code>simpleTicks</code> 方法确实按照要求生成了6个刻度，但是可读性太差：全是小数，那如果我们将这些刻度格式化一下呢？</p>\n<pre><code class=\"hljs language-js\" lang=\"js\">ticks.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> <span class=\"hljs-built_in\">parseFloat</span>(d.<span class=\"hljs-title function_\">toFixed</span>(<span class=\"hljs-number\">1</span>)));\nticks; <span class=\"hljs-comment\">// [0.1, 1.7, 3.4, 5, 6.6, 8.3];</span>\n</code></pre>\n<p>看上去好一点了，但是我们会发现刻度不是均匀的，也就是相邻的刻度之间的间隔不一样：<code>3.4 - 1.7 !== 1.7 - 0.1</code>。</p>\n<p>造成上面两个问题的根本原因就是我们没有选择合适的刻度间隔，也就是上面的 <code>const step = (max - min) / count;</code> 太过简单。对于 Linear 比例尺来说，合适的刻度间隔应该是是<strong>1或者2或者5乘上10的 n 次方</strong>的数，也就是说希望 <code>step = 10 ^ n * (1 | 2 | 5)</code>。</p>\n<p>获得上述刻度间隔的实现方式如下，该实现是来自于 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fd3%2Fd3-array%2Fblob%2Fmain%2Fsrc%2Fticks.js%23L46\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/d3/d3-array/blob/main/src/ticks.js#L46\" ref=\"nofollow noopener noreferrer\">d3-array</a>。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/utils.js</span>\n\n<span class=\"hljs-comment\">// step0 是生成指定数量的刻度的间隔</span>\n<span class=\"hljs-comment\">// step1 是最后生成的刻度的间隔</span>\n<span class=\"hljs-comment\">// 我们希望 step1 满足两个条件：</span>\n<span class=\"hljs-comment\">// 1. step1 = 10 ^ n * b (其中 b=1,2,5)</span>\n<span class=\"hljs-comment\">// 2. step0 和 step1 的误差尽量的小</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">tickStep</span>(<span class=\"hljs-params\">min, max, count</span>) {\n  <span class=\"hljs-keyword\">const</span> e10 = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sqrt</span>(<span class=\"hljs-number\">50</span>); <span class=\"hljs-comment\">// 7.07</span>\n  <span class=\"hljs-keyword\">const</span> e5 = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sqrt</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 3.16</span>\n  <span class=\"hljs-keyword\">const</span> e2 = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sqrt</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 1.41</span>\n\n  <span class=\"hljs-comment\">// 获得目标间隔 step0，设 step0 = 10 ^ m</span>\n  <span class=\"hljs-keyword\">const</span> step0 = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">abs</span>(max - min) / <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(<span class=\"hljs-number\">0</span>, count);\n  <span class=\"hljs-comment\">// 获得 step1 的初始值 = 10 ^ n &lt; step0，其中 n 为满足条件的最大整数</span>\n  <span class=\"hljs-keyword\">let</span> step1 = <span class=\"hljs-number\">10</span> ** <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">log</span>(step0) / <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">LN10</span>);\n  <span class=\"hljs-comment\">// 计算 step1 和 step0 的误差，error = 10 ^ m / 10 ^ n = 10 ^ (m - n)</span>\n  <span class=\"hljs-keyword\">const</span> error = step0 / step1;\n  <span class=\"hljs-comment\">// 根据当前的误差改变 step1 的值，从而减少误差</span>\n  <span class=\"hljs-comment\">// 1. 当 m - n &gt;= 0.85 = log(e10) 的时候，step1 * 10</span>\n  <span class=\"hljs-comment\">// 可以减少log(10) = 1 的误差 </span>\n  <span class=\"hljs-keyword\">if</span> (error &gt;= e10) step1 *= <span class=\"hljs-number\">10</span>;\n  <span class=\"hljs-comment\">// 2. 当 0.85 &gt; m - n &gt;= 0.5 = log(e5) 的时候，step1 * 5</span>\n  <span class=\"hljs-comment\">// 可以减少 log(5) = 0.7 的误差</span>\n  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (error &gt;= e5) step1 *= <span class=\"hljs-number\">5</span>;\n  <span class=\"hljs-comment\">// 3. 当 0.5 &gt; m - n &gt;= 0.15 = log(e2) 的时候，step1 * 2</span>\n  <span class=\"hljs-comment\">// 那么可以减少 log(2) = 0.3 的误差</span>\n  <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (error &gt;= e2) step1 *= <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-comment\">// 4. 当 0.15 &gt; m - n &gt; 0 的时候，step1 * 1</span>\n  <span class=\"hljs-keyword\">return</span> step1;\n}\n</code></pre>\n<p>这里简单解释一下使用 <code>Math.sqrt(50)</code>，<code>Math.sqrt(10)</code> 以及 <code>Math.sqrt(2)</code> 作为误差标准的原因（这里只是笔者的推断，仅供参考，如果更好的解释可以在评论处指出）。</p>\n<p>通过上面的注释我们可以看出，为了让 <code>step0</code> 和 <code>step1</code> 之间误差尽量的少，就是让 <code>Math.abs(m - n)</code> 尽量为 0。因为我们希望间隔是以 <strong>1或者2或者5乘上10的 n 次方</strong>数，所以只能通过乘 2，5或者10来减少误差。</p>\n<p>乘10可以减少 log10 的误差 ，乘5可以减少 log5 的误差，乘2可以减少 log2 的误差。我们用数列 0，log2，log5 和 log10 两两之间的平均数来作为选择需要改变的误差的标准。也就是:</p>\n<ul>\n<li><code>log(e2) = (0 + log2) / 2 = log(Math.sqrt(2))</code></li>\n<li><code>log(e5) = (log2 + log5) / 2 = log(Math.sqrt(2 * 5))</code></li>\n<li><code>log(e10) = (log5 + log10) / 2 = log(Math.sqrt(5 * 10))</code></li>\n</ul>\n<p>即 <code>e2 = Math.sqrt(2)</code>, <code>e5 = Math.sqrt(10)</code> 和 <code>e10 = Math.sqrt(50)</code>。</p>\n<p>在这个 <code>tickStep</code> 的基础上我们可以获取如下的获得刻度的方法。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/utils.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ticks</span>(<span class=\"hljs-params\">min, max, count</span>) {\n  <span class=\"hljs-keyword\">const</span> step = <span class=\"hljs-title function_\">tickStep</span>(min, max, count);\n  <span class=\"hljs-comment\">// 让 start 和 stop 都是 step 的整数倍</span>\n  <span class=\"hljs-comment\">// 这样生成的 ticks 都是 step 的整数倍</span>\n  <span class=\"hljs-comment\">// 可以让可读性更强</span>\n  <span class=\"hljs-keyword\">const</span> start = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">ceil</span>(min / step);\n  <span class=\"hljs-keyword\">const</span> stop = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(max / step);\n  <span class=\"hljs-keyword\">const</span> n = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">ceil</span>(stop - start + <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-comment\">// n 不一定等于 count，所以生成的 ticks 的数量可能和指定的不一样</span>\n  <span class=\"hljs-keyword\">const</span> values = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(n);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i += <span class=\"hljs-number\">1</span>) {\n    values[i] = <span class=\"hljs-title function_\">round</span>((start + i) * step);\n  }\n  <span class=\"hljs-keyword\">return</span> values;\n}\n\n<span class=\"hljs-comment\">// 简单解决 js 的精读问题：0.1 + 0.2 !== 0.3</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">round</span>(<span class=\"hljs-params\">n</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">round</span>(n * <span class=\"hljs-number\">1e12</span>) / <span class=\"hljs-number\">1e12</span>;\n}\n</code></pre>\n<p>下面来看看 <code>ticks</code> 方法获得的效果。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-title function_\">ticks</span>(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">9.9</span>, <span class=\"hljs-number\">6</span>); <span class=\"hljs-comment\">// [2, 4, 6, 8]</span>\n</code></pre>\n<p>现在发现生成的刻度不仅是均匀的，而且拥有很不错的可读性！但是美中不足的是定义域 <code>[0.1, 9.9]</code> 本身的可读性不是很强，但如果我们能根据刻度间隔去调整定义域的范围，使得最小值和最大值都是刻度间隔的整数倍，又会发生什么？这就是 <code>nice</code> 操作，具体的实现如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/utils.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">nice</span>(<span class=\"hljs-params\">domain, interval</span>) {\n  <span class=\"hljs-keyword\">const</span> [min, max] = domain;\n  <span class=\"hljs-keyword\">return</span> [interval.<span class=\"hljs-title function_\">floor</span>(min), interval.<span class=\"hljs-title function_\">ceil</span>(max)];\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ceil</span>(<span class=\"hljs-params\">n, base</span>) {\n  <span class=\"hljs-keyword\">return</span> base * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">ceil</span>(n / base);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">floor</span>(<span class=\"hljs-params\">n, base</span>) {\n  <span class=\"hljs-keyword\">return</span> base * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(n / base);\n}\n</code></pre>\n<p>我们可以如下使用上面新增的函数，可以发现改算法根据刻度间隔<code>2</code>去调整了定义域，使得其从<code>[0.1, 9.9]</code>变成了<code>[0, 10]</code>，从而生成了<code>[0, 2, 4, 6, 8]</code>这样可读性更强的刻度。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">let</span> d0 = <span class=\"hljs-number\">0.1</span>;\n<span class=\"hljs-keyword\">let</span> d1 = <span class=\"hljs-number\">9.9</span>;\n<span class=\"hljs-keyword\">const</span> step = <span class=\"hljs-title function_\">tickStep</span>(d0, d1, tickCount);\n[d0, d1] = <span class=\"hljs-title function_\">nice</span>([<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">9.9</span>], {\n  <span class=\"hljs-attr\">floor</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> <span class=\"hljs-title function_\">floor</span>(x, step),\n  <span class=\"hljs-attr\">ceil</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> <span class=\"hljs-title function_\">ceil</span>(x, step),\n});\n\nd0; <span class=\"hljs-comment\">// 0</span>\nd1; <span class=\"hljs-comment\">// 10</span>\n<span class=\"hljs-title function_\">ticks</span>(d0, d1, <span class=\"hljs-number\">6</span>); <span class=\"hljs-comment\">// [0, 2, 4, 6, 8]</span>\n</code></pre>\n<p>因为上面的 <code>ticks</code> 以及 <code>nice</code> 和 Linear 比例尺是强相关的，所以我们把它们作为 Linear 的两个方法，最后 Linear 比例尺的实现如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/linear.js</span>\n\n<span class=\"hljs-keyword\">import</span> {\n  normalize, tickStep, nice, floor, ceil, ticks,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createLinear</span>(<span class=\"hljs-params\">{\n  domain: [d0, d1],\n  range: [r0, r1],\n  interpolate = interpolateNumber,\n}</span>) {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">scale</span> = (<span class=\"hljs-params\">x</span>) =&gt; {\n    <span class=\"hljs-keyword\">const</span> t = <span class=\"hljs-title function_\">normalize</span>(x, d0, d1);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">interpolate</span>(t, r0, r1);\n  };\n\n  scale.<span class=\"hljs-property\">ticks</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">tickCount</span>) =&gt;</span> <span class=\"hljs-title function_\">ticks</span>(d0, d1, tickCount);\n  scale.<span class=\"hljs-property\">nice</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">tickCount</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> step = <span class=\"hljs-title function_\">tickStep</span>(d0, d1, tickCount);\n    [d0, d1] = <span class=\"hljs-title function_\">nice</span>([d0, d1], {\n      <span class=\"hljs-attr\">floor</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> <span class=\"hljs-title function_\">floor</span>(x, step),\n      <span class=\"hljs-attr\">ceil</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> <span class=\"hljs-title function_\">ceil</span>(x, step),\n    });\n  };\n\n  <span class=\"hljs-keyword\">return</span> scale;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">interpolateNumber</span>(<span class=\"hljs-params\">t, start, stop</span>) {\n  <span class=\"hljs-keyword\">return</span> start * (<span class=\"hljs-number\">1</span> - t) + stop * t;\n}\n</code></pre>\n<h3 data-id=\"heading-4\">Time</h3>\n<p>Linear 比例尺要求定义域都是数字，但是有的时候我们希望定义域是浏览器的时间对象（Date），这个时候就需要用到 Time 比例尺了。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75f389be0b9c484495ccbb599a1bc2e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>比如我们在做折线图的时候，希望把和时间相关的属性映射为折线图的 x 坐标，我们就会如下使用 Time 比例尺。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-title function_\">createTime</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2000</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2000</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>)],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">960</span>],\n});\n\n<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2000</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>)); <span class=\"hljs-comment\">// 200</span>\n<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2000</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">16</span>)); <span class=\"hljs-comment\">// 640</span>\n<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(<span class=\"hljs-number\">2000</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>)); <span class=\"hljs-comment\">// 960</span>\n</code></pre>\n<p>根据上面的描述，其实不难看出 Time 比例尺的表达式 <code>y = a * f(x) + b</code>中的 <code>f(x)</code> 应该为 <code>f(x) = x.getTime()</code>。所以我们可以在 Linear 比例尺的基础上如下实现 Time 比例尺。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/time.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createLinear } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./linear'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createTime</span>(<span class=\"hljs-params\">{ domain, ...rest }</span>) {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">transform</span> = (<span class=\"hljs-params\">x</span>) =&gt; x.<span class=\"hljs-title function_\">getTime</span>();\n  <span class=\"hljs-keyword\">const</span> transformedDomain = domain.<span class=\"hljs-title function_\">map</span>(transform);\n  <span class=\"hljs-keyword\">const</span> linear = <span class=\"hljs-title function_\">createLinear</span>({ <span class=\"hljs-attr\">domain</span>: transformedDomain, ...rest });\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">scale</span> = (<span class=\"hljs-params\">x</span>) =&gt; <span class=\"hljs-title function_\">linear</span>(<span class=\"hljs-title function_\">transform</span>(x));\n\n  scale.<span class=\"hljs-property\">nice</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">tickCount</span>) =&gt;</span> linear.<span class=\"hljs-title function_\">nice</span>(tickCount);\n  scale.<span class=\"hljs-property\">ticks</span> = <span class=\"hljs-function\">(<span class=\"hljs-params\">tickCount</span>) =&gt;</span> linear.<span class=\"hljs-title function_\">ticks</span>(tickCount).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(d));\n\n  <span class=\"hljs-keyword\">return</span> scale;\n}\n</code></pre>\n<p>这里需要注意的是 Time 比例尺和 Linear 比例尺的 <code>ticks</code> 和 <code>nice</code> 方法应该是不一样的，因为对于它们来说可读性强的刻度的含义不一样。对于 Time 比例尺来说，应该是如下的时间间隔：</p>\n<ul>\n<li>1, 5, 15 和 30秒.</li>\n<li>1, 5, 15 和 30分钟.</li>\n<li>1, 3, 6 和 12-小时.</li>\n<li>1 和 2天.</li>\n<li>1周.</li>\n<li>1 和 3月.</li>\n<li>1年.</li>\n</ul>\n<p>但是 Time 比例尺获得合适刻度间隔的算法相对更复杂的一点，所以这里就复用 Linear 比例尺的 <code>ticks</code> 算法，想了解更多的可以去里看 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fd3%2Fd3-scale%2Fblob%2Fmain%2Fsrc%2Ftime.js%23L47\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/d3/d3-scale/blob/main/src/time.js#L47\" ref=\"nofollow noopener noreferrer\">d3-scale</a> 的源码。</p>\n<p>最后我们将 Time 比例尺可视化的效果如下，可以发现它和 Linear 比例尺一个最大的区别是 x 轴从数字变成了时间。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4f87162f9b34afb9c565955401a3578~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-5\">序数类比例尺</h2>\n<p>如果说连续比例尺负责数值属性的映射，那么序数类比例尺就负责序数属性的映射。</p>\n<p>这里解释一下序数的含义。在<a href=\"https://juejin.cn/book/7031893648145186824/section/7032095221731033125\" target=\"_blank\" title=\"https://juejin.cn/book/7031893648145186824/section/7032095221731033125\">数据分析模型</a>那一章我们了解到，数据属性分为：分类和可排序属性，可排序又分为数值和序数两种类型。为了简单，我们把分类属性也算作一种特殊的序数属性（所有值的大小都是相等的）。所以这里的序数属性包含分类属性和序数属性。</p>\n<p>接下来我们来看看三个序数类比例尺：Ordinal、Band 和 Point。</p>\n<h3 data-id=\"heading-6\">Ordinal</h3>\n<p>Ordinal 比例尺和开篇提到的一样，值域和定义域都是序数，主要用于将序数属性映射为同为序数属性的视觉属性，比如颜色，形状等。比如下面我们将水果的名字映射为颜色。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84eec5a4a1dc43daa458ebf36ca5459a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>把上图的映射过程用代码描述如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createOrdinal</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-string\">\"苹果\"</span>, <span class=\"hljs-string\">\"香蕉\"</span>, <span class=\"hljs-string\">\"梨\"</span>, <span class=\"hljs-string\">\"西瓜\"</span>],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-string\">'red'</span>, <span class=\"hljs-string\">'yellow'</span>, <span class=\"hljs-string\">'green'</span>],\n});\n\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">\"苹果\"</span>); <span class=\"hljs-comment\">// 'red'</span>\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">\"香蕉\"</span>); <span class=\"hljs-comment\">// 'yellow'</span>\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">\"梨\"</span>); <span class=\"hljs-comment\">// 'green'</span>\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">\"西瓜\"</span>); <span class=\"hljs-comment\">// 'red'</span>\n</code></pre>\n<p>实现的思路也很简单：首先从定义域中找到输入对应的索引，然后返回值域中对应索引的元素。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/ordinal.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createOrdinal</span>(<span class=\"hljs-params\">{ domain, range }</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> index = domain.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> <span class=\"hljs-title function_\">equal</span>(d, x));\n    <span class=\"hljs-comment\">// 取模的目的是为了应对 domain.length &gt; range.length 的情况</span>\n    <span class=\"hljs-keyword\">return</span> range[index % range.<span class=\"hljs-property\">length</span>];\n  };\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/utils.js</span>\n\n<span class=\"hljs-comment\">// 通过对象序列化结果简单判断两个对象是否相等</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">equal</span>(<span class=\"hljs-params\">a, b</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(a) === <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(b);\n}\n</code></pre>\n<h3 data-id=\"heading-7\">Band</h3>\n<p>Ordinal 比例尺要求值域必须是序数的，如果值域是数值类型的话，就需要 Band 比例尺了。Band 比例尺主要用于将离散的序数属性映射为连续的数值属性，往往用于条形图中确定某个条的位置。</p>\n<p>比如下面我们将水果的名字映射为下面每个条的位置，其中每一个条使一个 Band，它的宽度为 BandWidth，条之间的间距为 Padding，步长是 BandWidth 和 Padding 之和。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab72ba856ece420297e57dbbdc5fea2c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>把上图的映射过程用代码描述如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> options = {\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-string\">\"苹果\"</span>, <span class=\"hljs-string\">\"香蕉\"</span>, <span class=\"hljs-string\">\"梨\"</span>],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">320</span>], <span class=\"hljs-comment\">// 上图中 width 的范围</span>\n  <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-comment\">// 控制条之间的间距，上图中的 padding</span>\n}\n\n<span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createBand</span>(options);\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">\"苹果\"</span>); <span class=\"hljs-comment\">// 20</span>\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">\"香蕉\"</span>); <span class=\"hljs-comment\">// 120</span>\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">\"梨\"</span>); <span class=\"hljs-comment\">// 220</span>\n</code></pre>\n<p>当然我们除了如上需要通过 Band 比例尺获得条的位置，还需要如下获得条的 BandWidth 和 Step。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\">scale.<span class=\"hljs-title function_\">bandWidth</span>(); <span class=\"hljs-comment\">// 80</span>\nscale.<span class=\"hljs-title function_\">step</span>(); <span class=\"hljs-comment\">// 100</span>\n</code></pre>\n<p>根据上面的介绍，发现 Band 比例尺可以直接基于 Ordinal 比例尺实现，只不过我们需要将其本身的值域进行转换，转换成间距相等的几个值。具体的实现方法如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/band.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createOrdinal } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./ordinal'</span>;\n<span class=\"hljs-keyword\">import</span> { band } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createBand</span>(<span class=\"hljs-params\">options</span>) {\n  <span class=\"hljs-keyword\">const</span> { bandRange, bandWidth, step } = <span class=\"hljs-title function_\">band</span>(options);\n  <span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createOrdinal</span>({ ...options, <span class=\"hljs-attr\">range</span>: bandRange });\n\n  scale.<span class=\"hljs-property\">bandWidth</span> = <span class=\"hljs-function\">() =&gt;</span> bandWidth;\n  scale.<span class=\"hljs-property\">step</span> = <span class=\"hljs-function\">() =&gt;</span> step;\n\n  <span class=\"hljs-keyword\">return</span> scale;\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/utils.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">band</span>(<span class=\"hljs-params\">{ domain, range, padding }</span>) {\n  <span class=\"hljs-keyword\">const</span> [r0, r1] = range;\n  <span class=\"hljs-keyword\">const</span> n = domain.<span class=\"hljs-property\">length</span>;\n  <span class=\"hljs-keyword\">const</span> step = (r1 - r0) / (n + padding);\n  <span class=\"hljs-keyword\">const</span> bandWidth = step * (<span class=\"hljs-number\">1</span> - padding);\n  <span class=\"hljs-keyword\">const</span> interval = step - bandWidth;\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">x</span> = (<span class=\"hljs-params\">_, i</span>) =&gt; r0 + interval + step * i;\n  <span class=\"hljs-keyword\">return</span> {\n    step,\n    bandWidth,\n    <span class=\"hljs-attr\">bandRange</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(n).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">0</span>).<span class=\"hljs-title function_\">map</span>(x),\n  };\n}\n</code></pre>\n<h3 data-id=\"heading-8\">Point</h3>\n<p>我们接下来看看最后的一种序数比例尺：Point。Point 比例尺是一种特殊的 Band 比例尺，它的 Padding 始终为 1，也就是说它的 BandWidth 始终为 0 。(具体参考下图）</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc257ac4098241e3a8c2ab5ae0cebfcd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>Point 比例尺主要用于散点图，它的使用方式如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> options = {\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-string\">\"苹果\"</span>, <span class=\"hljs-string\">\"香蕉\"</span>, <span class=\"hljs-string\">\"梨\"</span>],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">320</span>], \n};\n\n<span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createBand</span>(options);\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">\"苹果\"</span>); <span class=\"hljs-comment\">// 80</span>\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">\"香蕉\"</span>); <span class=\"hljs-comment\">// 160</span>\n<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">\"梨\"</span>); <span class=\"hljs-comment\">// 240</span>\n</code></pre>\n<p>Point 的比例尺可以基于 Ordinal 如下简单得实现。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/point.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createBand } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./band'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createPoint</span>(<span class=\"hljs-params\">options</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">createBand</span>({ ...options, <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-number\">1</span> });\n}\n</code></pre>\n<h2 data-id=\"heading-9\">分布比例尺</h2>\n<p>最后我们来看看分布比例尺，该类比例尺很多时候可以用来探索数据的分布。我们用 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fobservablehq.com%2F%40d3%2Fquantile-quantize-and-threshold-scales\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://observablehq.com/@d3/quantile-quantize-and-threshold-scales\" ref=\"nofollow noopener noreferrer\">Quantile, Quantize and Threshold scales</a> 这篇文章中的例子来认识这类比例尺。</p>\n<p>上面的文章中有一个工资的数据集合：<code>salary = [11002,29017, ...]</code>，这个数据集一共有 100 条数据，范围是：<code>[0, 300577]</code>，我们现在希望绘制一个热力图来展现这些数据的分布：每一个格子代表一个人，将工资映射为格子的颜色。</p>\n<p>首先我们可以先用如下 Linear 比例尺来看看效果。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createLinear</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">300577</span>],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-string\">'white'</span>, <span class=\"hljs-string\">'red'</span>],\n  <span class=\"hljs-attr\">interpolate</span>: interpolateColor\n})\n</code></pre>\n<p>可视化后的效果如下图，可以发现我们能获得的信息很少，因为我们很难去区别这些颜色。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d55dbf591e3c4be6b596d56a3c8577b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p><strong>所以我们需要离散的分布比例尺，将这些工资数据分组，每一个组使用一个颜色来编码</strong>。而不同的分组方式需要使用不同的分布比例尺，我们接下来分别看看它们。</p>\n<h3 data-id=\"heading-10\">Threshold</h3>\n<p>首先是 Threshold 比例尺，它的定义域是连续的，并且会被指定的分割值分成不同的组，它的使用方式如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createThreshold</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">10000</span>, <span class=\"hljs-number\">100000</span>], <span class=\"hljs-comment\">// 1000, 100000 就是两个分割值</span>\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-string\">\"white\"</span>, <span class=\"hljs-string\">\"pink\"</span>, <span class=\"hljs-string\">\"red\"</span>],\n})\n <span class=\"hljs-comment\">// [0, 300577] 会被上面的分割值分成三组，然后如下映射：</span>\n <span class=\"hljs-comment\">// [0, 10000) -&gt; \"white\"</span>\n <span class=\"hljs-comment\">// [10000, 100000) -&gt; \"pink\"</span>\n <span class=\"hljs-comment\">// [100000, 300577) -&gt; \"red\"</span>\n</code></pre>\n<p>使用上面声明的 Threshold 比例尺就会得到以下的效果。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b0c659be8b48e59a199b5eaf77f415~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>现在我们就可以得到一些有效信息了：因为粉红色的格子最多，所以大多人的工资都在 <code>[10000, 100000)</code> 这个区间，少部分在 <code>[0, 10000)</code> 和 <code>[100000, 300577)</code> 这两个区间。</p>\n<p>根据上面的介绍，以下 Threshold 比例尺的实现也不难理解了。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/threshold.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createThreshold</span>(<span class=\"hljs-params\">{ domain, range }</span>) {\n  <span class=\"hljs-keyword\">const</span> n = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(domain.<span class=\"hljs-property\">length</span>, range.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> index = domain.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =&gt;</span> x &lt; v);\n    <span class=\"hljs-keyword\">return</span> range[index === -<span class=\"hljs-number\">1</span> ? n : index];\n  };\n}\n</code></pre>\n<h3 data-id=\"heading-11\">Quantize</h3>\n<p>相对于 Threshold 比例尺需要我们指定分割值，Quantize 比例尺会根据数据的范围帮我们选择分割值，从而把定义域分成间隔相同的组。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 因为 range 有3个值，所以 domain 会被分成三等份，</span>\n<span class=\"hljs-comment\">// 并且按照如下的规则映射</span>\n<span class=\"hljs-comment\">// [0, 300577 / 3) -&gt; \"white\"</span>\n<span class=\"hljs-comment\">// [300577 / 3, 300577 * (2 / 3)) -&gt; \"pink\"</span>\n<span class=\"hljs-comment\">// [300577 * (2 / 3), 300577) -&gt; \"red</span>\n<span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createQuantize</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">300577</span>],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-string\">\"white\"</span>, <span class=\"hljs-string\">\"pink\"</span>, <span class=\"hljs-string\">\"red\"</span>],\n})\n</code></pre>\n<p>如果我们用 Quantize 比例尺可视化上面的数据，会得到如下的结果：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd59b46e540b4d268cc75bb32b075521~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>可以发现大部分人的工资都在前三分之一（白色）这个级别，只有极少数的人在后三分之一（红色）这个级别，这体现出了工资严重的分布不公平。这也是 使用 Quantize 比例尺存在的一个问题：当数据的分布有倾斜的时候，会出现几乎所有数据都在一个组，只有一些极端值在自己组的情况。</p>\n<p>根据上面的描述，实现 Quantize 比例尺的关键就是计算得到分割值，然后在这个基础之使用 Threahold 比例尺即可，具体的实现如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/quantize.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createThreshold } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./threshold\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createQuantize</span>(<span class=\"hljs-params\">{ domain: [d0, d1], range, ...rest }</span>) {\n  <span class=\"hljs-keyword\">const</span> n = range.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">const</span> step = (d1 - d0) / (n + <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">const</span> quantizeDomain = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(n).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">0</span>).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_, i</span>) =&gt;</span> step * (i + <span class=\"hljs-number\">1</span>));\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">createThreshold</span>({ <span class=\"hljs-attr\">domain</span>: quantizeDomain, range, ...rest });\n}\n</code></pre>\n<h3 data-id=\"heading-12\">Quantile</h3>\n<p>和 Quantize 比例尺不同是，Quantile 比例尺采用了另外得到分割值的策略： 根据数据出现的频率分组。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 首先把会 salary 按照升序排序</span>\n<span class=\"hljs-comment\">// 因为一共有100条数据，所以</span>\n<span class=\"hljs-comment\">// 前33条数据会被映射为 \"white\"</span>\n<span class=\"hljs-comment\">// 排名33到67的数据会被映射为 \"pink\"</span>\n<span class=\"hljs-comment\">// 最后33条数据会映射为 \"red</span>\n<span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createQuantile</span>({\n  <span class=\"hljs-attr\">domain</span>: salary,\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-string\">\"white\"</span>, <span class=\"hljs-string\">\"pink\"</span>, <span class=\"hljs-string\">\"red\"</span>],\n})\n</code></pre>\n<p>用 Quantize 比例尺进行可视化上面的数据会得到以下的效果。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae11fa51963b496081dd06418b84d39d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>如果对上面的数据按照升序排序之后再进行可视化，就会得到如下的效果。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0622843cf95d4624afc84e9cf8ed3106~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>可以发现，Quantile 比例尺把数据分成了每组数据的数量相同的三个组，也就是说通过上面的图我们可以真正能找到 “相对较低”、“普通”和“相对较高”这三个组对应的人。这里需要注意的是：Quantile 是根据数据在整个数据集的排名来分组的，所以会缺少数据绝对大小相关的分布信息。</p>\n<p>类似于 Quantize 比例尺，我们在实现 Quantile 比例尺的时候也需要计算对应的分割值，具体的计算方式如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/quantile.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createThreshold } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./threshold\"</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createQuantile</span>(<span class=\"hljs-params\">{ domain, range, ...rest }</span>) {\n  <span class=\"hljs-keyword\">const</span> n = range.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">const</span> sortedDomain = domain.<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a - b);\n  <span class=\"hljs-keyword\">const</span> step = (sortedDomain.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>) / (n + <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">const</span> quantileDomain = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(n).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">0</span>).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_, index</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> i = (index + <span class=\"hljs-number\">1</span>) * step;\n    <span class=\"hljs-keyword\">const</span> i0 = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">floor</span>(i);\n    <span class=\"hljs-keyword\">const</span> i1 = i0 + <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">const</span> v0 = sortedDomain[i0];\n    <span class=\"hljs-keyword\">const</span> v1 = sortedDomain[i1];\n    <span class=\"hljs-keyword\">return</span> v0 * (i1 - i) + v1 * (i - i0);\n  });\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">createThreshold</span>({ <span class=\"hljs-attr\">domain</span>: quantileDomain, range, ...rest });\n}\n</code></pre>\n<h2 data-id=\"heading-13\">作业</h2>\n<p>最后给大家布置一个小任务，就是基于 Linear 比例尺，参考 Time 比例尺实现 Log 比例尺。除了实现 Log 比例尺的映射功能之外，也要实现它的 <code>ticks</code> 和 <code>nice</code> 方法。</p>\n<p>Log 比例尺的表达式 <code>y = a * f(x) + b</code>中的 <code>f(x)</code> 应该为 <code>f(x) = Math.log(x)</code>， 这里只需要考虑 x 大于零的情况。对于 Log 比例尺来说，可读性较强的刻度就是指定 base 的指数。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { createLog } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./log.js'</span>;\n\n<span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createLog</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">100</span>],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">200</span>],\n  <span class=\"hljs-attr\">base</span>: <span class=\"hljs-number\">2</span>\n});\n\nscale.<span class=\"hljs-title function_\">ticks</span>(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// [16, 32, 64]  = [2 ^ 4, 2 ^5, 2 ^6]</span>\n\nscale.<span class=\"hljs-title function_\">nice</span>(<span class=\"hljs-number\">5</span>); \nsclae.<span class=\"hljs-title function_\">ticks</span>(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// [8, 16, 32, 64, 128];</span>\n</code></pre>\n<p>具体的实现参考<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Fblob%2Fmain%2Fsrc%2Fscale%2Flog.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/blob/main/src/scale/log.js\" ref=\"nofollow noopener noreferrer\">这里</a>，测试代码在<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Fblob%2Fmain%2F__tests__%2Fscale%2Flog.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/blob/main/__tests__/scale/log.spec.js\" ref=\"nofollow noopener noreferrer\">这里</a>。</p>\n<p>当我们实现了 Log 比例尺之后，我们就把常用的、Sparrow 后面会用到的比例尺都开发完成了，是不是觉得收获满满？最后把它们全部导出即可。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/scale/index.js</span>\n\n<span class=\"hljs-keyword\">export</span> { createLinear, interpolateNumber } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./linear'</span>;\n<span class=\"hljs-keyword\">export</span> { createIdentity } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./identity'</span>;\n<span class=\"hljs-keyword\">export</span> { createOrdinal } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./ordinal'</span>;\n<span class=\"hljs-keyword\">export</span> { createBand } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./band'</span>;\n<span class=\"hljs-keyword\">export</span> { createPoint } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./point'</span>;\n<span class=\"hljs-keyword\">export</span> { createQuantile } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./quantile'</span>;\n<span class=\"hljs-keyword\">export</span> { createThreshold } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./threshold'</span>;\n<span class=\"hljs-keyword\">export</span> { createQuantize } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./quantize'</span>;\n<span class=\"hljs-keyword\">export</span> { createTime } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./time'</span>;\n<span class=\"hljs-keyword\">export</span> { createLog } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./log'</span>;\n</code></pre>\n<p>完整的代码可以在<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2Fsrc%2Fscale\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/src/scale\" ref=\"nofollow noopener noreferrer\">这里</a>浏览，同样也可以通过<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fscale\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/scale\" ref=\"nofollow noopener noreferrer\">这里</a>的测试代码来验证代码的正确性。</p>\n<h2 data-id=\"heading-14\">拓展</h2>\n<p>虽然在上面的开发过程中每一个比例尺最多就10几行代码，但其实真正能在实际场景下使用的比例尺远没有这么简单。这里有两点需要注意：</p>\n<p>第一个是比例尺的丰富度。数据映射的场景很多，我们介绍的比例尺只是用于最常见的几种场景，更多的数据场景会使用一些更复杂的比例尺：比如 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fd3%2Fd3-scale%23symlog-scales\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/d3/d3-scale#symlog-scales\" ref=\"nofollow noopener noreferrer\">Symlog</a>、<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fd3%2Fd3-scale%23sequential-scales\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/d3/d3-scale#sequential-scales\" ref=\"nofollow noopener noreferrer\">Sequential</a>，</p>\n<p>第二个是性能上的要求。因为对每一个数据都会进行数据映射，所以在大数据的情况下，效率不高的比例尺实现会带来巨大的性能损失。</p>\n<p>比如在目前 Ordinal 比例尺的实现中，找到 index 的算法的时间复杂度是 <code>O(n)</code>：和定义域的数据规模呈线性相关。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createOrdinal</span>(<span class=\"hljs-params\">{ domain, range }</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> {\n    <span class=\"hljs-comment\">// findIndex 的每次都会遍历一次 domain</span>\n    <span class=\"hljs-keyword\">const</span> index = domain.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> <span class=\"hljs-title function_\">equal</span>(d, x));\n    <span class=\"hljs-keyword\">return</span> range[index % range.<span class=\"hljs-property\">length</span>];\n  };\n}\n</code></pre>\n<p>这在数据量大的情况下这是不可接受的，但是它经过如下的优化就可以变成时间复杂度为 <code>O(1)</code> 的算法。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createOrdinal</span>(<span class=\"hljs-params\">{ domain, range }</span>) {\n  <span class=\"hljs-keyword\">const</span> indexMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(domain.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d, i</span>) =&gt;</span> [d, i]));\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> index = indexMap.<span class=\"hljs-title function_\">get</span>(x); <span class=\"hljs-comment\">// O(1)</span>\n    <span class=\"hljs-keyword\">return</span> range[index % range.<span class=\"hljs-property\">length</span>];\n  };\n}\n</code></pre>\n<p>这里不会深入讲解优化和实现更多比例尺的细节，感兴趣的同学可以去参考：<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fd3%2Fd3-scale\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/d3/d3-scale\" ref=\"nofollow noopener noreferrer\">d3-scale</a> 和 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fscale\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/scale\" ref=\"nofollow noopener noreferrer\">@antv/scale</a> 里面的实现。</p>\n<h2 data-id=\"heading-15\">小结</h2>\n<p>这篇文章我们先从了解比例尺理论开始，知道了比例尺的本质是一个函数，然后实现了一些常用的且在 Sparrow 后面会用到的比例尺。</p>\n<p>这里简单总结一下根据数据属性的种类选择比例尺的思路。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th><strong>定义域</strong></th><th><strong>值域</strong></th><th><strong>比例尺</strong></th></tr></thead><tbody><tr><td>数值</td><td>数值</td><td>Linear、Time、Log</td></tr><tr><td>数值</td><td>序数</td><td>Band、Point</td></tr><tr><td>序数</td><td>序数</td><td>Ordinal</td></tr><tr><td>数值</td><td>序数</td><td>Threshold、Quantile、Quantize</td></tr></tbody></table>\n<p>同时我们也可以回答最开始提出的三个问题了。</p>\n<ul>\n<li>为啥最后坐标轴生成的刻度的数量和希望的不一样？- 为了保证生成刻度的可读性，需要在希望刻度数量的基础上进行调整。</li>\n<li>nice 到底有什么用？- 调整定义域的范围，从而生成可读性更强的刻度。</li>\n<li>Threshold, Quantize, Quantile 比例尺有什么区别？- 获得将定义域分组的分割值的依据不同。Threshold 是使用指定的分割值，Quantize 是根据数据的绝对大小计算分割值，Quantile 是根据数据的排名来计算分割值。</li>\n</ul>\n<p>文章的最后也提出了我们可以优化的空间，希望大家可以多去了解。在开发完比例尺模块之后，下一章将带大家认识坐标系（Coordinate）。如果说比例尺侧重于编码的映射过程，那么坐标系就侧重于编码的布局过程了。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d95ca36382a4483596fdef144ee3dc3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<blockquote>\n<p>参考</p>\n<ul>\n<li>The Grammar of Graphics, 2nd Edition, Leland Wilkinson</li>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fd3%2Fd3-scale\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/d3/d3-scale\" ref=\"nofollow noopener noreferrer\">d3-scale</a></li>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fobservablehq.com%2F%40d3%2Fquantile-quantize-and-threshold-scales\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://observablehq.com/@d3/quantile-quantize-and-threshold-scales\" ref=\"nofollow noopener noreferrer\">Quantile, Quantize and Threshold scales</a></li>\n</ul>\n</blockquote><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "8\n实战：坐标系 - Coordinate\n学习时长: 73分48秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>上一章给大家介绍了比例尺，它侧重于负责数据的映射，比如将数据映射为视觉元素的颜色、大小或者形状等属性。接下来会给大家介绍坐标系（Coordinate），它侧重于负责视觉元素的布局过程，将经过比例尺映射后的位置属性转换成画布坐标。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d95ca36382a4483596fdef144ee3dc3a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>坐标系可以说是基于图形语法的图表库的一个独有的概念，它可以很方便的让图表在不同种类之间进行转换（比如从条形图转换成玫瑰图，堆叠条形图转换成饼图等等）。但是方便使用的同时，也带了实现上和理解的成本，所以希望大家看了这篇文章之后好好体会。</p>\n<p>那么接下来我们将会从函数式编程讲起，因为 Coordinate 的开发和后续 Sparrow 的开发将依赖它。这之后再介绍坐标系理论以及实现方法，最后和前几章一样，进行简单的拓展。</p>\n<h2 data-id=\"heading-0\">函数式编程</h2>\n<p>我们首先进入函数式编程的学习。</p>\n<p>相信大家都对面向对象编程这种编程模式（Object Oriented Programming，OOP）不陌生，毕竟很多人学习的第一门计算机编程语言可能就是 Java，而它就是一门典型的面相对象编程的语言。</p>\n<p>这里将会给大家介绍另外一种编程模式：函数式编程（Funtional Programming, FP)。在这里介绍函数式编程的目的主要有两个：</p>\n<ul>\n<li>函数式编程相对于面向对象编程会有一些优点（我们之后会看见），Sparrow 的代码的目标就是尽量拥有这些优点，让代码更加函数式。了解函数式编程可以让我们更好理解 Sparrow 的代码架构和选择。</li>\n<li>Coordinate 的实现依赖于函数式编程两个非常重要的工具。</li>\n</ul>\n<p>我们首先会从一个例子简单来认识函数式编程，然后介绍其中两个重要概念：一等公民（First Class）和纯函数（Pure Function），最后介绍上面提到的两个工具：函数合成（Compose）和函数柯里化（Curry）。</p>\n<h3 data-id=\"heading-1\">计算海鸥数量</h3>\n<p>这里我们会用 Franklin Frisby 教授的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMostlyAdequate%2Fmostly-adequate-guide%2Fblob%2Fmaster%2Fch01.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/MostlyAdequate/mostly-adequate-guide/blob/master/ch01.md\" ref=\"nofollow noopener noreferrer\">《Mostly Adequate Guide to Function Programming》</a> 中的一个例子来初识函数式编程。</p>\n<p>假如现有一个功能：计算多个海鸥群按照一定方式结合（Conjoin）和繁殖（Breed）后的海鸥总数。如果用面向对象的方式来实现该功能就如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 定义一个海鸥群</span>\n<span class=\"hljs-comment\">// 这个群可以和别的海鸥群结合（Conjoin)和繁殖（Breed）</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Flock</span> {\n  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">n</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">seagulls</span> = n;\n  }\n\n  <span class=\"hljs-title function_\">conjoin</span>(<span class=\"hljs-params\">other</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">seagulls</span> += other.<span class=\"hljs-property\">seagulls</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>;\n  }\n\n  <span class=\"hljs-title function_\">breed</span>(<span class=\"hljs-params\">other</span>) {\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">seagulls</span> *= other.<span class=\"hljs-property\">seagulls</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>;\n  }\n}\n\n<span class=\"hljs-keyword\">const</span> flockA = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Flock</span>(<span class=\"hljs-number\">4</span>);\n<span class=\"hljs-keyword\">const</span> flockB = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Flock</span>(<span class=\"hljs-number\">2</span>);\n<span class=\"hljs-keyword\">const</span> flockC = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Flock</span>(<span class=\"hljs-number\">0</span>);\n<span class=\"hljs-keyword\">const</span> result = flockA\n  .<span class=\"hljs-title function_\">conjoin</span>(flockC)\n  .<span class=\"hljs-title function_\">breed</span>(flockB)\n  .<span class=\"hljs-title function_\">conjoin</span>(flockA.<span class=\"hljs-title function_\">breed</span>(flockB))\n  .<span class=\"hljs-property\">seagulls</span>; <span class=\"hljs-comment\">// 32</span>\n</code></pre>\n<p>上面这段代码不仅让我们难以跟踪一直在变的内部状态（群体的海鸥数量），而且计算结果也是不正确的：最后的总数应该是16，flockA 的数量在结合和繁殖过程中被永远改变了。</p>\n<p>那么接下来我们如何用函数式编程来实现相同的功能。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// add 相当于上面的 cojoin，multiply 相当于上面的 breed</span>\n<span class=\"hljs-comment\">// 这样命名的目的后面会讲</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add</span> = (<span class=\"hljs-params\">x, y</span>) =&gt; x + y;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">multiply</span> = (<span class=\"hljs-params\">x, y</span>) =&gt; x * y;\n\n<span class=\"hljs-keyword\">const</span> flockA = <span class=\"hljs-number\">4</span>;\n<span class=\"hljs-keyword\">const</span> flockB = <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-keyword\">const</span> flockC = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-keyword\">const</span> result =\n    <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title function_\">multiply</span>(flockB, <span class=\"hljs-title function_\">add</span>(flockA, flockC)), <span class=\"hljs-title function_\">multiply</span>(flockA, flockB)); <span class=\"hljs-comment\">// 16</span>\n</code></pre>\n<p>上面的这段代码不仅没有了难以跟踪的内部状态，也能让我们计算得到正确的结果，甚至如果大家熟悉加法交换律和乘法结合律等基本运算法则的话，上面的计算可以化简如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-title function_\">multiply</span>(flockB, <span class=\"hljs-title function_\">add</span>(flockA, flockA));\n</code></pre>\n<p>对函数式编程有了一个大概的感觉之后，接下来我们来看看函数式编程中第一个重要概念：一等公民（First Class）。</p>\n<h3 data-id=\"heading-2\">一等公民（First Class）</h3>\n<p>一等公民（First Class）的意思是：在函数式编程中，函数是一等公民。</p>\n<p>需要注意的是，这里的“一等”和我们平常理解的高人一等的“一等”不太一样，这里是指函数和其他基本数据类型（数值，字符串等）一样，没有什么特殊的地方。我们可以把函数存储在数组中，将它作为参数或者返回值，将它赋值给变量等等。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add</span> = (<span class=\"hljs-params\">x, y</span>) =&gt; x + y; <span class=\"hljs-comment\">// 将函数赋值给变量</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">multiply</span> = (<span class=\"hljs-params\">x, y</span>) =&gt; x * y;\n<span class=\"hljs-keyword\">const</span> operations = [add, multiply]; <span class=\"hljs-comment\">// 存储在数组里</span>\n\n<span class=\"hljs-comment\">// 包装函数</span>\n<span class=\"hljs-comment\">// 这是一个高阶函数（High Order Function, HOC)</span>\n<span class=\"hljs-comment\">// 参数和返回值都是函数</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">logify</span> = (<span class=\"hljs-params\">fn</span>) =&gt; { <span class=\"hljs-comment\">// 将函数作为变量</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =&gt;</span> { <span class=\"hljs-comment\">// 将函数作为返回值</span>\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(...args);\n    <span class=\"hljs-title function_\">fn</span>(...args);\n  }\n}\n</code></pre>\n<p>看上去将函数看做是一等公民非常简单，但其实也没有那么容易。比如我们希望使用上面的 <code>logify</code> 函数去包装 <code>add</code> 函数，从而在每次调用 <code>add</code> 的时候先打印参数。我们很容易给出如下的实现。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> logAddWithDelay = <span class=\"hljs-title function_\">logify</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">x, y</span>) =&gt;</span> <span class=\"hljs-title function_\">add</span>(x, y));\n</code></pre>\n<p>上面的实现可以满足我们的需求，但是这样会不必要地延迟执行 <code>add</code> 函数，因为 <code>(x, y) =&gt; add(x, y)</code> 又包装了一层函数。真正把函数作为一等公民的写法应该如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> logAdd = <span class=\"hljs-title function_\">logify</span>(add);\n</code></pre>\n<p>上面这样写处理可以避免不必要的延迟执行之外，还可以方便的修改被包装的函数 <code>add</code> 的参数。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 支持三个数的加法</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add</span> = (<span class=\"hljs-params\">x, y, z</span>) =&gt; x + y + z;\n\n<span class=\"hljs-comment\">// ❌ 和上面的写法保持不一致</span>\n<span class=\"hljs-keyword\">const</span> logAddWithDelay = <span class=\"hljs-title function_\">logfiy</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">x, y, z</span>) =&gt;</span> <span class=\"hljs-title function_\">add</span>(x, y, z));\n\n<span class=\"hljs-comment\">// ✅  和上面的写法保持一致</span>\n<span class=\"hljs-keyword\">const</span> logAdd = <span class=\"hljs-title function_\">logify</span>(add);\n</code></pre>\n<p>将函数作为一等公民的另外一个好处就是它不必和特定的数据类型关联起来，可以拥有更加通用的命名，从而更加通用。我们可以如下理解这个问题。</p>\n<p>在代码中往往会有相同的逻辑，但是拥有不同的命名，这往往会造成疑惑。比如在上面的计算海鸥的例子中，海鸥的结合本质上是一个加法，如果对应函数命名为 <code>conjoin</code> 就会将其和海鸥这个特定的概念联系起来。</p>\n<p>这样就两个坏处：一方面，不是所有人都熟悉海鸥结合这个概念，但是所有人都知道加法。另一方面，其他需要用到加法地方，也不可能直接用 <code>conjoin</code> 这个函数，需要重新实现或者赋值给新的拥有合适命名的变量，这都是不优雅的。</p>\n<p>后面我们还可以看到将函数作为一等公民的更多的作用。</p>\n<h3 data-id=\"heading-3\">纯函数（Pure Function）</h3>\n<p>在了解了函数式编程中第一个重要概念之后，我们来看看第二个重要概念：纯函数（Pure Function）。纯函数就是当输入参数保持一致的情况下返回结果也保持一致的函数。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> b = <span class=\"hljs-number\">1</span>;\n\n<span class=\"hljs-comment\">// 不是纯函数</span>\n<span class=\"hljs-comment\">// 参数 a 相同的情况下，返回结果依赖全局变量 b</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">impureAdd</span> = (<span class=\"hljs-params\">a</span>) =&gt; a + b;\n\n<span class=\"hljs-comment\">// 是纯函数</span>\n<span class=\"hljs-comment\">// 参数 a, b 相同的下，返回的结果一定相同</span>\n<span class=\"hljs-keyword\">const</span> pureAdd = (a, b) = a + b;\n</code></pre>\n<p>纯函数意味着函数没有副作用（Side Effect）。副作用是在函数计算过程中改变了系统的状态或者和函数外部的世界有交互，它包括但不限于下面几种。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 打印日志</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'hello world'</span>);\n\n<span class=\"hljs-comment\">// 发起 http 请求</span>\naxios.<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-comment\">/*...*/</span>);\n\n<span class=\"hljs-comment\">// 查询 DOM</span>\n<span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">'container'</span>);\n\n<span class=\"hljs-comment\">// 访问外部或者系统变量</span>\n<span class=\"hljs-keyword\">const</span> width = <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">innerWidth</span>;\n\n<span class=\"hljs-comment\">// 可变（mutation）</span>\n<span class=\"hljs-keyword\">const</span> a = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>];\na.<span class=\"hljs-title function_\">sort</span>(); <span class=\"hljs-comment\">// sort 是不纯的，因为它改变了 a 的值</span>\na <span class=\"hljs-comment\">// [1, 2, 3]</span>\n\n<span class=\"hljs-comment\">//...</span>\n</code></pre>\n<p>一个纯函数拥有以下的有优点：</p>\n<ul>\n<li>便携性：一方面意味着这个函数容易理解，因为它的所有依赖都体现在参数里面。另一方面，意味着这个函数可以在任何地方运行，因为它需要的东西都是通过参数传递的。但是在面向对象编程中却不是这样，Erlang 的创建者 Joe Armstrong 说：\"在面向对象编程的世界里，我想要一个香蕉，却得到了一片丛林\"</li>\n<li>可测试：我们只用给函数输入然后断言输出即可，不需要提供额外的状态。</li>\n<li>可并行运行：因为不会访问外部变量，所以不会访问共享的内存，从而不会出现竞争。</li>\n<li>可缓存：可以根据输入将输出缓存下来，下面是一个简单的实现。</li>\n</ul>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">memoize</span> = (<span class=\"hljs-params\">f</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> cache = {};\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(args);\n    cache[key] = cache[key] || <span class=\"hljs-title function_\">f</span>(...args);\n    <span class=\"hljs-keyword\">return</span> cache[key];\n  };\n};\n\n<span class=\"hljs-keyword\">const</span> squareNumber = <span class=\"hljs-title function_\">memoize</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x * x);\n<span class=\"hljs-title function_\">quareNumber</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 9, </span>\n<span class=\"hljs-title function_\">quareNumber</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 9, 返回缓存的的 9</span>\n<span class=\"hljs-title function_\">squareNumber</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 16</span>\n<span class=\"hljs-title function_\">squareNumber</span>(<span class=\"hljs-number\">4</span>); <span class=\"hljs-comment\">// 16, 返回缓存的的 16</span>\n</code></pre>\n<ul>\n<li>引用透明（Referentially Transparent）：一段代码可以被它的计算后的值所替换而不改变程序的行为，那么它就是引用透明的。这个特性在重构代码的过程或者帮助我们理解代码非常有用。参考下面的例子。</li>\n</ul>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">impureMultiply</span> = (<span class=\"hljs-params\">a, b</span>) =&gt; {\n  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">'multiply'</span>); \n  <span class=\"hljs-keyword\">return</span> a * b;\n}\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">pureMultiply</span> = (<span class=\"hljs-params\">a, b</span>) =&gt; a * b;\n\n<span class=\"hljs-comment\">// pureMultiply 是引用透明的</span>\n<span class=\"hljs-comment\">// 如果 a = 2, c = 3，pureMutiply(a, c) 被替换成 6 = pureMutiply(2, 3)</span>\n<span class=\"hljs-comment\">// const pureFn = (a, b, c) =&gt; add(6 + pureMultiply(a, b));</span>\n<span class=\"hljs-comment\">// 函数的行为没有改变，所以是引用透明的</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">pureFn</span> = (<span class=\"hljs-params\">a, b, c</span>) =&gt; <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title function_\">pureMultiply</span>(a, c) + <span class=\"hljs-title function_\">pureMultiply</span>(a, b));\n\n<span class=\"hljs-comment\">// impureMultiply 不是引用透明的</span>\n<span class=\"hljs-comment\">// 如果 a = 2, c = 3，impureMultiply(a, c) 被替换成 6 = pureMutiply(2, 3)</span>\n<span class=\"hljs-comment\">// const impureFn = (a, b, c) =&gt; add(6 + impureMultiply(a, b));</span>\n<span class=\"hljs-comment\">// 这样会打印一次 'multiply'，改变了程序行为，所以不是引用透明的</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">impureFn</span> = (<span class=\"hljs-params\">a, b, c</span>) =&gt; <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title function_\">impureMultiply</span>(a, c) + <span class=\"hljs-title function_\">impureMultiply</span>(a, b));\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 根据乘法结合律：a * b + a * c = a * (b + c) 可以对 pureFn 函数重构化简</span>\n<span class=\"hljs-keyword\">const</span> pureFn = <span class=\"hljs-title function_\">pureMultiply</span>(a, <span class=\"hljs-title function_\">add</span>(b, c));\n\n<span class=\"hljs-comment\">// 但是如果对 impureFn 函数按照相同方法化简就会有问题</span>\n<span class=\"hljs-comment\">// 'multiply' 这样就只会被打印一次了！！！</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">impureFn</span> = (<span class=\"hljs-params\">a, b, c</span>) =&gt; <span class=\"hljs-title function_\">impureMultiply</span>(a, <span class=\"hljs-title function_\">add</span>(b, c));\n</code></pre>\n<h3 data-id=\"heading-4\">函数柯里化（Currying）</h3>\n<p>函数柯里化（Currying）的概念很简单：我们可以用少于期望数量的参数去调用一个函数，这个函数返回一个接受剩下参数的函数。</p>\n<p>我们先来看看一个简单的<code>add</code> 函数，这个函数接受一个参数并且返回一个函数。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add</span> = x =&gt; <span class=\"hljs-function\"><span class=\"hljs-params\">y</span> =&gt;</span> <span class=\"hljs-function\"><span class=\"hljs-params\">z</span> =&gt;</span> x + y + z;\n<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>)(<span class=\"hljs-number\">2</span>)(<span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">// 6</span>\n</code></pre>\n<p>上面的写法太麻烦了，我们可以实现一个通用的 <code>curry</code> 方法来实现上面的效果，期望的使用方法如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> add = <span class=\"hljs-title function_\">curry</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">x, y, z</span>) =&gt;</span> x + y + z);\n<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>)(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">//6</span>\n<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 6</span>\n<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 6</span>\n</code></pre>\n<p>这样做的好处是我们可以固定一些参数，减少传入的参数，让我们能更灵活和简单的使用函数，也为我们接下来的函数合成（Compose）打下基础。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 将第一个参数固定为 1</span>\n<span class=\"hljs-keyword\">const</span> add1 = <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>);\n\n<span class=\"hljs-title function_\">add1</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>) <span class=\"hljs-comment\">// 6 </span>\n<span class=\"hljs-title function_\">add1</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// 8</span>\n\n<span class=\"hljs-comment\">// 变成一个单参数的函数</span>\n<span class=\"hljs-keyword\">const</span> add1 = <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);\n<span class=\"hljs-keyword\">const</span> add2 = <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>);\n<span class=\"hljs-keyword\">const</span> add3 = <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>);\n\n<span class=\"hljs-comment\">// 复合成一个函数</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add6</span> = x =&gt; <span class=\"hljs-title function_\">add1</span>(<span class=\"hljs-title function_\">add2</span>(<span class=\"hljs-title function_\">add3</span>(x)));\n\n<span class=\"hljs-title function_\">add6</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 7</span>\n<span class=\"hljs-title function_\">add6</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 8</span>\n</code></pre>\n<p>知道了 <code>curry</code> 函数的用途，那么接下来我们就来实现一个简单的版本。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curry</span>(<span class=\"hljs-params\">fn</span>) {\n  <span class=\"hljs-comment\">// 获得函数参数的数量</span>\n  <span class=\"hljs-keyword\">const</span> arity = fn.<span class=\"hljs-property\">length</span>;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curried</span>(<span class=\"hljs-params\">...args</span>) {\n    <span class=\"hljs-comment\">// 如果当前收集到的参数数量大于需要的数量，那么执行该函数</span>\n    <span class=\"hljs-keyword\">if</span> (args.<span class=\"hljs-property\">length</span> &gt;= arity) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fn</span>(...args);\n    <span class=\"hljs-comment\">// 否者，将传入的参数收集起来</span>\n    <span class=\"hljs-comment\">// 下面的写法类似于</span>\n    <span class=\"hljs-comment\">// return (...args1) =&gt; curried(...args, ...args1);</span>\n    <span class=\"hljs-keyword\">return</span> curried.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, ...args);\n  };\n}\n</code></pre>\n<p>最后说一下可以发现柯里化后的函数非常契合纯函数的输入一个输出一个的特点：接受一个参数，返回一个接受剩余参数的函数。</p>\n<h3 data-id=\"heading-5\">函数复合（Compose）</h3>\n<p>在学习函数式编程的最后我们来看看另外一个有用的工具：函数复合（Compose）。</p>\n<p>当一个值要经过多个函数转换，才能变成另外一个值，就可以把这些函数合成一个函数。这样，这个值就只用通过复合后的函数转换一次，就可以获得对应结果了。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// x 依次经过 add1、add2、add3 三个函数转换之后获得结果</span>\n<span class=\"hljs-keyword\">const</span> x = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-keyword\">const</span> x2 = <span class=\"hljs-title function_\">add1</span>(x); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-keyword\">const</span> x3 = <span class=\"hljs-title function_\">add2</span>(x2); <span class=\"hljs-comment\">// 4</span>\n<span class=\"hljs-title function_\">add3</span>(x3); <span class=\"hljs-comment\">// 7</span>\n\n<span class=\"hljs-comment\">// 合成一个 add6 函数</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add6</span> = x =&gt; <span class=\"hljs-title function_\">add3</span>(<span class=\"hljs-title function_\">add2</span>(<span class=\"hljs-title function_\">add1</span>(x)));\n<span class=\"hljs-title function_\">add6</span>(x); <span class=\"hljs-comment\">// 7</span>\n</code></pre>\n<p>上面的过程就是函数复合，但是复合方法过于麻烦。我们希望实现一个 <code>compose</code> 函数来自动帮助我们方便得合成函数，期望的使用方式如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 满足 Pointfreee，没有描述处理的数据</span>\n<span class=\"hljs-keyword\">const</span> add6 = <span class=\"hljs-title function_\">compose</span>(add1, add2, add3);\n<span class=\"hljs-title function_\">add6</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 7</span>\n</code></pre>\n<p>这样的写法不仅合成很方便，并且也满足了 Pointfree 这种风格：代码中不用描述数据。这样的风格可以让我们移除不必要的函数命名，也能保证函数的通用性。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 不是 Pointfree, x 就是数据</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add6</span> = x =&gt; <span class=\"hljs-title function_\">add3</span>(<span class=\"hljs-title function_\">add2</span>(<span class=\"hljs-title function_\">add1</span>(x)));\n\n<span class=\"hljs-comment\">// 不是 Pointfree, x 就是数据</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add6</span> = x =&gt; <span class=\"hljs-title function_\">compose</span>(add1, add2, add3)(x);\n</code></pre>\n<p>可以发现一等公民、函数柯里化和函数合成都是有助于我们写出 Pointfree 风格的代码。</p>\n<p>了解函数合成的基本概念，我们来下面这种一种简单的实现。这里的函数都是只有一个参数和一个返回值，并且复合后它们是按照从左到右的顺序执行的。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">compose</span>(<span class=\"hljs-params\">fn, ...rest</span>) {\n  <span class=\"hljs-keyword\">return</span> rest.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">total, cur</span>) =&gt;</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> <span class=\"hljs-title function_\">cur</span>(<span class=\"hljs-title function_\">total</span>(x)), fn);\n}\n</code></pre>\n<p>函数式编程就给大家介绍到这里了，接下来我们来看看我们的主角：坐标系（Coordinate）。</p>\n<h2 data-id=\"heading-6\">坐标系理论</h2>\n<p>在 《The Grammar of Graphics》 这本书里提到坐标系就是一系列点的集合，这些点是由一系列数字构成：<code>(x1, x2, ...xn)</code>。如果是在二维平面上点，这些就是：<code>(x1, x2)</code>。</p>\n<p>其实坐标系本质上也是一个函数，和比例尺的不同的是：比例尺是将数据映射为视觉元素的属性，坐标系是将视觉元素的位置属性映射为在画布上的坐标。坐标系这个函数的函数签名如下:</p>\n<pre><code class=\"hljs language-ts\" lang=\"ts\"><span class=\"hljs-comment\">// 输入是一个点，这个点的两个维度都是在 [0, 1] 的范围内</span>\n<span class=\"hljs-comment\">// 输入是一个点，这个点是可以直接绘制到画布坐标上的点</span>\n(<span class=\"hljs-attr\">point</span>: [<span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">number</span>]) =&gt; [<span class=\"hljs-built_in\">number</span>, <span class=\"hljs-built_in\">number</span>]\n</code></pre>\n<p>具体的使用看下面的这个例子。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { createLinear } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./scale\"</span>;\n<span class=\"hljs-keyword\">import</span> { createCoordinate, transpose, cartesian } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./coordinate'</span>;\n\n<span class=\"hljs-comment\">// 我们希望绘制一个散点图来看下面数据的分布</span>\n<span class=\"hljs-keyword\">const</span> data = [\n  { <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">180</span>, <span class=\"hljs-attr\">weight</span>: <span class=\"hljs-number\">150</span> },\n  { <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">163</span>, <span class=\"hljs-attr\">weight</span>: <span class=\"hljs-number\">94</span> },\n  { <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">173</span>, <span class=\"hljs-attr\">weight</span>: <span class=\"hljs-number\">130</span> }\n];\n\n<span class=\"hljs-comment\">// 将数据的 height 映射为点的 x 属性（这里注意 range 是 [0, 1]）</span>\n<span class=\"hljs-keyword\">const</span> scaleX = <span class=\"hljs-title function_\">createLinear</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">163</span>, <span class=\"hljs-number\">180</span>],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>]\n});\n\n<span class=\"hljs-comment\">// 将数据的 width 映射为点的 y 属性（这里注意 range 是 [0, 1]）</span>\n<span class=\"hljs-keyword\">const</span> scaleY = <span class=\"hljs-title function_\">createLinear</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">94</span>, <span class=\"hljs-number\">150</span>],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n})\n\n<span class=\"hljs-comment\">// 创建一个坐标系</span>\n<span class=\"hljs-keyword\">const</span> coordinate = <span class=\"hljs-title function_\">createCoordinate</span>({\n  <span class=\"hljs-comment\">// 指定画布的起点和宽高</span>\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">600</span>,\n  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">400</span>,\n  <span class=\"hljs-comment\">// 一系列坐标系变换</span>\n  <span class=\"hljs-attr\">transforms</span>: [\n    <span class=\"hljs-title function_\">transpose</span>(),\n    <span class=\"hljs-title function_\">cartesian</span>(),\n  ]\n});\n\n<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> { height, weight } <span class=\"hljs-keyword\">of</span> data) {\n  <span class=\"hljs-comment\">// 通过比例尺将数据的 height 和 weight 属性</span>\n  <span class=\"hljs-comment\">// 分别映射为点的 x 和 y 属性</span>\n  <span class=\"hljs-keyword\">const</span> attributeX = <span class=\"hljs-title function_\">scaleX</span>(height);\n  <span class=\"hljs-keyword\">const</span> attributeY = <span class=\"hljs-title function_\">scaleY</span>(weight);\n  \n  <span class=\"hljs-comment\">// 将点的 x 和 y 属性</span>\n  <span class=\"hljs-comment\">// 映射为最后的画布坐标</span>\n  <span class=\"hljs-keyword\">const</span> [x, y] = <span class=\"hljs-title function_\">coordinate</span>([attributeX, attributeY]);\n  \n  <span class=\"hljs-comment\">// 绘制点</span>\n  <span class=\"hljs-title function_\">point</span>(x, y);\n}\n</code></pre>\n<p>就像上面的这个例子中坐标系的创建方式一样，每一个坐标系都包含两个部分：<strong>画布的位置和大小</strong>和<strong>一系列坐标系变换函数</strong>。</p>\n<p>比如上面的坐标系的画布就是一个从 <code>(0, 0)</code> 开始，宽为600，高400的矩形，如下图。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f6ed8e137d04e9685b1594d63958d3c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"20211216223918.jpg\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>上面的坐标系包含两个坐标系变换：<code>transpose</code> 和 <code>cartesian</code>，现在我们不用知道他们具体含义，只用知道它们会把一个统计意义上的点，转换成画布上的点。</p>\n<p>统计意义上的点是指：点的两个维度都被归一化了，都在 <code>[0, 1]</code> 的范围之内。这样在将点在真正绘制到画布上的之前，我们不用考虑它们的绝对大小，只用关心它们相对大小等统计学特征。这些特征在变换过程中都不会丢失。</p>\n<p>不同的坐标系拥有的转换函数不同，这样得到点的位置也不同，从而让拥有相同属性的图形在不同坐标系下展现不同。比如笛卡尔坐标系下的矩形在极坐标系下却是扇形，这样就可以通过改变坐标系，把条形图转换成玫瑰图了。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c50f1eb5750e48c980951e40388ffbed~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>在了解了坐标系理论之后，我们就正式开始开发我们的坐标系。</p>\n<h2 data-id=\"heading-7\">基本变换</h2>\n<p>上面提到了坐标系的一个重要组成部分是坐标系变换，而坐标系变换又是由一些基本变换构成，接下来我们首先来实现一些需要的的基本变换。</p>\n<p>基本变换本质上是一个函数，输入是变换前点的坐标，输入是变换后点的坐标。同时该变换函数有 <code>type</code> 方法返回自己的变换类型（后面会使用到）。</p>\n<h3 data-id=\"heading-8\">平移（Translate）</h3>\n<p>这里先用平移变换来举例。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { translate } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./transforms'</span>;\n\n<span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">10</span>);\n<span class=\"hljs-title function_\">map</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>]); <span class=\"hljs-comment\">// [10, 10]</span>\n<span class=\"hljs-title function_\">map</span>([<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">// [12, 13]</span>\nmap.<span class=\"hljs-title function_\">type</span>(); <span class=\"hljs-comment\">// 'translate'</span>\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdd44bb270c34fa9ba1fbe94895ce60f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>通过平移变换的使用我们可以看出，不同的基本变换只是名字和变换函数不同，所以我们可以先抽象一个 <code>transform</code> 函数出来。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/coordinate/transforms.js</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-params\">type, transformer</span>) {\n  transformer.<span class=\"hljs-property\">type</span> = <span class=\"hljs-function\">() =&gt;</span> type;\n  <span class=\"hljs-keyword\">return</span> transformer;\n}\n</code></pre>\n<p>这个基础上 <code>translate</code> 函数的实现如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/coordinate/transforms.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-params\">tx = <span class=\"hljs-number\">0</span>, ty = <span class=\"hljs-number\">0</span></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-string\">'translate'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">[px, py]</span>) =&gt;</span> [px + tx, py + ty]);\n}\n</code></pre>\n<h3 data-id=\"heading-9\">缩放（Scale）</h3>\n<p>缩放变换的使用方法如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { scale } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./transforms'</span>;\n\n<span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">10</span>);\n<span class=\"hljs-title function_\">map</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>]); <span class=\"hljs-comment\">// [0, 0]</span>\n<span class=\"hljs-title function_\">map</span>([<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">// [20, 30]</span>\nmap.<span class=\"hljs-title function_\">type</span>(); <span class=\"hljs-comment\">// 'scale'</span>\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64443f57ac5d4f84a6d995fe6bfe60dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>缩放变换具体的实现如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/coordinate/transforms.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-params\">sx = <span class=\"hljs-number\">1</span>, sy = <span class=\"hljs-number\">1</span></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-string\">'scale'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">[px, py]</span>) =&gt;</span> [px * sx, py * sy]);\n}\n</code></pre>\n<h3 data-id=\"heading-10\">反射（Reflect）</h3>\n<p>反射变换是一种特殊的缩放变换，它在两个维度的放缩比例都是 -1。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { reflect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./transforms'</span>;\n\n<span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-title function_\">reflect</span>();\n<span class=\"hljs-title function_\">map</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">// [-1, -2]</span>\n<span class=\"hljs-title function_\">map</span>([-<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">// [2, -3]</span>\nmap.<span class=\"hljs-title function_\">type</span>(); <span class=\"hljs-comment\">// 'reflect'</span>\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff4a5e7edc7d42218f1ec8fd9e9ed0c3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/coordinate/transforms.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reflect</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-string\">'reflect'</span>, <span class=\"hljs-title function_\">scale</span>(-<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>));\n}\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80c27b17c6a348b39b1e8f078020dd9b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/coordinate/transforms.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reflectX</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-string\">'reflectX'</span>, <span class=\"hljs-title function_\">scale</span>(-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>));\n}\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e9ac7c681a6410e9024349f68f28c7a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/coordinate/transforms.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">reflectY</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-string\">'reflectY'</span>, <span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>));\n}\n</code></pre>\n<h3 data-id=\"heading-11\">转置（Transpose）</h3>\n<p>转置变换就是交换一个点的两个维度，可以理解为按照 <code>y = x</code> 这条直线对称。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { transpose } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./transforms'</span>;\n\n<span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-title function_\">transpose</span>();\n<span class=\"hljs-title function_\">map</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">// [2, 1]</span>\n<span class=\"hljs-title function_\">map</span>([-<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <span class=\"hljs-comment\">// [3, -2]</span>\nmap.<span class=\"hljs-title function_\">type</span>(); <span class=\"hljs-comment\">// 'transpose'</span>\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6ee8d52ae604da494717e48439cc0b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>具体的实现如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/coordinate/transforms.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">transpose</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-string\">'transpose'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">[px, py]</span>) =&gt;</span> [py, px]);\n}\n</code></pre>\n<h3 data-id=\"heading-12\">极坐标（Polar）</h3>\n<p>最后一种基础变换就是极坐标变换，它会将极坐标系下的点转换到笛卡尔坐标系。</p>\n<p>极坐标和笛卡尔坐标系的不同在于点的两个维度的意义不一样。\n笛卡尔坐标系中的点 <code>(x, y)</code> 的 <code>x</code> 和 <code>y</code> 可以简单理解点分别到纵轴和横轴的距离。</p>\n<p>而相同的点在极坐标系下就会被表示为 <code>(raduis, theta)</code>，<code>radius</code> 是到极点的距离，<code>theta</code> 是点和极点的连线和极轴的角度。两者可以相互转换。具体参考下面这张图。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08ad138879d7417693bed5f407fa51b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"20211217162113.jpg\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>极坐标变换可以如下把条形图转换成玫瑰图。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7b226eb7bb44811aee7599207eb6957~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"20211217145857.jpg\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>具体的实现如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/coordinate/transforms.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">polar</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-comment\">// 这里我们把点的第一个维度作为 theta</span>\n  <span class=\"hljs-comment\">// 第二个维度作为 radius</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-string\">'polar'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">[theta, radius]</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> x = radius * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">cos</span>(theta);\n    <span class=\"hljs-keyword\">const</span> y = radius * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sin</span>(theta);\n    <span class=\"hljs-keyword\">return</span> [x, y];\n  });\n}\n</code></pre>\n<p>基本变换就这些了，但是它们还不能直接被坐标系使用，它们需要被组合，才能被坐标系直接使用，接下来我们就一起来看看坐标系变换。</p>\n<h2 data-id=\"heading-13\">坐标系变换</h2>\n<p>坐标系变换会据画布的位置和大小，以及基本变换本身需要的参数去生成一个由基本变换构成的数组。所以所有的坐标系变换都应该接受两个参数：<code>transformOptions</code> 和 <code>canvasOptions</code>，然后返回一个数组。我们首先通过笛卡尔坐标系变换来理解这个概念。</p>\n<h3 data-id=\"heading-14\">笛卡尔坐标系变换</h3>\n<p>Cooridante 里的笛卡尔坐标系变换是将统计学上的点线性转换成画布上的点。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ff670e4f4f84450a0ff1feaf5206f5b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"20211217165953.jpg\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>它的使用方法如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { cartesian } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./cartesian'</span>;\n\n<span class=\"hljs-keyword\">const</span> canvasOptions = {\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">600</span>,\n  <span class=\"hljs-attr\">hieght</span>: <span class=\"hljs-number\">400</span>,\n};\n\n<span class=\"hljs-comment\">// cartesian 不需要 transformOptions</span>\n<span class=\"hljs-keyword\">const</span> transforms = <span class=\"hljs-title function_\">cartesian</span>(<span class=\"hljs-literal\">undefined</span>, canvasOptions);\n<span class=\"hljs-comment\">// 合成一个函数</span>\n<span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-title function_\">compose</span>(...transforms);\n\n<span class=\"hljs-title function_\">map</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>]); <span class=\"hljs-comment\">// [0, 0]</span>\n<span class=\"hljs-title function_\">map</span>([<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.5</span>]); <span class=\"hljs-comment\">// [300, 200]</span>\n<span class=\"hljs-title function_\">map</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>]); <span class=\"hljs-comment\">// [600, 400]</span>\n</code></pre>\n<p>但是这里存在一个问题 <code>transformOptions</code> 在定义坐标系的时候需要用户显示指定的，<code>canvasOptions</code> 是在执行坐标系函数的时候被传入的，两者被传入的时间不同。</p>\n<p>这个时候就需要延迟函数的执行，只有当 <code>transformOptions</code> 和 <code>canvasOptions</code> 都被传入的时候才执行该函数。这久可以用到我们前面提到的函数柯里化了。柯里化后的 <code>cartesian</code> 就可以如下使用。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> transforms = <span class=\"hljs-title function_\">cartesian</span>()(canvasOptions);\n</code></pre>\n<p>笛卡尔坐标系变换的实现如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/coordinate/cartesian.js</span>\n\n<span class=\"hljs-keyword\">import</span> { curry } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n<span class=\"hljs-keyword\">import</span> { scale, translate } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./transforms'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">coordinate</span>(<span class=\"hljs-params\">transformOptions, canvasOptions</span>) {\n  <span class=\"hljs-keyword\">const</span> {\n    x, y, width, height,\n  } = canvasOptions;\n  <span class=\"hljs-keyword\">return</span> [\n    <span class=\"hljs-title function_\">scale</span>(width, height),\n    <span class=\"hljs-title function_\">translate</span>(x, y),\n  ];\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> cartesian = <span class=\"hljs-title function_\">curry</span>(coordinate);\n</code></pre>\n<p>当然这里使用的 <code>curry</code> 会和之前提到的有一点不一样：当不传入参数的时候，需要等价于传入了 <code>undefined</code> 参数。也就是在使用柯里化后的 <code>cartesian</code> 函数的时候 <code>cartesian()</code> 等价于<code>caresian(undefined)</code>。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/utils/helper.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curry</span>(<span class=\"hljs-params\">fn</span>) {\n  <span class=\"hljs-keyword\">const</span> arity = fn.<span class=\"hljs-property\">length</span>;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">curried</span>(<span class=\"hljs-params\">...args</span>) {\n    <span class=\"hljs-comment\">// 如果没有传入参数就把参数列表设置为 [undefined]</span>\n    <span class=\"hljs-keyword\">const</span> newArgs = args.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span> ? [<span class=\"hljs-literal\">undefined</span>] : args;\n    <span class=\"hljs-keyword\">if</span> (newArgs.<span class=\"hljs-property\">length</span> &gt;= arity) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">fn</span>(...newArgs);\n    <span class=\"hljs-keyword\">return</span> curried.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-literal\">null</span>, ...newArgs);\n  };\n}\n</code></pre>\n<h3 data-id=\"heading-15\">极坐标系变换</h3>\n<p>接下来我们来看看我们的第二个坐标系变换：极坐标系变换，这里的极坐标系变换和前面的极坐标变换的区别在于：</p>\n<ul>\n<li>极点不同：极点从画布左上角变成了画布中心。</li>\n<li>大小不同：坐标系构成的圆形会内切画布。</li>\n<li>范围不同：可以指定坐标系开始的角度：<code>startAngle</code> 和结束的角度 <code>endAngle</code>。也可以指定内半径 <code>innerRadius</code> 和外半径 <code>outerRadius</code> （范围都是：<code>[0, 1]</code>)。</li>\n</ul>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b314ab5aceea4c199a696d87fd965983~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"20211217142537.jpg\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>为了达到上图中的效果，需要进行如下图的一些列变换：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d007b736c1d64c33846aa7c0d591158d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"20211217154039.jpg\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>代码实现如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/coordinate/polar.js</span>\n\n<span class=\"hljs-keyword\">import</span> {\n  translate, scale, reflectY, polar <span class=\"hljs-keyword\">as</span> polarT,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./transforms'</span>;\n<span class=\"hljs-keyword\">import</span> { curry } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils/helper'</span>;\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">coordinate</span>(<span class=\"hljs-params\">transformOptions, canvasOptions</span>) {\n  <span class=\"hljs-keyword\">const</span> { width, height } = canvasOptions;\n  <span class=\"hljs-keyword\">const</span> {\n    innerRadius, outerRadius, startAngle, endAngle,\n  } = transformOptions;\n  \n  <span class=\"hljs-comment\">// 保证最后经过 cartesian 变化之后是一个圆形</span>\n  <span class=\"hljs-comment\">// 需要根据画布宽高去调整</span>\n  <span class=\"hljs-keyword\">const</span> aspect = width / height;\n  <span class=\"hljs-keyword\">const</span> sx = aspect &gt; <span class=\"hljs-number\">1</span> ? <span class=\"hljs-number\">1</span> / aspect : <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">const</span> sy = aspect &gt; <span class=\"hljs-number\">1</span> ? <span class=\"hljs-number\">1</span> : aspect;\n  \n  <span class=\"hljs-keyword\">return</span> [\n    <span class=\"hljs-comment\">// 以画布中心沿着 y 方向翻转</span>\n    <span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">0.5</span>),\n    <span class=\"hljs-title function_\">reflectY</span>(),\n    <span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.5</span>),\n    \n    <span class=\"hljs-comment\">// 调整角度和半径的范围</span>\n    <span class=\"hljs-title function_\">scale</span>(endAngle - startAngle, outerRadius - innerRadius),\n    <span class=\"hljs-title function_\">translate</span>(startAngle, innerRadius),\n    <span class=\"hljs-title function_\">polarT</span>(),\n    \n    <span class=\"hljs-comment\">// 改变大小内切画布</span>\n    <span class=\"hljs-title function_\">scale</span>(sx, sy),\n    <span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.5</span>),\n    \n    <span class=\"hljs-comment\">// 移动到画布中心</span>\n    <span class=\"hljs-title function_\">translate</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.5</span>),\n  ];\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> polar = <span class=\"hljs-title function_\">curry</span>(coordinate);\n</code></pre>\n<h2 data-id=\"heading-16\">作业</h2>\n<p>出了笛卡尔和极坐标系变换，Sparrow 的 Coordinate 还支持转置坐标系变换。这个就当留给大家的作业了，期望的效果如下图。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62608ea22a0a434dbf53bc2c2cacb097~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"20211217144245.jpg\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>具体的实现可以参考<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Fblob%2Fmain%2Fsrc%2Fcoordinate%2Ftranspose.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/blob/main/src/coordinate/transpose.js\" ref=\"nofollow noopener noreferrer\">这里</a>，测试代码在<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Fblob%2Fmain%2F__tests__%2Fcoordinate%2Ftranspose.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/blob/main/__tests__/coordinate/transpose.spec.js\" ref=\"nofollow noopener noreferrer\">这里</a>。</p>\n<h2 data-id=\"heading-17\">createCoordinate</h2>\n<p>在了解一些基本变换和坐标系变换之后，理解 <code>createCoordinate</code> 的实现就没有太多困难了。</p>\n<p>前面我们提到，坐标系本身是一个函数，它会将我们输入的点进行一系列坐标变换，然后得到该点在画布上的坐标。这个场景就是一个使用函数复合的典型场景：将一系列变换合成一个复合变换。具体的实现如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/coordinate/coordinate.js</span>\n\n<span class=\"hljs-keyword\">import</span> { compose } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createCoordinate</span>(<span class=\"hljs-params\">{\n  x, y, width, height,\n  transforms: coordinates = [],\n}</span>) {\n  <span class=\"hljs-comment\">// coordinates 是坐标系变换函数</span>\n  <span class=\"hljs-comment\">// 它们是已经接受了 transformOptions 的柯里化函数</span>\n  <span class=\"hljs-comment\">// 它们还需要我们传入 canvasOptions</span>\n  <span class=\"hljs-comment\">// 它们返回一个由基本变换构成的数组，所以在复合前需要通过 flat 把数组拍平</span>\n  <span class=\"hljs-comment\">// [[transpose, reflect], [transpose, reflect]]</span>\n  <span class=\"hljs-comment\">// -&gt; [transpose, reflect, transpose, reflect]</span>\n  <span class=\"hljs-keyword\">const</span> transforms = coordinates\n    .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">coordinate</span>) =&gt;</span> <span class=\"hljs-title function_\">coordinate</span>({\n      x, y, width, height, <span class=\"hljs-comment\">// 传入 canvasOptions</span>\n    }))\n    .<span class=\"hljs-title function_\">flat</span>(); <span class=\"hljs-comment\">// 拍平</span>\n  <span class=\"hljs-keyword\">const</span> output = <span class=\"hljs-title function_\">compose</span>(...transforms); <span class=\"hljs-comment\">// 复合</span>\n  \n  <span class=\"hljs-comment\">// 某些场景需要获得坐标系的种类信息</span>\n  <span class=\"hljs-keyword\">const</span> types = transforms.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-title function_\">type</span>());\n  \n  <span class=\"hljs-comment\">// 判断是否是极坐标系</span>\n  output.<span class=\"hljs-property\">isPolar</span> = <span class=\"hljs-function\">() =&gt;</span> types.<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-string\">'polar'</span>) !== -<span class=\"hljs-number\">1</span>;\n  \n  <span class=\"hljs-comment\">// 判断是否转置</span>\n  <span class=\"hljs-comment\">// 只有是奇数个 'transpose' 的时候才是转置</span>\n  <span class=\"hljs-comment\">// 这里使用了异或：a ^ b， 只有当 a 和 b 值不相同的时候才为 true，否者为 false</span>\n  output.<span class=\"hljs-property\">isTranspose</span> = <span class=\"hljs-function\">() =&gt;</span> types.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">is, type</span>) =&gt;</span> is ^ (type === <span class=\"hljs-string\">'transpose'</span>), <span class=\"hljs-literal\">false</span>);\n  \n  <span class=\"hljs-comment\">// 获得坐标系画布的中心</span>\n  output.<span class=\"hljs-property\">center</span> = <span class=\"hljs-function\">() =&gt;</span> [x + width / <span class=\"hljs-number\">2</span>, y + height / <span class=\"hljs-number\">2</span>];\n  \n  <span class=\"hljs-keyword\">return</span> output;\n}\n</code></pre>\n<p>Sparrow 中使用的 <code>compose</code> 的功能会和之前介绍的有一点不同：当没有参数传入的时候，会返回一个 <code>identity</code> 函数。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> identity = <span class=\"hljs-title function_\">compose</span>();\n<span class=\"hljs-title function_\">identity</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-title function_\">identity</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n<p>所以这里的 <code>compose</code> 的实现会和之前有些略微的不同。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/utils/helper.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">identity</span>(<span class=\"hljs-params\">x</span>) {\n  <span class=\"hljs-keyword\">return</span> x;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">compose</span>(<span class=\"hljs-params\">...fns</span>) {\n  <span class=\"hljs-keyword\">return</span> fns.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">total, cur</span>) =&gt;</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">x</span>) =&gt;</span> <span class=\"hljs-title function_\">cur</span>(<span class=\"hljs-title function_\">total</span>(x)), identity);\n}\n</code></pre>\n<p>最后不要忘记将我们需要的东西导出。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/coordinate/index.js</span>\n\n<span class=\"hljs-keyword\">export</span> { createCoordinate } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./coordinate'</span>;\n<span class=\"hljs-keyword\">export</span> { cartesian } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./cartesian'</span>;\n<span class=\"hljs-keyword\">export</span> { polar } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./polar'</span>;\n<span class=\"hljs-keyword\">export</span> { transpose } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./transpose'</span>;\n</code></pre>\n<p>完整的代码可以在<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2Fsrc%2Fcoordiante\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/src/coordiante\" ref=\"nofollow noopener noreferrer\">这里</a>浏览，同样也可以通过<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fcoordiante\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/coordiante\" ref=\"nofollow noopener noreferrer\">这里</a>的测试代码来验证代码的正确性。</p>\n<h2 data-id=\"heading-18\">拓展</h2>\n<p>这一篇文章的主要内容就到这里了，其主要分为两大块：函数式编程和坐标系。</p>\n<p>函数式编程只给大家介绍了其中的一些基本概念和工具，更深入的学习推荐大家去阅读这本书：<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMostlyAdequate%2Fmostly-adequate-guide\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/MostlyAdequate/mostly-adequate-guide\" ref=\"nofollow noopener noreferrer\">《Mostly Adequate Guide to Function Programming》</a>。本篇文章中关于函数式编程的介绍几乎都来自于它的前面几节，后面会介绍范畴论和函子等比较高级的话题。同时也推荐大家去使用和阅读 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Flodash%2Flodash%2Ftree%2Fnpm%2Ffp\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/lodash/lodash/tree/npm/fp\" ref=\"nofollow noopener noreferrer\">lodash/fb</a>: 一个函数式编程的工具库，更加深入理解函数式编程。</p>\n<p>至于坐标系，这里其实只给大家介绍了其中三种最基础的坐标系变换，还有更多的坐标系变换，比如平行坐标系、鱼眼等(如下图）。大家感兴趣可以去这里看<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fobservablehq.com%2F%40pearmini%2Fantv-coord\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://observablehq.com/@pearmini/antv-coord\" ref=\"nofollow noopener noreferrer\">在线展示</a>，也可以去看 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fcoord\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/coord\" ref=\"nofollow noopener noreferrer\">@antv/coord</a> 的相关实现。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b00aaa25ba1a4cda9291adf60e8ae7d3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-19\">小结</h2>\n<p>最后，又到了我们的小结时间了。</p>\n<p>本篇文章我们首先通过一个计算海鸥数量的例子带大家认识了函数式编程，然后学习其中两个重要概念：一等公民和纯函数，接下来又认识了函数柯里化和函数复合这两个强有力的工具。</p>\n<p>大家也许对函数式编程相关的东西还是云里雾里的，没有关系，这里大家注意一点就好：<strong>在 Sparrow 的后续开发过程中，我们尽量使用纯函数去实现我们的功能</strong>。也就是说尽量将一个函数的不纯的部分抽离出去。至于这样做的好处，在纯函数那部分也说的比较清楚了。</p>\n<p>在介绍完函数式编程之后，就大家介绍了坐标系的基本概念和实现方法，知道了它的主要功能是对视觉元素进行布局。在学习坐标系的过程中，我们知道了它的本质其实是一个由多个基础变换复合而来的函数，用于将统计意义上的点转换成画布坐标。</p>\n<p>目前为止，结合上一章的比例尺，我们已经将编码的映射和布局过程需要用到的工具都实现了！因为都是涉及数据处理，所以这两部分会相对比较抽象。</p>\n<p>但好消息是，数据处理相关的东西暂时告一段落了。下一章我们将进入生动形象的内容：几何图形（Geometry），看看如何把我们处理好的数据绘制出来。这个过程不仅仅能加深大家对比例尺和坐标系的理解，也是将直接展示 Sparrow 能力的地方！</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68663fd7ae66473ebc172cc73aca7c57~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<blockquote>\n<p>参考资料</p>\n<ul>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMostlyAdequate%2Fmostly-adequate-guide\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/MostlyAdequate/mostly-adequate-guide\" ref=\"nofollow noopener noreferrer\">Mostly Adequate Guide to Function Programming, Professor Franklin Frisby</a></li>\n<li><a href=\"https://link.juejin.cn?target=http%3A%2F%2Fruanyifeng.com%2Fblog%2F2017%2F02%2Ffp-tutorial.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"http://ruanyifeng.com/blog/2017/02/fp-tutorial.html\" ref=\"nofollow noopener noreferrer\">函数式编程入门教程, 阮一峰</a></li>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.jdon.com%2F42422\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://www.jdon.com/42422\" ref=\"nofollow noopener noreferrer\">蒯因与引用透明</a></li>\n<li>The Grammar of Graphics, 2nd Edition, Leland Wilkinson</li>\n</ul>\n</blockquote><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "9\n实战：几何图形 - Geometry\n学习时长: 91分59秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>上一章我们介绍了坐标系，了解了如何把经过比例尺映射后的位置属性，转换成可以绘制到画布上的点。那么接下来我们就来看看如何把转换之后的数据真正地画到画布上。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68663fd7ae66473ebc172cc73aca7c57~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>和前面一样，我们首先会从几何图形的相关理论讲起，然后在 Sparrow 中实现相关的部分。那么接下来废话不多说，就让我们开始吧。</p>\n<h2 data-id=\"heading-0\">几何图形理论</h2>\n<p>几何图形理论主要会介绍两个部分：几何图形（Geometry）和通道（Channel）。了解它们会对我们在选择视觉编码的时候会有帮助，就算再复杂的视觉编码也能被拆分成这两个部分去分析。</p>\n<p>在可视化中，几何图形是根据数据集中的实体（Item）或者链接（Link）去绘制的图形元素，它还有一个同义词是标志（Mark）。通道又或者说视觉通道是用来控制几何图形的外观的。</p>\n<p>下面是《Visualization Analysis &amp; Design》中的一个例子。(a)条形图中用条这个几何图形来编码两个属性，其中分类属性用条的水平位置通道编码，数值属性用条的竖直位置通道来编码。(b)散点图中用点这个几何图形来编码两个数值属性，它们分别用点的水平和竖直位置通道来编码。(c)用颜色通道来编码一个额外的分类属性。（d）用大小通道来编码一个额外的数值属性。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2039ec498d63406baaa5340ef22994f2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>不同的几何图形拥有不同的通道和外观，接下来我们会实现以下的几何图形。每个几何图形的特征和可以绘制的图表我们会在实现过程中介绍。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c02db69695cd4922b98ffee4105fa405~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>下图中展示了一些常见的视觉通道，它们主要分为两类。数值通道（Magnitude Channel）会我们提供和有多少相关的信息，主要用来编码数值属性，比如下图中的位置（Position)、大小（Size）和倾斜角度（Tilt）都是数值属性；特征通道（Identity Channel)给我们提供是什么、在哪里相关的信息，主要用来编码分类属性，比如下图中的形状（Shape）和颜色（Color）。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1897de99008d43eab12b40a012c58f37~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>在设计可视化的时候的一个难点就是：面对手中的数据，选择什么几何图形的什么通道去编码数据的属性，可以让可视化结果能更加高效地传递信息？这部分的内容我们会在后面的分析篇中涉及，接下来的主要内容是实现几何图形。</p>\n<p>在代码中的几何图形和比例尺、坐标一样，都是一个函数，它会将处理好的数据转化成屏幕上的像素点，因为我们的渲染器是基于 SVG 的，所以其实是转换成对应的 SVG 元素。</p>\n<p>需要注意的是：几何图形渲染的数据不是一个数组，而是一个对象。这个对象的每一个 key 都是该几何图形的一个通道，对应的 value 是一个数组，数组的每一个元素是数据和该通道绑定的属性的值。具体可以参考以下的例子。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> data = [\n  { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0.3</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'red'</span> },\n  { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0.4</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0.8</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'yellow'</span> },\n  { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0.1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0.6</span>, <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'blue'</span> },\n]\n\n<span class=\"hljs-keyword\">const</span> values = {\n  <span class=\"hljs-attr\">x</span>: [<span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.4</span>, <span class=\"hljs-number\">0.1</span>],\n  <span class=\"hljs-attr\">y</span>: [<span class=\"hljs-number\">0.3</span>, <span class=\"hljs-number\">0.8</span>, <span class=\"hljs-number\">0.6</span>],\n  <span class=\"hljs-attr\">color</span>: [<span class=\"hljs-string\">'red'</span>, <span class=\"hljs-string\">'yellow'</span>, <span class=\"hljs-string\">'blue'</span>]\n}\n</code></pre>\n<p>所有的几何图形都有如下的函数签名，同时也支持返回该几何图形拥有的通道。这些通道一方面可以对我们渲染的数据进行校验，另一方面可以在后面的开发中使用。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\">\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">Renderer</span>} renderer 渲染引擎\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">number []</span>} I 索引数组\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">[key:string] Scale</span>} scales 每个通道用到的 scale\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">[key:string]: number[]</span>} values 每个通道需要渲染的值\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">[key: string]: string</span>} directStyles 图形的和通道无关的样式\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">Coordinate</span>} coordinate 使用的坐标系\n * <span class=\"hljs-doctag\">@returns</span> 渲染的 SVG 元素\n */</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">geometry</span>(<span class=\"hljs-params\">renderer, I, scales, values, directStyles, coordinate</span>) {}\n\ngeometry.<span class=\"hljs-property\">channels</span> = <span class=\"hljs-function\">() =&gt;</span> ({\n  <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'x'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> },\n  <span class=\"hljs-attr\">y</span>: { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'y'</span> }\n})\n</code></pre>\n<p>接下来还是用散点图的例子来看看几何图形的用法。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { createLinear } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./scale\"</span>;\n<span class=\"hljs-keyword\">import</span> { createCoordinate, transpose, cartesian } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./coordinate'</span>;\n<span class=\"hljs-keyword\">import</span> { point } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./geometry'</span>;\n\n<span class=\"hljs-comment\">// 希望绘制一个散点图来看下面数据的分布</span>\n<span class=\"hljs-keyword\">const</span> data = [\n  { <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">180</span>, <span class=\"hljs-attr\">weight</span>: <span class=\"hljs-number\">150</span> },\n  { <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">163</span>, <span class=\"hljs-attr\">weight</span>: <span class=\"hljs-number\">94</span> },\n  { <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">173</span>, <span class=\"hljs-attr\">weight</span>: <span class=\"hljs-number\">130</span> }\n];\n\n<span class=\"hljs-comment\">// 将对应的值提取出来</span>\n<span class=\"hljs-keyword\">const</span> H = data.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">height</span>);\n<span class=\"hljs-keyword\">const</span> W = data.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">weight</span>);\n<span class=\"hljs-keyword\">const</span> I = data.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_, index</span>) =&gt;</span> index);\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">extent</span> = d =&gt; [<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(...d), <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(...d)];\n\n<span class=\"hljs-comment\">// 将数据的 height 映射为点的 x 属性（这里注意 range 是 [0, 1]）</span>\n<span class=\"hljs-keyword\">const</span> scaleX = <span class=\"hljs-title function_\">createLinear</span>({\n  <span class=\"hljs-attr\">domain</span>: <span class=\"hljs-title function_\">extent</span>(H),\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>]\n});\n\n<span class=\"hljs-comment\">// 将数据的 width 映射为点的 y 属性（这里注意 range 是 [0, 1]）</span>\n<span class=\"hljs-keyword\">const</span> scaleY = <span class=\"hljs-title function_\">createLinear</span>({\n  <span class=\"hljs-attr\">domain</span>: <span class=\"hljs-title function_\">extent</span>(W),\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n})\n\n<span class=\"hljs-comment\">// 创建一个坐标系</span>\n<span class=\"hljs-keyword\">const</span> coordinate = <span class=\"hljs-title function_\">createCoordinate</span>({\n  <span class=\"hljs-comment\">// 指定画布的起点和宽高</span>\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">600</span>,\n  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">400</span>,\n  <span class=\"hljs-comment\">// 一系列坐标系变换</span>\n  <span class=\"hljs-attr\">transforms</span>: [\n    <span class=\"hljs-title function_\">transpose</span>(),\n    <span class=\"hljs-title function_\">cartesian</span>(),\n  ]\n});\n\n<span class=\"hljs-comment\">// 使用比例尺映射数据</span>\n<span class=\"hljs-keyword\">const</span> values = {\n  <span class=\"hljs-attr\">x</span>: H.<span class=\"hljs-title function_\">map</span>(scaleX),\n  <span class=\"hljs-attr\">y</span>: W.<span class=\"hljs-title function_\">map</span>(scaleY)\n};\n\n<span class=\"hljs-keyword\">const</span> scales = {\n  <span class=\"hljs-attr\">x</span>: scaleX,\n  <span class=\"hljs-attr\">y</span>: scaleY\n};\n\n<span class=\"hljs-comment\">// 设置样式</span>\n<span class=\"hljs-keyword\">const</span> styles = {\n  <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'none'</span>,\n  <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'steelblue'</span>\n};\n\n<span class=\"hljs-comment\">// 绘制点</span>\n<span class=\"hljs-title function_\">point</span>(renderer, scales, values, styles, coordinate);\n</code></pre>\n<p>在正式进入写代码环节之前，对 SVG 的 path 元素不了解的可以先去<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FSVG%2FTutorial%2FPaths\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths\" ref=\"nofollow noopener noreferrer\">这里</a>学习一下，因为接下来的部分很多地方都需要用到它。</p>\n<h2 data-id=\"heading-1\">创建通道</h2>\n<p>首先我们先来实现通道的创建，每一个通道都是一个对象，它拥有的属性如下。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>属性名</th><th>描述</th><th>可选</th><th>默认值</th></tr></thead><tbody><tr><td>name</td><td>属性的名字</td><td>否</td><td>-</td></tr><tr><td>optional</td><td>values 里面是否需要该属性对应的值</td><td>否</td><td><code>true</code></td></tr><tr><td>scale</td><td>需要使用的比例尺</td><td>是</td><td></td></tr></tbody></table>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/channel.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createChannel</span>(<span class=\"hljs-params\">{\n  name, \n  optional = <span class=\"hljs-literal\">true</span>,\n  ...rest\n}</span>) {\n  <span class=\"hljs-keyword\">return</span> { name, optional, ...rest };\n}\n</code></pre>\n<p>对于一个标准的几何元素来说，都具有以下的通道。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/channel.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createChannels</span>(<span class=\"hljs-params\">options = {}</span>) {\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'x'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }), <span class=\"hljs-comment\">// x 坐标</span>\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'y'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }), <span class=\"hljs-comment\">// y 坐标</span>\n    <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'stroke'</span> }), <span class=\"hljs-comment\">// 边框颜色</span>\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'fill'</span> }), <span class=\"hljs-comment\">// 填充颜色</span>\n    ...options,\n  };\n}\n</code></pre>\n<h2 data-id=\"heading-2\">创建几何图形</h2>\n<p>创建完通道，我们就来看看几何图形的创建。对于每一个几何图形，我们需要定义它的通道和渲染函数，并且在渲染之前检查一下是否提供了需要的数据和正确的比例尺。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/geometry.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createGeometry</span>(<span class=\"hljs-params\">channels, render</span>) {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">geometry</span> = (<span class=\"hljs-params\">renderer, I, scales, values, styles, coordinate</span>) =&gt; {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, { optional, scale }] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(channels)) {\n      <span class=\"hljs-comment\">// 只有必选的通道才会被检查</span>\n      <span class=\"hljs-keyword\">if</span> (!optional) {\n        <span class=\"hljs-comment\">// 如果没有提供对应的值就抛出异常</span>\n        <span class=\"hljs-keyword\">if</span> (!values[key]) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Missing Channel: <span class=\"hljs-subst\">${key}</span>`</span>);\n        <span class=\"hljs-comment\">// 目前只用判断一下 band 比例尺</span>\n        <span class=\"hljs-keyword\">if</span> (scale === <span class=\"hljs-string\">'band'</span> &amp;&amp; (!scales[key] || !scales[key].<span class=\"hljs-property\">bandWidth</span>)) {\n          <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">${key}</span> channel needs band scale.`</span>);\n        }\n      }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">render</span>(renderer, I, scales, values, styles, coordinate);\n  };\n\n  <span class=\"hljs-comment\">// 将需要的通道返回</span>\n  geometry.<span class=\"hljs-property\">channels</span> = <span class=\"hljs-function\">() =&gt;</span> channels;\n\n  <span class=\"hljs-keyword\">return</span> geometry;\n}\n</code></pre>\n<p>知道了如何创建一个几何图形，那么接下来我们就来一起实现一些基本的几何图形。</p>\n<h2 data-id=\"heading-3\">点（Point）</h2>\n<p>首先我们从点（Point）开始，点这个几何图形最基本的使用就是散点图，同时也可以用于气泡图、图可视化等中。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce68efe8e9414caf9bf48c22ad258d6e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>除了基本的通道以外，点还有一个半径（r）通道，去控制点的大小。结合上面的使用方法，下面的代码应该就不难理解了。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/point.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createChannel, createChannels } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./channel'</span>;\n<span class=\"hljs-keyword\">import</span> { circle } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./shape'</span>;\n<span class=\"hljs-keyword\">import</span> { channelStyles } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./style'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">point</span>(<span class=\"hljs-params\">renderer, I, scales, channels, directStyles, coordinate</span>) {\n  <span class=\"hljs-comment\">//  默认的一些属性</span>\n  <span class=\"hljs-keyword\">const</span> defaults = {\n    <span class=\"hljs-attr\">r</span>: <span class=\"hljs-number\">3</span>,\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'none'</span>,\n  };\n  <span class=\"hljs-comment\">// 获取每一个通道经过比例尺映射的值</span>\n  <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">x</span>: X, <span class=\"hljs-attr\">y</span>: Y, <span class=\"hljs-attr\">r</span>: R = [] } = channels;\n  \n  <span class=\"hljs-comment\">// 通过索引去获得每一条数据各个通道的值</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(I, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">r</span>: dr, ...restDefaults } = defaults;\n    <span class=\"hljs-keyword\">const</span> r = R[i] || dr;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">circle</span>(renderer, coordinate, {\n      ...restDefaults,\n      <span class=\"hljs-comment\">// 元素的样式由直接指定的样式和通过通道指定的样式决定</span>\n      <span class=\"hljs-comment\">// 经过通道指定的样式就是和数据相关的样式</span>\n      <span class=\"hljs-comment\">// 后的优先级更高</span>\n      ...directStyles,\n      ...<span class=\"hljs-title function_\">channelStyles</span>(i, channels),\n      <span class=\"hljs-comment\">// 圆心的位置</span>\n      <span class=\"hljs-attr\">cx</span>: X[i],\n      <span class=\"hljs-attr\">cy</span>: Y[i],\n      r,\n    });\n  });\n}\n\npoint.<span class=\"hljs-property\">channels</span> = <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">createChannels</span>({\n  <span class=\"hljs-attr\">r</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'r'</span> }),\n});\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/style.js</span>\n\n<span class=\"hljs-comment\">// 获得由通道指定的样式</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">channelStyles</span>(<span class=\"hljs-params\">index, channels</span>) {\n  <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">stroke</span>: S, <span class=\"hljs-attr\">fill</span>: F } = channels;\n  <span class=\"hljs-comment\">// 只有当 stroke 和 fill 这两个通道被指定的时候才会有用</span>\n  <span class=\"hljs-keyword\">return</span> {\n    ...(S &amp;&amp; { <span class=\"hljs-attr\">stroke</span>: S[index] }),\n    ...(F &amp;&amp; { <span class=\"hljs-attr\">fill</span>: F[index] }),\n  };\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/shape.js</span>\n\n<span class=\"hljs-comment\">// 绘制不同坐标系下面的圆</span>\n<span class=\"hljs-comment\">// 绘制圆的函数和渲染器里面绘制圆的区别在于</span>\n<span class=\"hljs-comment\">// 这里需要考虑坐标系</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">circle</span>(<span class=\"hljs-params\">renderer, coordinate, { cx, cy, r, ...styles }</span>) {\n  <span class=\"hljs-comment\">// 对圆心进行坐标系变换</span>\n  <span class=\"hljs-keyword\">const</span> [px, py] = <span class=\"hljs-title function_\">coordinate</span>([cx, cy]);\n  <span class=\"hljs-keyword\">return</span> renderer.<span class=\"hljs-title function_\">circle</span>({ <span class=\"hljs-attr\">cx</span>: px, <span class=\"hljs-attr\">cy</span>: py, r, ...styles });\n}\n</code></pre>\n<p>最后运行<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fgeometry%2Fpoint.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/point.spec.js\" ref=\"nofollow noopener noreferrer\">测试代码</a>会有以下的结果。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f10e77f7ed34208b7d203db1d9d9597~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-4\">文字（Text）</h2>\n<p>文字（Text）和点很像，只不过额外拥有旋转角度（rotate）、字体大小（fontSize）和内容（text）这些通道。文本一个典型用法就是词云图。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/622e4d98592a408c84150838c3d1ab39~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>它的实现和点类似。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/text.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createChannel, createChannels } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./channel'</span>;\n<span class=\"hljs-keyword\">import</span> { createGeometry } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./geometry'</span>;\n<span class=\"hljs-keyword\">import</span> { text <span class=\"hljs-keyword\">as</span> shapeText } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./shape'</span>;\n<span class=\"hljs-keyword\">import</span> { channelStyles } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./style'</span>;\n\n<span class=\"hljs-keyword\">const</span> channels = <span class=\"hljs-title function_\">createChannels</span>({\n  <span class=\"hljs-attr\">rotate</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'rotate'</span> }),\n  <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'fontSize'</span> }),\n  <span class=\"hljs-attr\">text</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'text'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }),\n});\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">renderer, I, scales, values, directStyles, coordinate</span>) {\n  <span class=\"hljs-keyword\">const</span> defaults = {\n    <span class=\"hljs-attr\">rotate</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-number\">14</span>,\n  };\n  <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">x</span>: X, <span class=\"hljs-attr\">y</span>: Y, <span class=\"hljs-attr\">text</span>: T, <span class=\"hljs-attr\">rotate</span>: R = [], <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-variable constant_\">FS</span> = [] } = values;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(I, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> <span class=\"hljs-title function_\">shapeText</span>(renderer, coordinate, {\n    ...directStyles,\n    ...<span class=\"hljs-title function_\">channelStyles</span>(i, values),\n    <span class=\"hljs-attr\">x</span>: X[i],\n    <span class=\"hljs-attr\">y</span>: Y[i],\n    <span class=\"hljs-attr\">rotate</span>: R[i] || defaults.<span class=\"hljs-property\">rotate</span>,\n    <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-variable constant_\">FS</span>[i] || defaults.<span class=\"hljs-property\">fontSize</span>,\n    <span class=\"hljs-attr\">text</span>: T[i],\n  }));\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> text = <span class=\"hljs-title function_\">createGeometry</span>(channels, render);\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/shape.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">text</span>(<span class=\"hljs-params\">renderer, coordinate, { x, y, rotate, text, ...styles }</span>) {\n  <span class=\"hljs-keyword\">const</span> [px, py] = <span class=\"hljs-title function_\">coordinate</span>([x, y]);\n  renderer.<span class=\"hljs-title function_\">save</span>();\n  <span class=\"hljs-comment\">// 将词旋转</span>\n  renderer.<span class=\"hljs-title function_\">translate</span>(px, py);\n  renderer.<span class=\"hljs-title function_\">rotate</span>(rotate);\n  <span class=\"hljs-keyword\">const</span> textElement = renderer.<span class=\"hljs-title function_\">text</span>({ text, <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, ...styles });\n  renderer.<span class=\"hljs-title function_\">restore</span>();\n  <span class=\"hljs-keyword\">return</span> textElement;\n}\n</code></pre>\n<p>最后运行<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fgeometry%2Ftext.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/text.spec.js\" ref=\"nofollow noopener noreferrer\">测试代码</a>会有以下的结果。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26d8347b3ebf405599607b015aba2286~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-5\">链接（Link）</h2>\n<p>实现完了文字，我们接下来看看链接（Link）。链接可以用来绘制下面图中的边。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6006663372384df0889c5c5e4c9c64ab~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>因为链接本质上就是一条直线，所以它需要通过两个点来确定。我们已经通过通道 x 和 y 去确定一个点了，所以它还需要通过额外的 x1 和 x2 这两个通道去确定另外一个点。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44a6ad31cd014bc2b2a9c7d22542f4de~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>具体的实现如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/link.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createChannels, createChannel } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./channel'</span>;\n<span class=\"hljs-keyword\">import</span> { createGeometry } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./geometry'</span>;\n<span class=\"hljs-keyword\">import</span> { link <span class=\"hljs-keyword\">as</span> shapeLink } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./shape'</span>;\n<span class=\"hljs-keyword\">import</span> { channelStyles } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./style'</span>;\n\n<span class=\"hljs-keyword\">const</span> channels = <span class=\"hljs-title function_\">createChannels</span>({\n  <span class=\"hljs-attr\">x1</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'x1'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }),\n  <span class=\"hljs-attr\">y1</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'y1'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }),\n});\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">renderer, I, scales, values, directStyles, coordinate</span>) {\n  <span class=\"hljs-keyword\">const</span> defaults = {};\n  <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">x</span>: X, <span class=\"hljs-attr\">y</span>: Y, <span class=\"hljs-attr\">x1</span>: <span class=\"hljs-variable constant_\">X1</span>, <span class=\"hljs-attr\">y1</span>: <span class=\"hljs-variable constant_\">Y1</span> } = values;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(I, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> <span class=\"hljs-title function_\">shapeLink</span>(renderer, coordinate, {\n    ...defaults,\n    ...directStyles,\n    ...<span class=\"hljs-title function_\">channelStyles</span>(i, values),\n    <span class=\"hljs-attr\">x1</span>: X[i],\n    <span class=\"hljs-attr\">y1</span>: Y[i],\n    <span class=\"hljs-attr\">x2</span>: <span class=\"hljs-variable constant_\">X1</span>[i],\n    <span class=\"hljs-attr\">y2</span>: <span class=\"hljs-variable constant_\">Y1</span>[i],\n  }));\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> link = <span class=\"hljs-title function_\">createGeometry</span>(channels, render);\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/shape.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">link</span>(<span class=\"hljs-params\">renderer, coordinate, { x1, y1, x2, y2, ...styles }</span>) {\n  <span class=\"hljs-keyword\">const</span> [p0, p1] = [[x1, y1], [x2, y2]].<span class=\"hljs-title function_\">map</span>(coordinate);\n  <span class=\"hljs-keyword\">return</span> renderer.<span class=\"hljs-title function_\">line</span>({ <span class=\"hljs-attr\">x1</span>: p0[<span class=\"hljs-number\">0</span>], <span class=\"hljs-attr\">y1</span>: p0[<span class=\"hljs-number\">1</span>], <span class=\"hljs-attr\">x2</span>: p1[<span class=\"hljs-number\">0</span>], <span class=\"hljs-attr\">y2</span>: p1[<span class=\"hljs-number\">1</span>], ...styles });\n}\n</code></pre>\n<p>最后运行<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fgeometry%2Flink.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/link.spec.js\" ref=\"nofollow noopener noreferrer\">测试代码</a>会有以下的结果。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f2fa0c224a24b21a40f933884b2f568~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-6\">线（Line）</h2>\n<p>接下来我们来看看线（Line）这个几何图形的实现，线主要用来实现折线图或者雷达图等。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdd01dc047b641efbe7984b4e78984d8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>线是由多个点连接而成，连接它们的可以是直线，也可以是曲线，我们这里只实现通过直线来连接这些点。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a75d1a99343e4951be9db2e53bdec156~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>线除了基本的通道之外，还有一个额外的 z 通道，用来对数据进行分组，从而绘制多条线，参考下面的例子。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// z 通道表示种类</span>\n<span class=\"hljs-keyword\">const</span> values = {\n  <span class=\"hljs-attr\">x</span>: [<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.3</span>, <span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.9</span>, <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.4</span>, <span class=\"hljs-number\">0.6</span>, <span class=\"hljs-number\">0.8</span>],\n  <span class=\"hljs-attr\">y</span>: [<span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.9</span>, <span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.9</span>, <span class=\"hljs-number\">0.3</span>, <span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.9</span>],\n  <span class=\"hljs-attr\">z</span>: [<span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'b'</span>],\n}\n\n<span class=\"hljs-comment\">// 上面的 values 会被拆分成两部分数据</span>\n<span class=\"hljs-comment\">// 每部分数据对应一条线</span>\n<span class=\"hljs-comment\">// z 为 'a' 的值</span>\n<span class=\"hljs-keyword\">const</span> line1 = {\n  <span class=\"hljs-attr\">x</span>: [<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.3</span>, <span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.9</span>],\n  <span class=\"hljs-attr\">y</span>: [<span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">0.9</span>, <span class=\"hljs-number\">0.2</span>],\n}\n\n<span class=\"hljs-comment\">// z 为 'b' 的值</span>\n<span class=\"hljs-keyword\">const</span> line2 = {\n  <span class=\"hljs-attr\">x</span>: [<span class=\"hljs-number\">0.2</span>, <span class=\"hljs-number\">0.4</span>, <span class=\"hljs-number\">0.6</span>, <span class=\"hljs-number\">0.8</span>],\n  <span class=\"hljs-attr\">y</span>: [<span class=\"hljs-number\">0.9</span>, <span class=\"hljs-number\">0.3</span>, <span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.9</span>]\n}\n</code></pre>\n<p>理解了 z 通道，那么接下来的实现就不难理解了。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/line.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createChannel, createChannels } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./channel'</span>;\n<span class=\"hljs-keyword\">import</span> { groupChannelStyles } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./style'</span>;\n<span class=\"hljs-keyword\">import</span> { line <span class=\"hljs-keyword\">as</span> shapeLine } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./shape'</span>;\n<span class=\"hljs-keyword\">import</span> { group } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n<span class=\"hljs-keyword\">import</span> { createGeometry } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./geometry'</span>;\n\n<span class=\"hljs-keyword\">const</span> channels = <span class=\"hljs-title function_\">createChannels</span>({\n  <span class=\"hljs-attr\">z</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'z'</span> }),\n});\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">renderer, I, scales, values, directStyles, coordinate</span>) {\n  <span class=\"hljs-keyword\">const</span> defaults = {};\n  <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">x</span>: X, <span class=\"hljs-attr\">y</span>: Y, <span class=\"hljs-attr\">z</span>: Z } = values;\n  <span class=\"hljs-comment\">// 将索引 index 按照 z 通道的值分组</span>\n  <span class=\"hljs-comment\">// 每一个组对应一条直线</span>\n  <span class=\"hljs-comment\">// 如果 z 通道没有被指定，就默认一个分组，只绘制一条直线</span>\n  <span class=\"hljs-keyword\">const</span> series = Z ? <span class=\"hljs-title function_\">group</span>(I, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> Z[i]).<span class=\"hljs-title function_\">values</span>() : [I];\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(series, <span class=\"hljs-function\">(<span class=\"hljs-params\">I</span>) =&gt;</span> <span class=\"hljs-title function_\">shapeLine</span>(renderer, coordinate, {\n    ...defaults,\n    ...directStyles,\n    <span class=\"hljs-comment\">// 获该组的样式</span>\n    ...<span class=\"hljs-title function_\">groupChannelStyles</span>(I, values),\n    X,\n    Y,\n    I,\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'none'</span>, <span class=\"hljs-comment\">// 直线是没有填充颜色的</span>\n  }));\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> line = <span class=\"hljs-title function_\">createGeometry</span>(channels, render);\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/style.js</span>\n\n<span class=\"hljs-comment\">// 获取这个组的第一个点的样式作为该条线的样式</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">groupChannelStyles</span>(<span class=\"hljs-params\">[index], channels</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">channelStyles</span>(index, channels);\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/utils/array.js</span>\n\n<span class=\"hljs-comment\">/**\n * 数据根据 key 分组\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">T[]</span>} array 需要分组的数据\n * <span class=\"hljs-doctag\">@param</span> {<span class=\"hljs-type\">T =&gt; string</span>} key 获得数据 key 的函数\n * <span class=\"hljs-doctag\">@returns</span> {<span class=\"hljs-type\">Map&lt;string, T&gt;</span>}\n * <span class=\"hljs-doctag\">@example</span>\n * const array = [\n *   {name:'a', value: 1},\n *   {name:'a', value: 2},\n *   {name:'b', value: 3}\n * ]\n * const groups = group(array, d =&gt; d.name);\n * groups // Map(2) {'a' =&gt; [{name: 'a', value:1}, {name: 'a', value: 2}], 'b' =&gt; [{name: 'b', value: 3}]}\n */</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">group</span>(<span class=\"hljs-params\">array, key = (d) =&gt; d</span>) {\n  <span class=\"hljs-keyword\">const</span> keyGroups = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> item <span class=\"hljs-keyword\">of</span> array) {\n    <span class=\"hljs-keyword\">const</span> k = <span class=\"hljs-title function_\">key</span>(item);\n    <span class=\"hljs-keyword\">const</span> g = keyGroups.<span class=\"hljs-title function_\">get</span>(k);\n    <span class=\"hljs-keyword\">if</span> (g) {\n      g.<span class=\"hljs-title function_\">push</span>(item);\n    } <span class=\"hljs-keyword\">else</span> {\n      keyGroups.<span class=\"hljs-title function_\">set</span>(k, [item]);\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> keyGroups;\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/utils/index.js</span>\n\n<span class=\"hljs-keyword\">export</span> * <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./array'</span>;\n</code></pre>\n<p>这里稍微提一下绘制一条线的函数：每一条线是一条 path，这条 path 的点由直线的点构成。在极坐标系下这条线需要闭合，所以需要将第一个点加入到最后。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/shape.js</span>\n\n<span class=\"hljs-keyword\">import</span> { line <span class=\"hljs-keyword\">as</span> pathLine } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./d'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">line</span>(<span class=\"hljs-params\">renderer, coordinate, { X, Y, I: I0, ...styles }</span>) {\n  <span class=\"hljs-keyword\">const</span> I = coordinate.<span class=\"hljs-title function_\">isPolar</span>() ? [...<span class=\"hljs-variable constant_\">I0</span>, <span class=\"hljs-variable constant_\">I0</span>[<span class=\"hljs-number\">0</span>]] : <span class=\"hljs-variable constant_\">I0</span>;\n  <span class=\"hljs-keyword\">const</span> points = I.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> <span class=\"hljs-title function_\">coordinate</span>([X[i], Y[i]]));\n  <span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-title function_\">pathLine</span>(points);\n  <span class=\"hljs-keyword\">return</span> renderer.<span class=\"hljs-title function_\">path</span>({ d, ...styles });\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/d.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">line</span>(<span class=\"hljs-params\">[p0, ...points]</span>) {\n  <span class=\"hljs-keyword\">return</span> [\n    [<span class=\"hljs-string\">'M'</span>, ...p0],\n    ...points.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">p</span>) =&gt;</span> [<span class=\"hljs-string\">'L'</span>, ...p]),\n  ];\n}\n</code></pre>\n<p>最后运行<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fgeometry%2Fline.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/line.spec.js\" ref=\"nofollow noopener noreferrer\">测试代码</a>会有以下的结果。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfd097d9451f481c9c89633e1cf12e7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-7\">区域（Area）</h2>\n<p>理解了线，那么理解区域（Area）就比较容易了。两条直线如下首位连接起来就成了一个区域。所以对于区域来讲，我们需要 x1 和 y1 两个额外的通道。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6513ce3c94f465aab37bbdc064cba88~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>区域的常见用途就是面积图，河流图和带填充颜色的雷达图。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfcaa8a14c4b46e39c090283e8d3e18f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/area.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createChannel, createChannels } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./channel'</span>;\n<span class=\"hljs-keyword\">import</span> { groupChannelStyles } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./style'</span>;\n<span class=\"hljs-keyword\">import</span> { area <span class=\"hljs-keyword\">as</span> shapeArea } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./shape'</span>;\n<span class=\"hljs-keyword\">import</span> { group } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n<span class=\"hljs-keyword\">import</span> { createGeometry } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./geometry'</span>;\n\n<span class=\"hljs-keyword\">const</span> channels = <span class=\"hljs-title function_\">createChannels</span>({\n  <span class=\"hljs-attr\">x1</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'x1'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }),\n  <span class=\"hljs-attr\">y1</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'y1'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }),\n  <span class=\"hljs-attr\">z</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'z'</span> }),\n});\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">renderer, I, scales, values, directStyles, coordinate</span>) {\n  <span class=\"hljs-keyword\">const</span> defaults = {};\n  <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">x</span>: X, <span class=\"hljs-attr\">y</span>: Y, <span class=\"hljs-attr\">z</span>: Z, <span class=\"hljs-attr\">x1</span>: <span class=\"hljs-variable constant_\">X1</span>, <span class=\"hljs-attr\">y1</span>: <span class=\"hljs-variable constant_\">Y1</span> } = values;\n  <span class=\"hljs-keyword\">const</span> series = Z ? <span class=\"hljs-title function_\">group</span>(I, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> Z[i]).<span class=\"hljs-title function_\">values</span>() : [I];\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(series, <span class=\"hljs-function\">(<span class=\"hljs-params\">I</span>) =&gt;</span> <span class=\"hljs-title function_\">shapeArea</span>(renderer, coordinate, {\n    ...defaults,\n    ...directStyles,\n    ...<span class=\"hljs-title function_\">groupChannelStyles</span>(I, values),\n    <span class=\"hljs-attr\">X1</span>: X,\n    <span class=\"hljs-attr\">Y1</span>: Y,\n    <span class=\"hljs-attr\">X2</span>: <span class=\"hljs-variable constant_\">X1</span>,\n    <span class=\"hljs-attr\">Y2</span>: <span class=\"hljs-variable constant_\">Y1</span>,\n    I,\n  }));\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> area = <span class=\"hljs-title function_\">createGeometry</span>(channels, render);\n</code></pre>\n<p>绘制每一个区域的时候我们也需要针对不同的坐标系使用不同的绘制方式。和线一样，在极坐标系下我们也需要把区域的首尾连接起来。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { contour } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./primitive'</span>;\n<span class=\"hljs-keyword\">import</span> { area <span class=\"hljs-keyword\">as</span> pathArea } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./d'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">area</span>(<span class=\"hljs-params\">renderer, coordinate, { X1, Y1, X2, Y2, I: I0, ...styles }</span>) {\n  <span class=\"hljs-comment\">// 连接首尾</span>\n  <span class=\"hljs-keyword\">const</span> I = coordinate.<span class=\"hljs-title function_\">isPolar</span>() ? [...<span class=\"hljs-variable constant_\">I0</span>, <span class=\"hljs-variable constant_\">I0</span>[<span class=\"hljs-number\">0</span>]] : <span class=\"hljs-variable constant_\">I0</span>;\n  \n  <span class=\"hljs-comment\">// 将点按照顺时针方向排列</span>\n  <span class=\"hljs-keyword\">const</span> points = [\n    ...I.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> [<span class=\"hljs-variable constant_\">X1</span>[i], <span class=\"hljs-variable constant_\">Y1</span>[i]]),\n    ...I.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> [<span class=\"hljs-variable constant_\">X2</span>[i], <span class=\"hljs-variable constant_\">Y2</span>[i]]).<span class=\"hljs-title function_\">reverse</span>(),\n  ].<span class=\"hljs-title function_\">map</span>(coordinate);\n\n  <span class=\"hljs-comment\">// 如果是在极坐标系下，绘制等高线</span>\n  <span class=\"hljs-keyword\">if</span> (coordinate.<span class=\"hljs-title function_\">isPolar</span>()) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">contour</span>(renderer, { points, ...styles });\n  }\n  \n  <span class=\"hljs-comment\">// 否者直接绘制区域</span>\n  <span class=\"hljs-keyword\">return</span> renderer.<span class=\"hljs-title function_\">path</span>({ <span class=\"hljs-attr\">d</span>: <span class=\"hljs-title function_\">pathArea</span>(points), ...styles });\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/d.js</span>\n\n<span class=\"hljs-comment\">// 和 line 的区别就是进行了闭合操作</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">area</span>(<span class=\"hljs-params\">points</span>) {\n  <span class=\"hljs-keyword\">return</span> [\n    ...<span class=\"hljs-title function_\">line</span>(points),\n    [<span class=\"hljs-string\">'Z'</span>],\n  ];\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/primitive.js</span>\n\n<span class=\"hljs-keyword\">import</span> { area <span class=\"hljs-keyword\">as</span> pathArea, line <span class=\"hljs-keyword\">as</span> pathLine } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./d'</span>;\n\n<span class=\"hljs-comment\">// 绘制等高线</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">contour</span>(<span class=\"hljs-params\">renderer, { points, ...styles }</span>) {\n  <span class=\"hljs-keyword\">const</span> end = points.<span class=\"hljs-property\">length</span>;\n  <span class=\"hljs-keyword\">const</span> mid = end / <span class=\"hljs-number\">2</span>;\n  <span class=\"hljs-comment\">// 用一条 path 绘制等高线本身</span>\n  <span class=\"hljs-keyword\">const</span> contour = renderer.<span class=\"hljs-title function_\">path</span>({ <span class=\"hljs-attr\">d</span>: <span class=\"hljs-title function_\">pathArea</span>(points), ...styles, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'none'</span> });\n  <span class=\"hljs-comment\">// 用一条 path 绘制外边框</span>\n  <span class=\"hljs-keyword\">const</span> outerStroke = renderer.<span class=\"hljs-title function_\">path</span>({ <span class=\"hljs-attr\">d</span>: <span class=\"hljs-title function_\">pathLine</span>(points.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>, mid)), ...styles, <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'none'</span> });\n  <span class=\"hljs-comment\">// 用一条 path 绘制内边框</span>\n  <span class=\"hljs-keyword\">const</span> innerStroke = renderer.<span class=\"hljs-title function_\">path</span>({ <span class=\"hljs-attr\">d</span>: <span class=\"hljs-title function_\">pathLine</span>(points.<span class=\"hljs-title function_\">slice</span>(mid, end)), ...styles, <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'none'</span> });\n  <span class=\"hljs-keyword\">return</span> [innerStroke, contour, outerStroke];\n}\n</code></pre>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64fd3b40f2b04e04aa10cf5a90c1b800~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>最后运行<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fgeometry%2Farea.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/area.spec.js\" ref=\"nofollow noopener noreferrer\">测试代码</a>会有以下的结果。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b08ff93df704468faf20c76a21c68459~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-8\">矩形（Rect）</h2>\n<p>接下来我们来看矩形（Rect），矩型最常见的用法就是矩阵树图。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/920942cd6e694632856c1589c37d5194~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>矩形除了拥有基本的通道之外，还应该如下图拥有 x1 和  这个两个额外的通道。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3421620cafc4e5d8a1e6bbeb59e905d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/rect.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createChannel, createChannels } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./channel'</span>;\n<span class=\"hljs-keyword\">import</span> { createGeometry } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./geometry'</span>;\n<span class=\"hljs-keyword\">import</span> { rect <span class=\"hljs-keyword\">as</span> shapeRect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./shape'</span>;\n<span class=\"hljs-keyword\">import</span> { channelStyles } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./style'</span>;\n\n<span class=\"hljs-keyword\">const</span> channels = <span class=\"hljs-title function_\">createChannels</span>({\n  <span class=\"hljs-attr\">x1</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'x1'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }),\n  <span class=\"hljs-attr\">y1</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'y1'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }),\n});\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">renderer, I, scales, values, directStyles, coordinate</span>) {\n  <span class=\"hljs-keyword\">const</span> defaults = {};\n  <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">x</span>: X, <span class=\"hljs-attr\">y</span>: Y, <span class=\"hljs-attr\">x1</span>: <span class=\"hljs-variable constant_\">X1</span>, <span class=\"hljs-attr\">y1</span>: <span class=\"hljs-variable constant_\">Y1</span> } = values;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(I, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> <span class=\"hljs-title function_\">shapeRect</span>(renderer, coordinate, {\n    ...defaults,\n    ...directStyles,\n    ...<span class=\"hljs-title function_\">channelStyles</span>(i, values),\n    <span class=\"hljs-attr\">x1</span>: X[i],\n    <span class=\"hljs-attr\">y1</span>: Y[i],\n    <span class=\"hljs-attr\">x2</span>: <span class=\"hljs-variable constant_\">X1</span>[i],\n    <span class=\"hljs-attr\">y2</span>: <span class=\"hljs-variable constant_\">Y1</span>[i],\n  }));\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> rect = <span class=\"hljs-title function_\">createGeometry</span>(channels, render);\n</code></pre>\n<p>每一个矩形的绘制可以说是本章最复杂的部分，因为在不同的坐标系下矩形的形状是不同的。假如我们用矩形的四个顶点(p0, p1, p2, p3)去描述它，那在不同坐标系下它的展示方式如下。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa28840636ed49d3bb62d64e70329e67~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>同时如果坐标系发生了转置，我们需要改变顶点的顺序。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cfdb63dd161d4cc7a5ab5eae763d0a84~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/shape.js</span>\n\n<span class=\"hljs-keyword\">import</span> { dist, sub, equal } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n<span class=\"hljs-keyword\">import</span> { ring } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./primitive'</span>;\n<span class=\"hljs-keyword\">import</span> { sector <span class=\"hljs-keyword\">as</span> pathSector } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./d'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">rect</span>(<span class=\"hljs-params\">renderer, coordinate, { x1, y1, x2, y2, ...styles }</span>) {\n  <span class=\"hljs-keyword\">const</span> v0 = [x1, y1];\n  <span class=\"hljs-keyword\">const</span> v1 = [x2, y1];\n  <span class=\"hljs-keyword\">const</span> v2 = [x2, y2];\n  <span class=\"hljs-keyword\">const</span> v3 = [x1, y2];\n  \n  <span class=\"hljs-comment\">// 如果坐标系转置了，改变顶点的顺序</span>\n  <span class=\"hljs-keyword\">const</span> vs = coordinate.<span class=\"hljs-title function_\">isTranspose</span>() ? [v3, v0, v1, v2] : [v0, v1, v2, v3];\n  <span class=\"hljs-keyword\">const</span> ps = vs.<span class=\"hljs-title function_\">map</span>(coordinate);\n  <span class=\"hljs-keyword\">const</span> [p0, p1, p2, p3] = ps;\n\n  <span class=\"hljs-comment\">// 笛卡尔坐标系绘制矩形</span>\n  <span class=\"hljs-keyword\">if</span> (!coordinate.<span class=\"hljs-title function_\">isPolar</span>()) {\n    <span class=\"hljs-keyword\">const</span> [width, height] = <span class=\"hljs-title function_\">sub</span>(p2, p0);\n    <span class=\"hljs-keyword\">const</span> [x, y] = p0;\n    <span class=\"hljs-keyword\">return</span> renderer.<span class=\"hljs-title function_\">rect</span>({ x, y, width, height, ...styles });\n  }\n\n  <span class=\"hljs-comment\">// 获得圆心的位置</span>\n  <span class=\"hljs-keyword\">const</span> center = coordinate.<span class=\"hljs-title function_\">center</span>();\n  <span class=\"hljs-keyword\">const</span> [cx, cy] = center;\n\n  <span class=\"hljs-comment\">// 如果角度小于360度</span>\n  <span class=\"hljs-comment\">// 判断的方法是顶点是否重合</span>\n  <span class=\"hljs-comment\">// 绘制扇形</span>\n  <span class=\"hljs-keyword\">if</span> (!(<span class=\"hljs-title function_\">equal</span>(p0, p1) &amp;&amp; <span class=\"hljs-title function_\">equal</span>(p2, p3))) {\n    <span class=\"hljs-keyword\">return</span> renderer.<span class=\"hljs-title function_\">path</span>({ <span class=\"hljs-attr\">d</span>: <span class=\"hljs-title function_\">pathSector</span>([center, ...ps]), ...styles });\n  }\n\n  <span class=\"hljs-comment\">// 如果角度等于360度，绘制圆环</span>\n  <span class=\"hljs-keyword\">const</span> r1 = <span class=\"hljs-title function_\">dist</span>(center, p2); <span class=\"hljs-comment\">// 内半径</span>\n  <span class=\"hljs-keyword\">const</span> r2 = <span class=\"hljs-title function_\">dist</span>(center, p0); <span class=\"hljs-comment\">// 外半径</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">ring</span>(renderer, { cx, cy, r1, r2, ...styles });\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/d.js</span>\n\n<span class=\"hljs-keyword\">import</span> { dist, angleBetween, sub } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-comment\">// 生成绘制扇形的路径</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sector</span>(<span class=\"hljs-params\">[c, p0, p1, p2, p3]</span>) {\n  <span class=\"hljs-keyword\">const</span> r = <span class=\"hljs-title function_\">dist</span>(c, p0);\n  <span class=\"hljs-keyword\">const</span> r1 = <span class=\"hljs-title function_\">dist</span>(c, p2);\n  <span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-title function_\">angleBetween</span>(<span class=\"hljs-title function_\">sub</span>(p0, c), <span class=\"hljs-title function_\">sub</span>(p1, c));\n  <span class=\"hljs-keyword\">const</span> l = a &gt; <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">const</span> l1 = a &gt; <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">return</span> [\n    [<span class=\"hljs-string\">'M'</span>, p0[<span class=\"hljs-number\">0</span>], p0[<span class=\"hljs-number\">1</span>]],\n    [<span class=\"hljs-string\">'A'</span>, r, r, <span class=\"hljs-number\">0</span>, l, <span class=\"hljs-number\">1</span>, p1[<span class=\"hljs-number\">0</span>], p1[<span class=\"hljs-number\">1</span>]],\n    [<span class=\"hljs-string\">'L'</span>, p2[<span class=\"hljs-number\">0</span>], p2[<span class=\"hljs-number\">1</span>]],\n    [<span class=\"hljs-string\">'A'</span>, r1, r1, <span class=\"hljs-number\">0</span>, l1, <span class=\"hljs-number\">0</span>, p3[<span class=\"hljs-number\">0</span>], p3[<span class=\"hljs-number\">1</span>]],\n    [<span class=\"hljs-string\">'Z'</span>],\n  ];\n}\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1d2af96904b4ee78693110d02f5fd4c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/primitive.js</span>\n\n<span class=\"hljs-keyword\">import</span> { ring <span class=\"hljs-keyword\">as</span> pathRing } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./d'</span>;\n\n<span class=\"hljs-comment\">// 绘制圆环</span>\n<span class=\"hljs-comment\">// 绘制圆环的能力从渲染引擎里面移出了</span>\n<span class=\"hljs-comment\">// 为了更好的扩展性，直接在这里绘制即可</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ring</span>(<span class=\"hljs-params\">renderer, { cx, cy, r1, r2, ...styles }</span>) {\n  <span class=\"hljs-comment\">// 用一个路径去绘制圆环本身</span>\n  <span class=\"hljs-keyword\">const</span> ring = renderer.<span class=\"hljs-title function_\">path</span>({ ...styles, <span class=\"hljs-attr\">d</span>: <span class=\"hljs-title function_\">pathRing</span>([[cx, cy], [r1, r2]]), <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'none'</span> });\n  <span class=\"hljs-comment\">// 分别用两个圆去绘制圆环的边框</span>\n  <span class=\"hljs-keyword\">const</span> innerStroke = renderer.<span class=\"hljs-title function_\">circle</span>({ ...styles, <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'none'</span>, <span class=\"hljs-attr\">r</span>: r1, cx, cy });\n  <span class=\"hljs-keyword\">const</span> outerStroke = renderer.<span class=\"hljs-title function_\">circle</span>({ ...styles, <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'none'</span>, <span class=\"hljs-attr\">r</span>: r2, cx, cy });\n  <span class=\"hljs-keyword\">return</span> [innerStroke, ring, outerStroke];\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/d.js</span>\n\n<span class=\"hljs-comment\">// 生成绘制圆环的路径</span>\n<span class=\"hljs-comment\">// 用两个扇形来模拟</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ring</span>(<span class=\"hljs-params\">[c, [r1, r2]]</span>) {\n  <span class=\"hljs-keyword\">const</span> [cx, cy] = c;\n  <span class=\"hljs-keyword\">const</span> p0 = [cx, cy - r2];\n  <span class=\"hljs-keyword\">const</span> p1 = [cx, cy + r2];\n  <span class=\"hljs-keyword\">const</span> p2 = [cx, cy + r1];\n  <span class=\"hljs-keyword\">const</span> p3 = [cx, cy - r1];\n  <span class=\"hljs-keyword\">return</span> [\n    ...<span class=\"hljs-title function_\">sector</span>([c, p0, p1, p2, p3]),\n    ...<span class=\"hljs-title function_\">sector</span>([c, p1, p0, p3, p2]),\n  ];\n}\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92ca71d712c7459e8bf6db1d972fe3db~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/utils/vector.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">equal</span>(<span class=\"hljs-params\">[x0, y0], [x1, y1]</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">closeTo</span>(x0, x1) &amp;&amp; <span class=\"hljs-title function_\">closeTo</span>(y0, y1);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">closeTo</span>(<span class=\"hljs-params\">x, y, tol = <span class=\"hljs-number\">1e-5</span></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">abs</span>(x - y) &lt; tol;\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">dist</span>(<span class=\"hljs-params\">[x0, y0], [x1 = <span class=\"hljs-number\">0</span>, y1 = <span class=\"hljs-number\">0</span>] = []</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">sqrt</span>((x0 - x1) ** <span class=\"hljs-number\">2</span> + (y0 - y1) ** <span class=\"hljs-number\">2</span>);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sub</span>(<span class=\"hljs-params\">[x1, y1], [x0, y0]</span>) {\n  <span class=\"hljs-keyword\">return</span> [x1 - x0, y1 - y0];\n}\n\n<span class=\"hljs-comment\">// 计算两个向量之间的夹角</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">angleBetween</span>(<span class=\"hljs-params\">v0, v1</span>) {\n  <span class=\"hljs-keyword\">const</span> a0 = <span class=\"hljs-title function_\">angle</span>(v0);\n  <span class=\"hljs-keyword\">const</span> a1 = <span class=\"hljs-title function_\">angle</span>(v1);\n  <span class=\"hljs-keyword\">if</span> (a0 &lt; a1) <span class=\"hljs-keyword\">return</span> a1 - a0;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span> - (a0 - a1);\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">angle</span>(<span class=\"hljs-params\">[x, y]</span>) {\n  <span class=\"hljs-keyword\">const</span> theta = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">atan2</span>(y, x);\n  <span class=\"hljs-keyword\">return</span> theta;\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/utils/index.js</span>\n\n<span class=\"hljs-keyword\">export</span> * <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./vector'</span>;\n</code></pre>\n<p>最后运行<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fgeometry%2Frect.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/rect.spec.js\" ref=\"nofollow noopener noreferrer\">测试代码</a>会有以下的结果。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4abdc8b703874602a21c0c74dab5921f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-9\">格子（Cell）</h2>\n<p>格子（Cell）和矩形的形状都是一样的，不同的是格子没有 x1 和 x2 两个通道，它的 x1 和 x2 这个属性不是通过通道得到的，而是通过比例尺计算出来的。</p>\n<p>下面我们用格子常被用于的热力图来举例子。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/476ea2b31b104257876c32b6e6e9a49a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>上面的中每一个格子的 x 和 y 两个通道是由数据本身决定的，但是宽度和高度是分别是由水平方向和竖直方向格子的数量来决定的，而这个过程是通过 band 比例尺计算而得的。我们用竖直方向举例子。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { createBand } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./scale'</span>;\n\n<span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-title function_\">createBand</span>({\n <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-string\">'Friday'</span>, <span class=\"hljs-string\">'Thursday'</span>, <span class=\"hljs-string\">'Wednesday'</span>, <span class=\"hljs-string\">'Tuesday'</span>, <span class=\"hljs-string\">'Monday'</span>],\n <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>]\n});\n\n<span class=\"hljs-keyword\">const</span> y = <span class=\"hljs-comment\">/* ... */</span>;\n<span class=\"hljs-keyword\">const</span> width = y.<span class=\"hljs-title function_\">bandWidth</span>();\n<span class=\"hljs-keyword\">const</span> y1 = y + width;\n</code></pre>\n<p>所以对于格子来说，它 x 和 y 通道的比例尺必须是 band 比例尺，它的实现如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/geometry/cell.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createChannels, createChannel } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./channel'</span>;\n<span class=\"hljs-keyword\">import</span> { createGeometry } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./geometry'</span>;\n<span class=\"hljs-keyword\">import</span> { rect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./shape'</span>;\n<span class=\"hljs-keyword\">import</span> { channelStyles } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./style'</span>;\n\n<span class=\"hljs-keyword\">const</span> channels = <span class=\"hljs-title function_\">createChannels</span>({\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'x'</span>, <span class=\"hljs-attr\">scale</span>: <span class=\"hljs-string\">'band'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }),\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'y'</span>, <span class=\"hljs-attr\">scale</span>: <span class=\"hljs-string\">'band'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }),\n});\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">renderer, I, scales, values, directStyles, coordinate</span>) {\n  <span class=\"hljs-keyword\">const</span> defaults = {};\n  <span class=\"hljs-keyword\">const</span> { x, y } = scales;\n  <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">x</span>: X, <span class=\"hljs-attr\">y</span>: Y } = values;\n  <span class=\"hljs-keyword\">const</span> width = x.<span class=\"hljs-title function_\">bandWidth</span>();\n  <span class=\"hljs-keyword\">const</span> height = y.<span class=\"hljs-title function_\">bandWidth</span>();\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(I, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> <span class=\"hljs-title function_\">rect</span>(renderer, coordinate, {\n    ...defaults,\n    ...directStyles,\n    ...<span class=\"hljs-title function_\">channelStyles</span>(i, values),\n    <span class=\"hljs-attr\">x1</span>: X[i],\n    <span class=\"hljs-attr\">y1</span>: Y[i],\n    <span class=\"hljs-attr\">x2</span>: X[i] + width,\n    <span class=\"hljs-attr\">y2</span>: Y[i] + height,\n  }));\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> cell = <span class=\"hljs-title function_\">createGeometry</span>(channels, render);\n</code></pre>\n<p>最后运行<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fgeometry%2Fcell.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/cell.spec.js\" ref=\"nofollow noopener noreferrer\">测试代码</a>会有以下的结果。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86df8f3edb394fc286877fa3e3aa855e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-10\">间隔（Interval）</h2>\n<p>最后来看看间隔（Interval），间隔一种很强大的几何图形，用它可以绘制出很多图表：条形图，柱状图，玫瑰图，甜甜圈，饼图，瀑布图等等。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8844fa18b7647c3a2c884741c3a5d4d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>间隔和格子有会有点不同，间隔还需要额外的 y1 通道，用来确定矩形的高度。它的宽度同样还是根据 x 通道绑定的 band 比例尺来实现。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0e4660726d444a2b2b96c28124fa933~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>这里需要注意的是间隔还有额外的 z 通道，这点和线、区域是一样的，都是用来分组的。不同的是，这里的 z 通道会绑定一个 band 比例尺，计算间隔在组内的偏移。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2263ed64965348d894a88f1ca44d61ca~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { createChannel, createChannels } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./channel'</span>;\n<span class=\"hljs-keyword\">import</span> { channelStyles } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./style'</span>;\n<span class=\"hljs-keyword\">import</span> { rect } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./shape'</span>;\n<span class=\"hljs-keyword\">import</span> { createGeometry } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./geometry'</span>;\n\n<span class=\"hljs-keyword\">const</span> channels = <span class=\"hljs-title function_\">createChannels</span>({\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'x'</span>, <span class=\"hljs-attr\">scale</span>: <span class=\"hljs-string\">'band'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }),\n  <span class=\"hljs-attr\">z</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'z'</span>, <span class=\"hljs-attr\">scale</span>: <span class=\"hljs-string\">'band'</span> }),\n  <span class=\"hljs-attr\">y1</span>: <span class=\"hljs-title function_\">createChannel</span>({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'y1'</span>, <span class=\"hljs-attr\">optional</span>: <span class=\"hljs-literal\">false</span> }),\n});\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\">renderer, I, scales, values, directStyles, coordinate</span>) {\n  <span class=\"hljs-keyword\">const</span> defaults = {\n    <span class=\"hljs-attr\">z</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>,\n  };\n  <span class=\"hljs-keyword\">const</span> { x, z } = scales;\n  <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">x</span>: X, <span class=\"hljs-attr\">y</span>: Y, <span class=\"hljs-attr\">y1</span>: <span class=\"hljs-variable constant_\">Y1</span>, <span class=\"hljs-attr\">z</span>: Z = [] } = values;\n  <span class=\"hljs-keyword\">const</span> groupWidth = x.<span class=\"hljs-title function_\">bandWidth</span>();\n  <span class=\"hljs-keyword\">const</span> intervalWidth = z ? z.<span class=\"hljs-title function_\">bandWidth</span>() : <span class=\"hljs-number\">1</span>;\n  <span class=\"hljs-keyword\">const</span> width = groupWidth * intervalWidth;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(I, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">z</span>: dz, <span class=\"hljs-attr\">x</span>: dx, ...restDefaults } = defaults;\n    <span class=\"hljs-keyword\">const</span> offset = (Z[i] || dz) * groupWidth; <span class=\"hljs-comment\">// 计算偏移</span>\n    <span class=\"hljs-keyword\">const</span> x1 = (X[i] || dx) + offset;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">rect</span>(renderer, coordinate, {\n      ...restDefaults,\n      ...directStyles,\n      ...<span class=\"hljs-title function_\">channelStyles</span>(i, values),\n      x1,\n      <span class=\"hljs-attr\">y1</span>: Y[i],\n      <span class=\"hljs-attr\">x2</span>: x1 + width,\n      <span class=\"hljs-attr\">y2</span>: <span class=\"hljs-variable constant_\">Y1</span>[i],\n    });\n  });\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> interval = <span class=\"hljs-title function_\">createGeometry</span>(channels, render);\n</code></pre>\n<p>最后运行<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fgeometry%2Finterval.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/interval.spec.js\" ref=\"nofollow noopener noreferrer\">测试代码</a>会有以下的结果。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a955edf23a1c4a1cb578a1a95364ca41~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-11\">作业</h2>\n<p>又到了给大家布置小作业的时间了，这里大家可以尝试实现一下路径（Path）这个几何图形。它主要有三个通道如下表。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>通道名</th><th>描述</th><th>可选</th><th>默认值</th></tr></thead><tbody><tr><td>d</td><td>路径字符串或者数组</td><td>否</td><td>-</td></tr><tr><td>fill</td><td>填充颜色</td><td>否</td><td>-</td></tr><tr><td>stroke</td><td>边框颜色</td><td>是</td><td>-</td></tr></tbody></table>\n<p>它主要用来绘制自定义的图形，比如地图等。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> index = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>];\n\n<span class=\"hljs-keyword\">const</span> values =  {\n    <span class=\"hljs-attr\">fill</span>: [<span class=\"hljs-string\">'#5B8FF9'</span>, <span class=\"hljs-string\">'#5AD8A6'</span>],\n    <span class=\"hljs-attr\">d</span>: [ \n      <span class=\"hljs-string\">'M 10 10 L 10 200 L 200 200 Z'</span>,\n      [\n        [<span class=\"hljs-string\">'M'</span>, <span class=\"hljs-number\">250</span>, <span class=\"hljs-number\">250</span>],\n        [<span class=\"hljs-string\">'L'</span>, <span class=\"hljs-number\">250</span>, <span class=\"hljs-number\">300</span>],\n        [<span class=\"hljs-string\">'L'</span>, <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">300</span>],\n        [<span class=\"hljs-string\">'Z'</span>],\n      ],\n    ],\n};\n\n<span class=\"hljs-title function_\">path</span>(renderer, index, scales, values, coordinate);\n</code></pre>\n<p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fgeometry%2Fpath.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/geometry/path.spec.js\" ref=\"nofollow noopener noreferrer\">上面的代码</a>可以绘制出以下的效果。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f11f4cfb7e94c8daf526941e1359a2e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>具体的实现可以参考<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2Fsrc%2Fgeometry%2Fpath.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/src/geometry/path.js\" ref=\"nofollow noopener noreferrer\">这里</a>。</p>\n<h2 data-id=\"heading-12\">小结</h2>\n<p>这一章就到这里结束了。我们从认识几何图形和通道开始，知道了几何图形通过通道来控制它的外观，然后了解一些基本的通道和分类的方法。这之后认识并且实现了几种常用的几何图形，并且知道了它们的用途。</p>\n<p>也许大家现在还对很多东西比较模糊，不用着急，我们在后面的章节会有很多和几何图形以及通道接触的机会，越到后面大家对它们的理解会更加深刻。</p>\n<p>最后这里为下一章做一下预告，下一章我们将进入辅助组件（Guide），看看它们是如何加快我们理解几何图形的速度的。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82543b7a6f47417b85b7ce9de2b93118~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "10\n实战：辅助组件 - Guide\n学习时长: 54分58秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>在上一章几何图形（Geometry）结束以后，我们已经可以根据数据绘制出如下简单的图形元素了。虽然目前通过下面这些图我们已经能获得一些基本的信息，但是这些信息还不够明确。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a955edf23a1c4a1cb578a1a95364ca41~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>比如：在上面的第一个柱形图中蓝色的条对应柱子最矮，说明其对应的数据实体的某个属性最小，但具体是哪个数据实体的哪个属性、这个属性的值又具体是多少，这些信息我们就不知道了。</p>\n<p>所以我们除了基本的几何图形之外，还需要一些基本的辅助组件（Guide）来帮助我们理解图表，获取更多的信息，比如坐标轴（Axis），图例（Legend）和标注（Annotation）。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82543b7a6f47417b85b7ce9de2b93118~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>那么接下来我们将从辅助组件理论讲起，然后深入了解并且实现坐标轴和图例，最后在小结部分简单介绍一下标注。</p>\n<h2 data-id=\"heading-0\">辅助组件理论（Guide）</h2>\n<p>辅助组件理论这部分主要介绍坐标轴和图例，理解它们的核心在于理解：<strong>如果几何元素是对数据本身的可视化，那么坐标轴和图例就是对比例尺的可视化。</strong></p>\n<p>对于每一个比例尺来说，它的辅助组件是坐标轴还是图例，取决于和比例尺绑定的视觉通道。而具体的坐标轴和图例的类型取决于比例尺的种类。</p>\n<p>当一个比例尺和水平位置通道 x 或者和竖直位置通道 y 绑定的时候，那么它的辅助组件就是坐标轴。</p>\n<p>比如下图中 x 通道绑定的 Band 比例尺对应底部的坐标轴，这种坐标轴是水平坐标轴（AxisX）。 y 通道绑定的 Linear 比例尺对应是左边坐标轴，这种坐标轴就是竖直坐标轴（AxisY）。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e131da6f9e344dd385c2bced026b1995~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>如果是在极坐标系下，那么两种比例尺的展现又会有所不同。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7f0135b47bf4134b57765c8f5cf8bda~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>当一个比例尺和颜色，形状这些非位置通道绑定的时候，它对应的辅助组件就是图例。比如下图中颜色通道绑定的 Oridnal 比例尺对应底部的图例，因为 Ordinal 是离散的比例尺，所以对应的是样品图例（LegendSwatches）。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31f1e324c16d4ce1b60a5f308139c1e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>当然如果这个颜色通道对应的是连续形比例尺的话，那么这个比例尺就是坡道图例（LegendRamp）。比如下面的颜色通道用的是 Linear 比例尺，所以对应的图例就是一个坡道图例。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5762dd0a684e44738365037b971b0793~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>简单了解了一下坐标轴和比例尺，那么接下来就进入我们的开发环节。</p>\n<h2 data-id=\"heading-1\">坐标轴（Axis）</h2>\n<p>首先我们来看一看坐标轴的绘制。不管对应什么比例尺，一个比较完整的坐标轴会包含下面三个部分：刻度、标签和格子。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0b7405e6b0045f4acfd9ab64295242c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p><strong>刻度</strong>是由比例尺的 ticks 方法或者定义域决定的。如果是连续比例尺（Linear，Log 和 Time 等），它们的刻度就是 ticks 方法返回的值。如果是离散比例尺（Ordianl 和 Point 等），它们的刻度就是定义域本身。</p>\n<p>比如下图中底部的坐标轴的刻度就是对应 Band 比例尺的定义域：<code>['1991', '1992', '1993', ...]</code>，而左边的坐标轴的刻度就是对应的 Linear 比例尺在 <code>[0, 13]</code> 这个范围内生成的 ticks。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e131da6f9e344dd385c2bced026b1995~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p><strong>格子</strong>是根据刻度生成，每一个刻度都会生成一条线，根据坐标系的不同，这条线可能是直线，也可能是曲线。</p>\n<p><strong>标签</strong>的位置一般由第一个或者最后一个刻度决定，它主要用于说明当前比例尺绑定的数据的对应属性。</p>\n<p>在不同的坐标系下 AxisX 和 AxisY 的展现形式不同，根据是否是极坐标（isPolar）以及是否转置坐标系（isTranspose），可以将它们分别分为四种类型：</p>\n<ul>\n<li><code>(isPolar: false, isTranspose: false)</code></li>\n<li><code>(isPolar: false, isTranspose: true)</code></li>\n<li><code>(isPolar: true, isTranspose: true)</code></li>\n<li><code>(isPolar: true, isTranspose: false)</code></li>\n</ul>\n<p>如果上面的四种类型分别用 <code>00</code>、 <code>01</code>、 <code>11</code>、 <code>10</code> 来表示，那么 axisX 在不同坐标系的展示如下。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f9c55dfd314fe883f2a8f28222d5e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>axisY 在不同坐标系的展示如下。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/630398aa27e84a10ade6a3af58152170~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>了解了坐标轴的不同样子，接下来我们首先抽象出一个创建坐标轴的函数：<code>createAxis</code>。该函数会返回一个绘制坐标轴的函数，它根据当前的坐标系选择不同的刻度、标签和格子绘制函数，从而绘制整个坐标轴。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/guide/axis.js</span>\n\n<span class=\"hljs-keyword\">import</span> { identity } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-comment\">// components 不同坐标系对应的绘制组件</span>\n<span class=\"hljs-comment\">// labelOf 获取标签绘制需要的刻度</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createAxis</span>(<span class=\"hljs-params\">components, labelOf</span>) {\n  <span class=\"hljs-comment\">// renderer 渲染器</span>\n  <span class=\"hljs-comment\">// scale 比例尺</span>\n  <span class=\"hljs-comment\">// cooridante 坐标系</span>\n  <span class=\"hljs-comment\">// domain 比例尺的定义域（对离散比例尺有用）</span>\n  <span class=\"hljs-comment\">// label 绘制的标签内容</span>\n  <span class=\"hljs-comment\">// tickCount 刻度数量（对连续比例尺有用）</span>\n  <span class=\"hljs-comment\">// formatter 格式化刻度的函数</span>\n  <span class=\"hljs-comment\">// tickLength 刻度的长度</span>\n  <span class=\"hljs-comment\">// fontSize 刻度文本和标签的字号</span>\n  <span class=\"hljs-comment\">// grid 是否绘制格子</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">renderer, scale, coordinate, {\n    domain, \n    label,\n    tickCount = <span class=\"hljs-number\">5</span>, \n    formatter = identity,\n    tickLength = <span class=\"hljs-number\">5</span>,\n    fontSize = <span class=\"hljs-number\">12</span>,\n    grid = <span class=\"hljs-literal\">false</span>,\n    tick = <span class=\"hljs-literal\">true</span>,\n  }</span>) =&gt;</span> {\n    <span class=\"hljs-comment\">// 获得 ticks 的值</span>\n    <span class=\"hljs-keyword\">const</span> offset = scale.<span class=\"hljs-property\">bandWidth</span> ? scale.<span class=\"hljs-title function_\">bandWidth</span>() / <span class=\"hljs-number\">2</span> : <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">const</span> values = scale.<span class=\"hljs-property\">ticks</span> ? scale.<span class=\"hljs-title function_\">ticks</span>(tickCount) : domain;\n\n    <span class=\"hljs-comment\">// 处理一些绘制需要的属性</span>\n    <span class=\"hljs-keyword\">const</span> center = coordinate.<span class=\"hljs-title function_\">center</span>();\n    <span class=\"hljs-comment\">// 转换成 00、01、11、10</span>\n    <span class=\"hljs-keyword\">const</span> type = <span class=\"hljs-string\">`<span class=\"hljs-subst\">${+coordinate.isPolar()}</span><span class=\"hljs-subst\">${+coordinate.isTranspose()}</span>`</span>;\n    <span class=\"hljs-keyword\">const</span> options = { tickLength, fontSize, center };\n    \n    <span class=\"hljs-comment\">// 根据当前坐标系种类选择对应的绘制格子、刻度和标签的方法</span>\n    <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">grid</span>: <span class=\"hljs-title class_\">Grid</span>, <span class=\"hljs-attr\">ticks</span>: <span class=\"hljs-title class_\">Ticks</span>, <span class=\"hljs-attr\">label</span>: <span class=\"hljs-title class_\">Label</span>, start, end } = components[type];\n    \n    <span class=\"hljs-comment\">// 计算得到刻度真正的坐标和展示的文本</span>\n    <span class=\"hljs-keyword\">const</span> ticks = values.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> [x, y] = <span class=\"hljs-title function_\">coordinate</span>(<span class=\"hljs-title function_\">start</span>(d, scale, offset));\n      <span class=\"hljs-keyword\">const</span> text = <span class=\"hljs-title function_\">formatter</span>(d);\n      <span class=\"hljs-keyword\">return</span> { x, y, text };\n    });\n\n    <span class=\"hljs-comment\">// 按需绘制格子、刻度和标签</span>\n    <span class=\"hljs-keyword\">if</span> (grid &amp;&amp; <span class=\"hljs-title class_\">Grid</span>) <span class=\"hljs-title class_\">Grid</span>(renderer, ticks, <span class=\"hljs-title function_\">end</span>(coordinate));\n    <span class=\"hljs-keyword\">if</span> (tick &amp;&amp; <span class=\"hljs-title class_\">Ticks</span>) <span class=\"hljs-title class_\">Ticks</span>(renderer, ticks, options);\n    <span class=\"hljs-keyword\">if</span> (label &amp;&amp; <span class=\"hljs-title class_\">Label</span>) <span class=\"hljs-title class_\">Label</span>(renderer, label, <span class=\"hljs-title function_\">labelOf</span>(ticks), options);\n  };\n}\n</code></pre>\n<p>通过 <code>createAxis</code> 函数我们可以看见刻度、格子和标签绘制组件是如何组合使用的，那么接下来我们就分别看看它们的实现。</p>\n<h3 data-id=\"heading-2\">刻度（Ticks）</h3>\n<p>在笛卡尔坐标系下我们主要会绘制三种刻度：<code>ticksBottom</code>、<code>ticksTop</code> 和 <code>ticksLeft</code>，它们的区别在于刻度线的方向以及刻度线和刻度文本的相对位置不同。</p>\n<p>在极坐标系下绘制刻度的重点主要有两个：</p>\n<ul>\n<li>旋转刻度使得刻度线指向圆心。</li>\n<li>旋转刻度文本使得文本不颠倒。</li>\n</ul>\n<p>具体的实现如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/guide/ticks.js</span>\n\n<span class=\"hljs-keyword\">import</span> { rotationOf, unique } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./utils'</span>;\n<span class=\"hljs-keyword\">import</span> { degree } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ticksBottom</span>(<span class=\"hljs-params\">renderer, ticks, { tickLength, fontSize }</span>) {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> { x, y, text } <span class=\"hljs-keyword\">of</span> ticks) {\n    <span class=\"hljs-keyword\">const</span> x2 = x;\n    <span class=\"hljs-keyword\">const</span> y2 = y + tickLength;\n    renderer.<span class=\"hljs-title function_\">line</span>({ <span class=\"hljs-attr\">x1</span>: x, <span class=\"hljs-attr\">y1</span>: y, x2, y2, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'currentColor'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'tick'</span> });\n    renderer.<span class=\"hljs-title function_\">text</span>({ text, fontSize, x, <span class=\"hljs-attr\">y</span>: y2, <span class=\"hljs-attr\">textAnchor</span>: <span class=\"hljs-string\">'middle'</span>, <span class=\"hljs-attr\">dy</span>: <span class=\"hljs-string\">'1em'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'text'</span> });\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ticksTop</span>(<span class=\"hljs-params\">renderer, ticks, { tickLength, fontSize }</span>) {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> { x, y, text } <span class=\"hljs-keyword\">of</span> ticks) {\n    <span class=\"hljs-keyword\">const</span> x2 = x;\n    <span class=\"hljs-keyword\">const</span> y2 = y - tickLength;\n    renderer.<span class=\"hljs-title function_\">line</span>({ <span class=\"hljs-attr\">x1</span>: x, <span class=\"hljs-attr\">y1</span>: y, x2, y2, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'currentColor'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'tick'</span> });\n    renderer.<span class=\"hljs-title function_\">text</span>({ text, fontSize, x, <span class=\"hljs-attr\">y</span>: y2, <span class=\"hljs-attr\">textAnchor</span>: <span class=\"hljs-string\">'middle'</span>, <span class=\"hljs-attr\">dy</span>: <span class=\"hljs-string\">'-0.3em'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'text'</span> });\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ticksLeft</span>(<span class=\"hljs-params\">renderer, ticks, { tickLength, fontSize }</span>) {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> { x, y, text } <span class=\"hljs-keyword\">of</span> ticks) {\n    <span class=\"hljs-keyword\">const</span> x2 = x - tickLength;\n    <span class=\"hljs-keyword\">const</span> y2 = y;\n    renderer.<span class=\"hljs-title function_\">line</span>({ <span class=\"hljs-attr\">x1</span>: x, <span class=\"hljs-attr\">y1</span>: y, x2, y2, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'currentColor'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'tick'</span> });\n    renderer.<span class=\"hljs-title function_\">text</span>({ text, fontSize, <span class=\"hljs-attr\">x</span>: x2, y, <span class=\"hljs-attr\">textAnchor</span>: <span class=\"hljs-string\">'end'</span>, <span class=\"hljs-attr\">dy</span>: <span class=\"hljs-string\">'0.5em'</span>, <span class=\"hljs-attr\">dx</span>: <span class=\"hljs-string\">'-0.5em'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'text'</span> });\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ticksCircular</span>(<span class=\"hljs-params\">renderer, ticks, { tickLength, fontSize, center }</span>) {\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> { x, y, text } <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title function_\">unique</span>(ticks)) {\n    <span class=\"hljs-comment\">// 计算刻度和刻度文本的旋转角度</span>\n    <span class=\"hljs-keyword\">const</span> { tickRotation, textRotation } = <span class=\"hljs-title function_\">rotationOf</span>(center, [x, y]);\n    <span class=\"hljs-keyword\">const</span> [x2, y2] = [<span class=\"hljs-number\">0</span>, tickLength];\n    <span class=\"hljs-keyword\">const</span> dy = textRotation === <span class=\"hljs-number\">0</span> ? <span class=\"hljs-string\">'1.2em'</span> : <span class=\"hljs-string\">'-0.5em'</span>;\n\n    <span class=\"hljs-comment\">// 旋转刻度</span>\n    renderer.<span class=\"hljs-title function_\">save</span>();\n    renderer.<span class=\"hljs-title function_\">translate</span>(x, y);\n    renderer.<span class=\"hljs-title function_\">rotate</span>(<span class=\"hljs-title function_\">degree</span>(tickRotation));\n\n    renderer.<span class=\"hljs-title function_\">line</span>({\n      <span class=\"hljs-attr\">x1</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y1</span>: <span class=\"hljs-number\">0</span>, x2, y2, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'currentColor'</span>, <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'currentColor'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'tick'</span>,\n    });\n\n    <span class=\"hljs-comment\">// 在旋转刻度的基础上旋转文本</span>\n    renderer.<span class=\"hljs-title function_\">save</span>();\n    renderer.<span class=\"hljs-title function_\">translate</span>(x2, y2);\n    renderer.<span class=\"hljs-title function_\">rotate</span>(<span class=\"hljs-title function_\">degree</span>(textRotation));\n\n    renderer.<span class=\"hljs-title function_\">text</span>({\n      <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${text}</span>`</span>, <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">textAnchor</span>: <span class=\"hljs-string\">'middle'</span>, fontSize, <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'currentColor'</span>, dy, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'text'</span>,\n    });\n    renderer.<span class=\"hljs-title function_\">restore</span>();\n    renderer.<span class=\"hljs-title function_\">restore</span>();\n  }\n}\n</code></pre>\n<h3 data-id=\"heading-3\">标签（Label）</h3>\n<p>标签绘制函数的实现没有太大的难点，这里就不具体介绍了。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/guide/label.js</span>\n\n<span class=\"hljs-comment\">// 当 axis 在左边，且方向向上</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">labelLeftUp</span>(<span class=\"hljs-params\">renderer, label, tick, { fontSize }</span>) {\n  <span class=\"hljs-keyword\">const</span> { x, y } = tick;\n  renderer.<span class=\"hljs-title function_\">text</span>({ <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">`↑ <span class=\"hljs-subst\">${label}</span>`</span>, x, y, fontSize, <span class=\"hljs-attr\">textAnchor</span>: <span class=\"hljs-string\">'end'</span>, <span class=\"hljs-attr\">dy</span>: <span class=\"hljs-string\">'-1em'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'label'</span> });\n}\n\n<span class=\"hljs-comment\">// 当 axis 在左边，且方向向下</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">labelLeftDown</span>(<span class=\"hljs-params\">renderer, label, tick, { fontSize }</span>) {\n  <span class=\"hljs-keyword\">const</span> { x, y } = tick;\n  renderer.<span class=\"hljs-title function_\">text</span>({ <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">`↓ <span class=\"hljs-subst\">${label}</span>`</span>, x, y, fontSize, <span class=\"hljs-attr\">textAnchor</span>: <span class=\"hljs-string\">'end'</span>, <span class=\"hljs-attr\">dy</span>: <span class=\"hljs-string\">'2em'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'label'</span> });\n}\n\n<span class=\"hljs-comment\">// 当 axis 在底部，且方向向右</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">labelBottomRight</span>(<span class=\"hljs-params\">renderer, label, tick, { fontSize, tickLength }</span>) {\n  <span class=\"hljs-keyword\">const</span> { x, y } = tick;\n  <span class=\"hljs-keyword\">const</span> ty = y + tickLength;\n  renderer.<span class=\"hljs-title function_\">text</span>({ <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${label}</span> →`</span>, x, <span class=\"hljs-attr\">y</span>: ty, fontSize, <span class=\"hljs-attr\">textAnchor</span>: <span class=\"hljs-string\">'end'</span>, <span class=\"hljs-attr\">dy</span>: <span class=\"hljs-string\">'2em'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'label'</span> });\n}\n\n<span class=\"hljs-comment\">// 当 axis 在顶部，且方向向右</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">labelTopRight</span>(<span class=\"hljs-params\">renderer, label, tick, { fontSize, tickLength }</span>) {\n  <span class=\"hljs-keyword\">const</span> { x, y } = tick;\n  <span class=\"hljs-keyword\">const</span> ty = y - tickLength;\n  renderer.<span class=\"hljs-title function_\">text</span>({ <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${label}</span> →`</span>, x, <span class=\"hljs-attr\">y</span>: ty, fontSize, <span class=\"hljs-attr\">textAnchor</span>: <span class=\"hljs-string\">'end'</span>, <span class=\"hljs-attr\">dy</span>: <span class=\"hljs-string\">'-1.2em'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'label'</span> });\n}\n</code></pre>\n<h3 data-id=\"heading-4\">网格（Grid）</h3>\n<p>网格线的绘制也没有太多的难点，具体的实现参考下面的代码。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/guide/label.js</span>\n\n<span class=\"hljs-keyword\">import</span> { dist } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-comment\">// 垂直方向的线</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">gridVertical</span>(<span class=\"hljs-params\">renderer, ticks, end</span>) {\n  <span class=\"hljs-keyword\">const</span> [, y2] = end;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> { x, y } <span class=\"hljs-keyword\">of</span> ticks) {\n    renderer.<span class=\"hljs-title function_\">line</span>({ <span class=\"hljs-attr\">x1</span>: x, <span class=\"hljs-attr\">y1</span>: y, <span class=\"hljs-attr\">x2</span>: x, y2, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'#eee'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'grid'</span> });\n  }\n}\n\n<span class=\"hljs-comment\">// 水平方向的线</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">gridHorizontal</span>(<span class=\"hljs-params\">renderer, ticks, end</span>) {\n  <span class=\"hljs-keyword\">const</span> [x2] = end;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> { x, y } <span class=\"hljs-keyword\">of</span> ticks) {\n    renderer.<span class=\"hljs-title function_\">line</span>({ <span class=\"hljs-attr\">x1</span>: x, <span class=\"hljs-attr\">y1</span>: y, x2, <span class=\"hljs-attr\">y2</span>: y, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'#eee'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'grid'</span> });\n  }\n}\n\n<span class=\"hljs-comment\">// 绘制一系列从圆心发散的直线</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">gridRay</span>(<span class=\"hljs-params\">renderer, ticks, end</span>) {\n  <span class=\"hljs-keyword\">const</span> [x2, y2] = end;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> { x, y } <span class=\"hljs-keyword\">of</span> ticks) {\n    renderer.<span class=\"hljs-title function_\">line</span>({ <span class=\"hljs-attr\">x1</span>: x, <span class=\"hljs-attr\">y1</span>: y, x2, y2, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'#eee'</span>, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'grid'</span> });\n  }\n}\n\n<span class=\"hljs-comment\">// 绘制一系列同心圆</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">gridCircular</span>(<span class=\"hljs-params\">renderer, ticks, end</span>) {\n  <span class=\"hljs-keyword\">const</span> [cx, cy] = end;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> { x, y } <span class=\"hljs-keyword\">of</span> ticks) {\n    <span class=\"hljs-keyword\">const</span> r = <span class=\"hljs-title function_\">dist</span>(end, [x, y]);\n    renderer.<span class=\"hljs-title function_\">circle</span>({ <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'none'</span>, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'#eee'</span>, cx, cy, r, <span class=\"hljs-attr\">class</span>: <span class=\"hljs-string\">'grid'</span> });\n  }\n}\n</code></pre>\n<h3 data-id=\"heading-5\">水平坐标轴（AxisX）</h3>\n<p>水平坐标轴在不同的坐标系下需要不同的绘制组件，具体如下面代码所展示的一样。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/guide/axisX.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createAxis } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./axis'</span>;\n<span class=\"hljs-keyword\">import</span> { ticksBottom, ticksLeft, ticksCircular } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./ticks'</span>;\n<span class=\"hljs-keyword\">import</span> { gridCircular, gridHorizontal, gridRay, gridVertical } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./grid'</span>;\n<span class=\"hljs-keyword\">import</span> { labelLeftDown, labelBottomRight } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./label'</span>;\n\n<span class=\"hljs-keyword\">const</span> components = {\n  <span class=\"hljs-string\">'00'</span>: {\n    <span class=\"hljs-attr\">start</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d, scale, offset</span>) =&gt;</span> [<span class=\"hljs-title function_\">scale</span>(d) + offset, <span class=\"hljs-number\">1</span>],\n    <span class=\"hljs-attr\">end</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">coordinate</span>) =&gt;</span> <span class=\"hljs-title function_\">coordinate</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>]),\n    <span class=\"hljs-attr\">grid</span>: gridVertical,\n    <span class=\"hljs-attr\">ticks</span>: ticksBottom,\n    <span class=\"hljs-attr\">label</span>: labelBottomRight,\n  },\n  <span class=\"hljs-string\">'01'</span>: {\n    <span class=\"hljs-attr\">start</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d, scale, offset</span>) =&gt;</span> [<span class=\"hljs-title function_\">scale</span>(d) + offset, <span class=\"hljs-number\">1</span>],\n    <span class=\"hljs-attr\">end</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">coordinate</span>) =&gt;</span> <span class=\"hljs-title function_\">coordinate</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>]),\n    <span class=\"hljs-attr\">grid</span>: gridHorizontal,\n    <span class=\"hljs-attr\">ticks</span>: ticksLeft,\n    <span class=\"hljs-attr\">label</span>: labelLeftDown,\n  },\n  <span class=\"hljs-number\">10</span>: {\n    <span class=\"hljs-attr\">start</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d, scale, offset</span>) =&gt;</span> [<span class=\"hljs-title function_\">scale</span>(d) + offset, <span class=\"hljs-number\">0</span>],\n    <span class=\"hljs-attr\">grid</span>: gridRay,\n    <span class=\"hljs-attr\">ticks</span>: ticksCircular,\n    <span class=\"hljs-attr\">end</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">coordinate</span>) =&gt;</span> coordinate.<span class=\"hljs-title function_\">center</span>(),\n  },\n  <span class=\"hljs-number\">11</span>: {\n    <span class=\"hljs-attr\">start</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d, scale, offset</span>) =&gt;</span> [<span class=\"hljs-title function_\">scale</span>(d) + offset, <span class=\"hljs-number\">1</span>],\n    <span class=\"hljs-attr\">grid</span>: gridCircular,\n    <span class=\"hljs-attr\">ticks</span>: ticksLeft,\n    <span class=\"hljs-attr\">end</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">coordinate</span>) =&gt;</span> coordinate.<span class=\"hljs-title function_\">center</span>(),\n  },\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> axisX = <span class=\"hljs-title function_\">createAxis</span>(components);\n</code></pre>\n<p>在不同的坐标系下，根据下面这个比例尺绘制水平坐标轴的效果如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createLinear</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>]\n});\n</code></pre>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1f9c55dfd314fe883f2a8f28222d5e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h3 data-id=\"heading-6\">竖直坐标轴（AxisY）</h3>\n<p>竖直坐标轴在不同的坐标系下同样需要不同的绘制组件，具体如下面代码所展示的一样。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/guide/axisY.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createAxis } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./axis'</span>;\n<span class=\"hljs-keyword\">import</span> { ticksTop, ticksLeft, ticksCircular } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./ticks'</span>;\n<span class=\"hljs-keyword\">import</span> { gridCircular, gridHorizontal, gridRay, gridVertical } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./grid'</span>;\n<span class=\"hljs-keyword\">import</span> { labelTopRight, labelLeftUp } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./label'</span>;\n\n<span class=\"hljs-keyword\">const</span> components = {\n  <span class=\"hljs-string\">'00'</span>: {\n    <span class=\"hljs-attr\">start</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d, scale, offset</span>) =&gt;</span> [<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_\">scale</span>(d) + offset],\n    <span class=\"hljs-attr\">end</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">coordinate</span>) =&gt;</span> <span class=\"hljs-title function_\">coordinate</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>]),\n    <span class=\"hljs-attr\">grid</span>: gridHorizontal,\n    <span class=\"hljs-attr\">ticks</span>: ticksLeft,\n    <span class=\"hljs-attr\">label</span>: labelLeftUp,\n  },\n  <span class=\"hljs-string\">'01'</span>: {\n    <span class=\"hljs-attr\">start</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d, scale, offset</span>) =&gt;</span> [<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_\">scale</span>(d) + offset],\n    <span class=\"hljs-attr\">end</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">coordinate</span>) =&gt;</span> <span class=\"hljs-title function_\">coordinate</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>]),\n    <span class=\"hljs-attr\">grid</span>: gridVertical,\n    <span class=\"hljs-attr\">ticks</span>: ticksTop,\n    <span class=\"hljs-attr\">label</span>: labelTopRight,\n  },\n  <span class=\"hljs-number\">10</span>: {\n    <span class=\"hljs-attr\">start</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d, scale, offset</span>) =&gt;</span> [<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_\">scale</span>(d) + offset],\n    <span class=\"hljs-attr\">grid</span>: gridCircular,\n    <span class=\"hljs-attr\">ticks</span>: ticksLeft,\n    <span class=\"hljs-attr\">end</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">coordinate</span>) =&gt;</span> coordinate.<span class=\"hljs-title function_\">center</span>(),\n  },\n  <span class=\"hljs-number\">11</span>: {\n    <span class=\"hljs-attr\">start</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d, scale, offset</span>) =&gt;</span> [<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_\">scale</span>(d) + offset],\n    <span class=\"hljs-attr\">grid</span>: gridRay,\n    <span class=\"hljs-attr\">ticks</span>: ticksCircular,\n    <span class=\"hljs-attr\">end</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">coordinate</span>) =&gt;</span> coordinate.<span class=\"hljs-title function_\">center</span>(),\n  },\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> axisY = <span class=\"hljs-title function_\">createAxis</span>(components);\n</code></pre>\n<p>在不同的坐标系下，根据下面这个比例尺去绘制竖直坐标轴的效果如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createLinear</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>]\n});\n</code></pre>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/630398aa27e84a10ade6a3af58152170~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-7\">图例（Legend）</h2>\n<p>了解完坐标轴的绘制，接下来我们来看看图例的绘制。图例的绘制会相对简单很多，因为绘制图例不需要考虑坐标系。但是为了保证辅助组件绘制函数接口的一致性，还是会把坐标系作为参数传入。</p>\n<h3 data-id=\"heading-8\">样品图例（LegendSwatches）</h3>\n<p>首先我们来看看样品图例，它主要针对离散比例尺，比如根据下面这个 Ordinal 比例尺来生成图例，将会得到如下图的效果。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createOrdinal</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'c'</span>],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-string\">'#5B8FF9'</span>, <span class=\"hljs-string\">'#5AD8A6'</span>, <span class=\"hljs-string\">'#5D7092'</span>],\n});\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/355b0a28f0ee480da5770e9fb2832e52~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>具体的实现如下，涉及一些简单的位置计算和图形绘制。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/guide/legendSwatches.js</span>\n\n<span class=\"hljs-keyword\">import</span> { identity } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-comment\">// marginLeft 色块和文字的距离</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">legendSwatches</span>(<span class=\"hljs-params\">renderer, scale, coordinate, {\n  x,\n  y,\n  width = <span class=\"hljs-number\">48</span>,\n  marginLeft = <span class=\"hljs-number\">12</span>,\n  swatchSize = <span class=\"hljs-number\">10</span>,\n  fontSize = <span class=\"hljs-number\">10</span>,\n  formatter = identity,\n  domain,\n  label,\n}</span>) {\n  renderer.<span class=\"hljs-title function_\">save</span>();\n  renderer.<span class=\"hljs-title function_\">translate</span>(x, y);\n\n  <span class=\"hljs-comment\">// 绘制 label</span>\n  <span class=\"hljs-keyword\">if</span> (label) {\n    renderer.<span class=\"hljs-title function_\">text</span>({ <span class=\"hljs-attr\">text</span>: label, <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">fontWeight</span>: <span class=\"hljs-string\">'bold'</span>, fontSize, <span class=\"hljs-attr\">textAnchor</span>: <span class=\"hljs-string\">'start'</span>, <span class=\"hljs-attr\">dy</span>: <span class=\"hljs-string\">'1em'</span> });\n  }\n\n  <span class=\"hljs-keyword\">const</span> legendY = label ? swatchSize * <span class=\"hljs-number\">2</span> : <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [i, label] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(domain)) {\n    <span class=\"hljs-comment\">// 绘制色块</span>\n    <span class=\"hljs-keyword\">const</span> color = <span class=\"hljs-title function_\">scale</span>(label);\n    <span class=\"hljs-keyword\">const</span> legendX = width * i;\n    renderer.<span class=\"hljs-title function_\">rect</span>({\n      <span class=\"hljs-attr\">x</span>: legendX,\n      <span class=\"hljs-attr\">y</span>: legendY,\n      <span class=\"hljs-attr\">width</span>: swatchSize,\n      <span class=\"hljs-attr\">height</span>: swatchSize,\n      <span class=\"hljs-attr\">stroke</span>: color,\n      <span class=\"hljs-attr\">fill</span>: color,\n    });\n    \n    <span class=\"hljs-comment\">// 绘制文字</span>\n    <span class=\"hljs-keyword\">const</span> textX = legendX + marginLeft + swatchSize;\n    <span class=\"hljs-keyword\">const</span> textY = legendY + swatchSize;\n    renderer.<span class=\"hljs-title function_\">text</span>({ <span class=\"hljs-attr\">text</span>: <span class=\"hljs-title function_\">formatter</span>(label), <span class=\"hljs-attr\">x</span>: textX, <span class=\"hljs-attr\">y</span>: textY, <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'currentColor'</span>, fontSize });\n  }\n  renderer.<span class=\"hljs-title function_\">restore</span>();\n}\n</code></pre>\n<h3 data-id=\"heading-9\">坡道图例（LegendRamp）</h3>\n<p>接下来是坡道图例，它主要针对连续比例尺，比如根据下面这个 Linear 比例尺来生成图例，将会得到如下图的效果。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> scale = <span class=\"hljs-title function_\">createLinear</span>({\n  <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>],\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-string\">'#5B8FF9'</span>, <span class=\"hljs-string\">'#5AD8A6'</span>],\n  <span class=\"hljs-attr\">interpolate</span>: interpolateColor,\n});\n</code></pre>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/011742ec813e4aee8d66915cd10a7779~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>具体的实现如下，这里会用一条条颜色渐变的线来实现过度效果。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/guide/legendRamp.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createLinear } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../scale'</span>;\n<span class=\"hljs-keyword\">import</span> { identity } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n<span class=\"hljs-keyword\">import</span> { ticksBottom } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./ticks'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">legendRamp</span>(<span class=\"hljs-params\">renderer, scale, coordinate, {\n  x,\n  y,\n  width = <span class=\"hljs-number\">120</span>,\n  height = <span class=\"hljs-number\">10</span>,\n  domain,\n  tickCount = <span class=\"hljs-number\">5</span>,\n  tickLength = height + <span class=\"hljs-number\">5</span>,\n  formatter = identity,\n  fontSize = <span class=\"hljs-number\">10</span>,\n  label,\n}</span>) {\n  renderer.<span class=\"hljs-title function_\">save</span>();\n  renderer.<span class=\"hljs-title function_\">translate</span>(x, y);\n\n  <span class=\"hljs-comment\">// 绘制标签</span>\n  <span class=\"hljs-keyword\">if</span> (label) {\n    renderer.<span class=\"hljs-title function_\">text</span>({ <span class=\"hljs-attr\">text</span>: label, <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">fontWeight</span>: <span class=\"hljs-string\">'bold'</span>, fontSize, <span class=\"hljs-attr\">textAnchor</span>: <span class=\"hljs-string\">'start'</span>, <span class=\"hljs-attr\">dy</span>: <span class=\"hljs-string\">'1em'</span> });\n  }\n\n  <span class=\"hljs-comment\">// 用一条条紧靠的线来实现渐变效果</span>\n  <span class=\"hljs-comment\">// 将每条线的位置 x 转换到比例尺的定义域内</span>\n  <span class=\"hljs-keyword\">const</span> value = <span class=\"hljs-title function_\">createLinear</span>({ <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, width], <span class=\"hljs-attr\">range</span>: domain });\n  <span class=\"hljs-keyword\">const</span> legendY = label ? height * <span class=\"hljs-number\">2</span> : <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; width; i += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">const</span> stroke = <span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-title function_\">value</span>(i));\n    renderer.<span class=\"hljs-title function_\">line</span>({ <span class=\"hljs-attr\">x1</span>: i, <span class=\"hljs-attr\">y1</span>: legendY, <span class=\"hljs-attr\">x2</span>: i, <span class=\"hljs-attr\">y2</span>: legendY + height, stroke });\n  }\n\n  <span class=\"hljs-comment\">// 绘制 ticks</span>\n  <span class=\"hljs-keyword\">const</span> position = <span class=\"hljs-title function_\">createLinear</span>({ domain, <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, width] });\n  <span class=\"hljs-keyword\">const</span> values = position.<span class=\"hljs-title function_\">ticks</span>(tickCount);\n  <span class=\"hljs-keyword\">const</span> ticks = values.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> ({\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-title function_\">position</span>(d),\n    <span class=\"hljs-attr\">y</span>: legendY,\n    <span class=\"hljs-attr\">text</span>: <span class=\"hljs-title function_\">formatter</span>(d),\n  }));\n  <span class=\"hljs-title function_\">ticksBottom</span>(renderer, ticks, { fontSize, tickLength });\n\n  renderer.<span class=\"hljs-title function_\">restore</span>();\n}\n\n</code></pre>\n<p>坐标轴和图例就开发完成了，完整的代码可以在<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2Fsrc%2Fguide\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/src/guide\" ref=\"nofollow noopener noreferrer\">这里</a>浏览，同样也可以通过<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fguide\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/guide\" ref=\"nofollow noopener noreferrer\">这里</a>的测试代码来验证代码的正确性。</p>\n<h2 data-id=\"heading-10\">小结</h2>\n<p>本章的主要内容就差不多这些了，这一章我们了解了辅助组件里面的坐标轴和图例，也知道了它们和比例尺之间密不可分的关系。</p>\n<p>不过辅助组件里面还有很重要的一种没有给大家详细介绍：标注（Annotation）。标注和它的名字一样，主要用于来标注一些值得注意的数据点或者数据值，比如最大值，最小值，平均值这些。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93e8119bd28e4b3f9713ebeebcf12a69~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>标注除了上图中的文字以外，还可以是线条、图片等等。这部分的内容就不再这里深入介绍了。</p>\n<p>下一章我们将进入统计（Statistic），看看它是如何改变几何图形的位置的。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d295663040f0489491795330fd713b04~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "11\n实战：统计 - Statistic\n学习时长: 56分6秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>上一章介绍了辅助组件（Guide）相关的知识，聊了坐标轴、图例的本质和绘制方法，这一章我们将简单了解一下统计函数（Statistic），看一看它是如何改变几何图形的位置的。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45199749306c4a08ac2a15ac5a137957~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>我们首先还是会从统计理论开始，然后实现几个比较常见的统计函数。接下来就让我们开始吧。</p>\n<h2 data-id=\"heading-0\">统计理论（Statistic）</h2>\n<p>在图形语法这本书中将统计定义为修改几何元素位置的函数，包括了以下这些函数。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c814d7303b804e2b9954ea93df53dc04~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>这本书里除了统计可以修改几何元素的位置，几何元素的调整（Modifier）也是可以的，比如如下的这些。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33b35615a5fc44cd8fa8d1e7bacd984c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>因为它们拥有相同的功能，所以在这里我们都有统计函数去实现它们，并且在这里都把它们称为统计函数。接下来我们将实现以下的统计函数：</p>\n<ul>\n<li>堆叠（StackY）</li>\n<li>对称（SymmetryY）</li>\n<li>归一化（NormalizeY）</li>\n<li>分箱（BinX）</li>\n</ul>\n<p>修改几何元素的位置就意味着修改或者产生位置通道的值，也就是在前面几何图形那章里面提到的 x、x1、y、y1 这些通道的值。这也是为什么上面的统计函数的名字是由 X 和 Y 结尾：X 说明该函数修改了该几何图形 x 通道的值，Y 说明该函数修改了该几何图形 x 通道的值。</p>\n<p>具体的实现我们将在接下来的部分看到。正式开始写代码之前需要说明一点的是：<strong>目前代码中各个模块下的 <code>utils.js</code> 文件的内容都统一放到了 <code>src/utils</code> 这个文件夹下。</strong></p>\n<h2 data-id=\"heading-1\">堆叠（StackY）</h2>\n<p>首先我们来看看堆叠（StackY），堆叠这个统计函数常常用于堆叠条形图和堆叠面积图。下面我们先来看一个简单的例子。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> rainfall = [\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jan.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">18.9</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Feb.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">28.8</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Mar.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">39.3</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Apr.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">81.4</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'May'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">47</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jun.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">20.3</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jul.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">24</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Aug.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">35.6</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jan.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">12.4</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Feb.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">23.2</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Mar.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">34.5</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Apr.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">99.7</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'May'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">52.6</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jun.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">35.5</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jul.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">37.4</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Aug.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">42.4</span> },\n];\n</code></pre>\n<p>当我们用条形图可视化上面的数据的时候，会得到下面的结果。这里有个奇怪的现象：条的数量和数据数量不一致！这是因为在同一月份的数量对应的条重合在一起了！</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18baba1a86dd485aa0a92e3f2f1df7e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>为了解决上面的问题，其中一种方法就是通过堆叠函数把在相同月份的条堆叠起来，得到下面的效果。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2b80a9ba7ad4aedb5f8496a4b4a0ca2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>接下来我们就从数据层面来了解一下堆叠函数的原理。这里还是说一下，统计函数处理的数据不是我们的原始表格数据，而是一个和每个通道绑定的对象，参考下面的例子。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 原始数据</span>\n<span class=\"hljs-keyword\">const</span> raw = [\n  { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">1</span> },\n  { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">2</span> },\n  { <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">3</span> }\n];\n\n<span class=\"hljs-comment\">// 和每个通道绑定的对象</span>\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">index</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>],\n  <span class=\"hljs-attr\">values</span>: {\n    <span class=\"hljs-attr\">x</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n    <span class=\"hljs-attr\">y</span>: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>],\n  },\n};\n</code></pre>\n<p>了解了统计函数的输入之后我们就来看看堆叠函数的使用方式。可以发现它把 x 属性相同的数据的 y 属性的值堆叠起来，修改了 y 的值，并且产生了一个新的 y1 通道的值。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { createStackY } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../../src/statistic'</span>;\n\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">index</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>],\n  <span class=\"hljs-attr\">values</span>: {\n    <span class=\"hljs-attr\">x</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n    <span class=\"hljs-attr\">y</span>: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>],\n  },\n};\n<span class=\"hljs-keyword\">const</span> stack = <span class=\"hljs-title function_\">createStackY</span>();\n<span class=\"hljs-title function_\">stack</span>(data);\n<span class=\"hljs-comment\">// {</span>\n<span class=\"hljs-comment\">//   index: [0, 1, 2],</span>\n<span class=\"hljs-comment\">//   values: {</span>\n<span class=\"hljs-comment\">//     x: [0, 0, 0],</span>\n<span class=\"hljs-comment\">//     y1: [0, 1, 3],</span>\n<span class=\"hljs-comment\">//     y: [1, 3, 6],</span>\n<span class=\"hljs-comment\">//   },</span>\n<span class=\"hljs-comment\">// }</span>\n</code></pre>\n<p>接下来我们就来看看具体的实现。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/statistc/stack.js</span>\n\n<span class=\"hljs-keyword\">import</span> { group } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createStackY</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">{ index, values }</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">x</span>: X, <span class=\"hljs-attr\">y</span>: Y } = values;\n    \n    <span class=\"hljs-comment\">// 根据 x 通道值分组</span>\n    <span class=\"hljs-keyword\">const</span> series = X ? <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-title function_\">group</span>(index, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> X[i]).<span class=\"hljs-title function_\">values</span>()) : [index];\n    \n    <span class=\"hljs-comment\">// 生成两个新的通道的值</span>\n    <span class=\"hljs-keyword\">const</span> newY = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(index.<span class=\"hljs-property\">length</span>);\n    <span class=\"hljs-keyword\">const</span> newY1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(index.<span class=\"hljs-property\">length</span>);\n    \n    <span class=\"hljs-comment\">// 对每个分组的 y 进行累加</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> I <span class=\"hljs-keyword\">of</span> series) {\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> py = <span class=\"hljs-number\">0</span>, i = <span class=\"hljs-number\">0</span>; i &lt; I.<span class=\"hljs-property\">length</span>; py = newY[I[i]], i += <span class=\"hljs-number\">1</span>) {\n        <span class=\"hljs-keyword\">const</span> index = I[i];\n        newY1[index] = py;\n        newY[index] = py + Y[index];\n      }\n    }\n    \n    <span class=\"hljs-keyword\">return</span> {\n      index,\n      <span class=\"hljs-comment\">// 返回修改后的 y 通道的值，并且新增一个 y1 通道</span>\n      <span class=\"hljs-attr\">values</span>: { ...values, <span class=\"hljs-attr\">y</span>: newY, <span class=\"hljs-attr\">y1</span>: newY1 },\n    };\n  };\n}\n</code></pre>\n<h2 data-id=\"heading-2\">归一化（NormalizeY）</h2>\n<p>了解了堆叠这个统计函数之后，我们再来看看归一化这个统计函数。该函数常用于百分比条形图：比如在上面的堆叠条形图的基础上使用归一化统计函数，就会得到下面的例子。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4208f5c788f646119155883f51511667~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>看完了例子，我们来看看使用方法。其实不难发现，归一化其实就是把 y 通道的值都变成了 <code>[0, 1]</code> 这个范围之内。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { createNormalizeY } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../../src/statistic'</span>;\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">index</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>],\n  <span class=\"hljs-attr\">values</span>: {\n    <span class=\"hljs-attr\">x</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>],\n    <span class=\"hljs-attr\">y1</span>: [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>],\n    <span class=\"hljs-attr\">y</span>: [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">10</span>],\n  },\n};\n<span class=\"hljs-keyword\">const</span> normalizeY = <span class=\"hljs-title function_\">createNormalizeY</span>();\n<span class=\"hljs-comment\">// {</span>\n<span class=\"hljs-comment\">//   index: [0, 1, 2],</span>\n<span class=\"hljs-comment\">//   values: {</span>\n<span class=\"hljs-comment\">//     x: [0, 1, 2],</span>\n<span class=\"hljs-comment\">//     y1: [0.2, 0.4, 0.6],</span>\n<span class=\"hljs-comment\">//     y: [1, 1, 1],</span>\n<span class=\"hljs-comment\">//   },</span>\n<span class=\"hljs-comment\">// }</span>\n</code></pre>\n<p>接下来我们就来看看具体的实现。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/statistc/normalize.js</span>\n\n<span class=\"hljs-keyword\">import</span> { group } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createNormalizeY</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">{ index, values }</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> {<span class=\"hljs-attr\">x</span>: X } = values;\n    \n    <span class=\"hljs-comment\">// 按照 x 通道分组</span>\n    <span class=\"hljs-keyword\">const</span> series = X ? <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-title function_\">group</span>(index, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> X[i]).<span class=\"hljs-title function_\">values</span>()) : [index];\n    \n    <span class=\"hljs-comment\">// 生成定义了的 y 方向的通道值</span>\n    <span class=\"hljs-keyword\">const</span> newValues = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">fromEntries</span>(\n      [<span class=\"hljs-string\">'y1'</span>, <span class=\"hljs-string\">'y'</span>]\n        .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> values[key])\n        .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> [key, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(index.<span class=\"hljs-property\">length</span>)]),\n    );\n    \n    <span class=\"hljs-comment\">// 处理每一个分组</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> I <span class=\"hljs-keyword\">of</span> series) {\n      <span class=\"hljs-comment\">// 找到该分组最大的 y</span>\n      <span class=\"hljs-keyword\">const</span> Y = I.<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(newValues).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> values[key][i]));\n      <span class=\"hljs-keyword\">const</span> n = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(...Y);\n      \n      <span class=\"hljs-comment\">// 归一化每一条数据的每一个 y 方向通道的值</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> i <span class=\"hljs-keyword\">of</span> I) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(newValues)) {\n          newValues[key][i] = values[key][i] / n;\n        }\n      }\n    }\n    \n    <span class=\"hljs-keyword\">return</span> {\n      index,\n      <span class=\"hljs-attr\">values</span>: {\n        ...values,\n        ...newValues,\n      },\n    };\n  };\n}\n</code></pre>\n<h2 data-id=\"heading-3\">对称（SymmetryY）</h2>\n<p>这之后我们来看看对称（SymmetryY），对称这个统计函数常常用于漏斗图和河流图。下面我们先来看一个简单的例子。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> countries = [\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Europe'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1750'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">163</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Europe'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1800'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">203</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Europe'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1850'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">276</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Europe'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1900'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">628</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Europe'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1950'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">547</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Europe'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1999'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">729</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Europe'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'2050'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">408</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Oceania'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1750'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">200</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Oceania'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1800'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">200</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Oceania'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1850'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">200</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Oceania'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1900'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">460</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Oceania'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1950'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">230</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Oceania'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1999'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">300</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Oceania'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'2050'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">300</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Africa'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1750'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">106</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Africa'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1800'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">107</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Africa'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1850'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">111</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Africa'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1900'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1766</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Africa'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1950'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">221</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Africa'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1999'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">767</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Africa'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'2050'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">133</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Asia'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1750'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">502</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Asia'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1800'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">635</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Asia'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1850'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">809</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Asia'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1900'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">5268</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Asia'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1950'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">4400</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Asia'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'1999'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">3634</span> },\n  { <span class=\"hljs-attr\">country</span>: <span class=\"hljs-string\">'Asia'</span>, <span class=\"hljs-attr\">year</span>: <span class=\"hljs-string\">'2050'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">947</span> },\n];\n</code></pre>\n<p>在上面数据的基础上，用区域几何图形加上堆叠统计函数我们可以得到以下的堆叠面积图。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46e5f1e22a5b48de8e207b2d73b28fe5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>但如果我们继续加入对称统计函数，就可以得到下面的河流图，可以发现它是关于 <code>y = 4000</code> 对称的！</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efa80dde41f84af2b6525ad6b79916a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>接下来我们就从数据层面了解一下它的使用方式。可以发现对称其实是改变了 y 和 y1 这两个通道值。在根据 x 通道分组的基础上，让每个组 y 方向通道的平均值保持一致，并且选择最大的那一个平均值。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { createSymmetryY } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../../src/statistic'</span>;\n\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">index</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>],\n  <span class=\"hljs-attr\">values</span>: {\n    <span class=\"hljs-attr\">x</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>],\n    <span class=\"hljs-attr\">y1</span>: [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>],\n    <span class=\"hljs-attr\">y</span>: [<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">8</span>],\n  },\n};\n\n<span class=\"hljs-keyword\">const</span> symmetryY = <span class=\"hljs-title function_\">createSymmetryY</span>();\n<span class=\"hljs-title function_\">symmetryY</span>(data);\n<span class=\"hljs-comment\">// {</span>\n<span class=\"hljs-comment\">//   index: [0, 1, 2],</span>\n<span class=\"hljs-comment\">//   values: {</span>\n<span class=\"hljs-comment\">//     x: [0, 1, 2],</span>\n<span class=\"hljs-comment\">//     y1: [4, 5, 6],</span>\n<span class=\"hljs-comment\">//     y: [10, 9, 8],</span>\n<span class=\"hljs-comment\">//   },</span>\n<span class=\"hljs-comment\">// }</span>\n</code></pre>\n<p>接下来我们就来看看具体的实现。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/statistc/symmetry.js</span>\n\n<span class=\"hljs-keyword\">import</span> { group } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createSymmetryY</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">{ index, values }</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> {<span class=\"hljs-attr\">x</span>: X} = values;\n    \n    <span class=\"hljs-comment\">// 按照 x 方向分组</span>\n    <span class=\"hljs-keyword\">const</span> series = X ? <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-title function_\">group</span>(index, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> X[i]).<span class=\"hljs-title function_\">values</span>()) : [index];\n    <span class=\"hljs-keyword\">const</span> newValues = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">fromEntries</span>(\n      [<span class=\"hljs-string\">'y1'</span>, <span class=\"hljs-string\">'y'</span>]\n        .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> values[key])\n        .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> [key, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(index.<span class=\"hljs-property\">length</span>)]),\n    );\n\n    <span class=\"hljs-comment\">// 计算每个分组 y 方向的平均值</span>\n    <span class=\"hljs-keyword\">const</span> M = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(series.<span class=\"hljs-property\">length</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [i, I] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(series)) {\n      <span class=\"hljs-keyword\">const</span> Y = I.<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(newValues).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> values[key][i]));\n      <span class=\"hljs-keyword\">const</span> min = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(...Y);\n      <span class=\"hljs-keyword\">const</span> max = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(...Y);\n      M[i] = (min + max) / <span class=\"hljs-number\">2</span>;\n    }\n\n    <span class=\"hljs-comment\">// 找到最大的平均值</span>\n    <span class=\"hljs-keyword\">const</span> maxM = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(...M);\n    \n    <span class=\"hljs-comment\">// 对 y 方向的通道进行调整</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [i, I] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(series)) {\n      <span class=\"hljs-keyword\">const</span> offset = maxM - M[i];\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> i <span class=\"hljs-keyword\">of</span> I) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(newValues)) {\n          newValues[key][i] = values[key][i] + offset;\n        }\n      }\n    }\n    \n    <span class=\"hljs-keyword\">return</span> {\n      index,\n      <span class=\"hljs-attr\">values</span>: {\n        ...values,\n        ...newValues,\n      },\n    };\n  };\n}\n</code></pre>\n<h2 data-id=\"heading-4\">分箱（BinX）</h2>\n<p>最后我们来看看分箱（BinX），分箱这个统计函数常常用于直方图，用于看数据的分布。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> rainfall = [\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jan.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">18.9</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Feb.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">28.8</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Mar.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">39.3</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Apr.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">81.4</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'May'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">47</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jun.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">20.3</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jul.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">24</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Aug.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">35.6</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jan.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">12.4</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Feb.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">23.2</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Mar.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">34.5</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Apr.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">99.7</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'May'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">52.6</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jun.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">35.5</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jul.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">37.4</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Aug.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">42.4</span> },\n];\n</code></pre>\n<p>比如我们想看看上面数据中的 rainfall 这个属性的分布情况，就可以对该属性进行分箱，最后得到下面的直方图。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28ebc280b4324e309902d03fe3c49982~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>参考上面的例子：分箱可以简单理解为对连续数据进行分组。对于离散数据的分组很好理解，但是对于连续数据听上去就有点奇怪了：连续的怎么分？所以我们首先需要计算一些均匀的分割值，把连续的数据范围分成一段段的，然后对每一段所包含的数据进行聚合。</p>\n<p>下面我们通过使用方式去深入了解一下它。可以发现我们将数据划分为了 <code>[0, 5, 10, 15, 20, 25, 30, 35]</code> 这些区间，每个区间的聚合方式选择了计数，并且将产生值作为了 fill 这个通道。同时根据划分的区间，修改了 x 和 y 通道，生成了 x1 通道。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { createBinX } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../../src/statistic'</span>;\n<span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">index</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">12</span>],\n  <span class=\"hljs-attr\">values</span>: {\n    <span class=\"hljs-attr\">x</span>: [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">16</span>, <span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">18</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">33</span>, <span class=\"hljs-number\">30</span>],\n    <span class=\"hljs-attr\">y</span>: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>],\n  },\n};\n\n<span class=\"hljs-keyword\">const</span> binX = <span class=\"hljs-title function_\">createBinX</span>({ <span class=\"hljs-attr\">channel</span>: <span class=\"hljs-string\">'fill'</span> });\n<span class=\"hljs-title function_\">binX</span>(data);\n<span class=\"hljs-comment\">// {</span>\n<span class=\"hljs-comment\">//   index: [0, 1, 2, 3, 4, 6],</span>\n<span class=\"hljs-comment\">//   values: {</span>\n<span class=\"hljs-comment\">//     x: [0, 5, 10, 15, 20, 25, 30],</span>\n<span class=\"hljs-comment\">//     x1: [5, 10, 15, 20, 25, 30, 35],</span>\n<span class=\"hljs-comment\">//     fill: [1, 2, 5, 3, 1, 0, 1],</span>\n<span class=\"hljs-comment\">//     y: [1, 1, 1, 1, 1, undefined, 1],</span>\n<span class=\"hljs-comment\">//   },</span>\n<span class=\"hljs-comment\">// }</span>\n</code></pre>\n<p>接下来我们就来看看具体的实现。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/statistc/bin.js</span>\n\n<span class=\"hljs-keyword\">import</span> { bisect, ticks, identity, group, tickStep, floor, ceil, firstOf, min, max } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-comment\">// 计算划分区间</span>\n<span class=\"hljs-comment\">// 这里我们使用 linear scale 的 ticks 算法</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bin</span>(<span class=\"hljs-params\">values, count = <span class=\"hljs-number\">10</span>, accessor = identity</span>) {\n  <span class=\"hljs-comment\">// 计算原始 step</span>\n  <span class=\"hljs-keyword\">const</span> minValue = <span class=\"hljs-title function_\">min</span>(values, accessor);\n  <span class=\"hljs-keyword\">const</span> maxValue = <span class=\"hljs-title function_\">max</span>(values, accessor);\n  <span class=\"hljs-keyword\">const</span> step = <span class=\"hljs-title function_\">tickStep</span>(minValue, maxValue, count);\n  \n  <span class=\"hljs-comment\">// 计算 nice 之后的 step</span>\n  <span class=\"hljs-keyword\">const</span> niceMin = <span class=\"hljs-title function_\">floor</span>(minValue, step);\n  <span class=\"hljs-keyword\">const</span> niceMax = <span class=\"hljs-title function_\">ceil</span>(maxValue, step);\n  <span class=\"hljs-keyword\">const</span> niceStep = <span class=\"hljs-title function_\">tickStep</span>(niceMin, niceMax, count);\n  \n  <span class=\"hljs-comment\">// 生成区间</span>\n  <span class=\"hljs-keyword\">const</span> thresholds = <span class=\"hljs-title function_\">ticks</span>(niceMin, niceMax, count);\n  \n  <span class=\"hljs-comment\">// 区间包含首位两个值，并且去重</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([\n    <span class=\"hljs-title function_\">floor</span>(niceMin, niceStep),\n    ...thresholds,\n    <span class=\"hljs-title function_\">ceil</span>(niceMax, niceStep),\n  ]));\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createBinX</span>(<span class=\"hljs-params\">{ count = <span class=\"hljs-number\">10</span>, channel, aggregate = (values) =&gt; values.length } = {}</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">{ index, values }</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> { [channel]: C, <span class=\"hljs-attr\">x</span>: X, x1, ...rest } = values;\n    <span class=\"hljs-keyword\">const</span> keys = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(rest);\n    \n    <span class=\"hljs-comment\">// 计算区间</span>\n    <span class=\"hljs-keyword\">const</span> thresholds = <span class=\"hljs-title function_\">bin</span>(X, count);\n    <span class=\"hljs-keyword\">const</span> n = thresholds.<span class=\"hljs-property\">length</span>;\n    \n    <span class=\"hljs-comment\">// 分组，依据是二分查找找到对应的区间</span>\n    <span class=\"hljs-keyword\">const</span> groups = <span class=\"hljs-title function_\">group</span>(index, <span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> <span class=\"hljs-title function_\">bisect</span>(thresholds, X[i]) - <span class=\"hljs-number\">1</span>);\n    \n    <span class=\"hljs-comment\">// 过滤掉没有数据点的区间</span>\n    <span class=\"hljs-keyword\">const</span> I = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(n - <span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">0</span>).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_, i</span>) =&gt;</span> i);\n    <span class=\"hljs-keyword\">const</span> filtered = I.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> groups.<span class=\"hljs-title function_\">has</span>(i));\n    \n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">index</span>: filtered,\n      <span class=\"hljs-attr\">values</span>: <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">fromEntries</span>([\n        <span class=\"hljs-comment\">// 修改其余的原始通道</span>\n        <span class=\"hljs-comment\">// 取该组该通道的第一个值作为新生成的值</span>\n        ...keys.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> [key, I.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> {\n          <span class=\"hljs-keyword\">if</span> (!groups.<span class=\"hljs-title function_\">has</span>(i)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">undefined</span>;\n          <span class=\"hljs-keyword\">return</span> values[key][<span class=\"hljs-title function_\">firstOf</span>(groups.<span class=\"hljs-title function_\">get</span>(i))];\n        })]),\n        \n        <span class=\"hljs-comment\">// 聚合并且产生新的通道</span>\n        <span class=\"hljs-comment\">// 这里的聚合方式为简单的计数</span>\n        [channel, I.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">i</span>) =&gt;</span> {\n          <span class=\"hljs-keyword\">if</span> (!groups.<span class=\"hljs-title function_\">has</span>(i)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">aggregate</span>(groups.<span class=\"hljs-title function_\">get</span>(i).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">index</span>) =&gt;</span> values[index]));\n        })],\n        \n        <span class=\"hljs-comment\">// 生成 x 和 x1 通道</span>\n        [<span class=\"hljs-string\">'x'</span>, thresholds.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>)],\n        [<span class=\"hljs-string\">'x1'</span>, thresholds.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">1</span>, n)],\n      ]),\n    };\n  };\n}\n</code></pre>\n<p>本章的所有统计函数就开发完成了，完整的代码可以在<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2Fsrc%2Fstatistic\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/src/statistic\" ref=\"nofollow noopener noreferrer\">这里</a>浏览，同样也可以通过<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fstatistic\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/statistic\" ref=\"nofollow noopener noreferrer\">这里</a>的测试代码来验证代码的正确性。</p>\n<h2 data-id=\"heading-5\">小结</h2>\n<p>这一章的内容大到这里就全部结束了。统计是一个比较难以理解的部分，在之后了解整个渲染流程之后，大家应该会更加清楚一点。</p>\n<p>相同的效果也可以通过预处理数据得到，比如使用 AntV 的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fdata-set\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/data-set\" ref=\"nofollow noopener noreferrer\">DataSet</a> 这个库。但是这样就不是一个统一的数据分析流程了，因为它不在 Sparrow 的可视化渲染流程之内，使用起来会比较割裂。</p>\n<p>在了解完统计之后，下一章我们将进入视图（View），看看如何一次绘制多个图表。</p>\n<blockquote>\n<p>参考资料</p>\n<ul>\n<li>The Grammar of Graphics, 2nd Edition, Leland Wilkinson</li>\n</ul>\n</blockquote><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "12\n实战：视图 - View\n学习时长: 46分34秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>上一章我们聊了一系列比较抽象的统计函数，了解了它们是如何改变几何图形的位置的。这一章我们来谈谈视图，了解一下什么是视图，又该如何组合它们去搭建一个拥有很多视图的界面（如下图）。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6837b9bc56f64094917df04c7a69a7ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>首先我们还是从视图理论开始，然后进入实战部分，去实现几个视图组合函数，最后再进行简单的小结。那么废话不多说，我们马上进入视图的学习。</p>\n<h2 data-id=\"heading-0\">视图理论</h2>\n<p>在可视化中，一个完整的视图至少由两个部分构成：几何元素和辅助组件（如下图。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f78bba1e26754af7b95ca341ef4f92fc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>上面的这张图是一个单视图图表，因为它只有一个视图。而下面这张图是一个多视图图表，因为它将多个视图组合在了一起。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9493b2ef3fdb4078bea613880a7b346e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>对于多视图图表来说，它其实是由一棵视图树构成。视图树类似于前端开发中的 DOM 树，只不过每一个节点不是一个 DOM 而是一个视图，类似的概念还有渲染引擎中的场景图（Scene Graph）。</p>\n<p>在数据结构层面，视图树就是一个如下的嵌套对象。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> viewTree = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'layer'</span>,\n  <span class=\"hljs-attr\">children</span>: [\n    {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'row'</span>,\n      <span class=\"hljs-attr\">children</span>: [{<span class=\"hljs-regexp\">/.../</span>}, {<span class=\"hljs-regexp\">/.../</span>}]\n    },\n    {\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'interval'</span>,\n    }\n  ]\n};\n</code></pre>\n<p>用 TypeScript 可以如下简单定义。</p>\n<pre><code class=\"hljs language-ts\" lang=\"ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">ViewTree</span> = {\n  <span class=\"hljs-keyword\">type</span>?: <span class=\"hljs-built_in\">string</span>, <span class=\"hljs-comment\">// 当前节点的种类</span>\n  children?: <span class=\"hljs-title class_\">ViewTree</span>[], <span class=\"hljs-comment\">// 包含的孩子节点</span>\n  [<span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span>,\n}\n</code></pre>\n<p>不同的视图节点有不同的布局方法和功能，在这里我们将实现3种视图节点：</p>\n<ul>\n<li>图层（Layer）：<code>type: 'layer'</code></li>\n<li>弹性盒子（Flex）：<code>type: 'col | row'</code></li>\n<li>分面（Facet）：<code>type: 'facet'</code></li>\n</ul>\n<p>而视图这个模块要做的就是解析这棵视图树，计算出每个视图区域的位置和大小，以及在这个区域有几个视图（视图可以重叠，之后我们会看见）。</p>\n<p>接下来我们就正式进入开发环节。</p>\n<h2 data-id=\"heading-1\">创建视图（createViews）</h2>\n<p>视图模块就导出一个函数：<strong>createViews(tree, computes)</strong>。</p>\n<p>该函数有两个参数，第一个参数是一个描述视图树的嵌套对象，第二个参数是一个对象，该对象的每一个值是一个支持的视图计算函数。该函数返回一个数组，数组的每一个元素是一个元组。</p>\n<p>元组的第一个元素是一个如下的区域的描述：</p>\n<pre><code class=\"hljs language-ts\" lang=\"ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Area</span> = {\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-built_in\">number</span>, \n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-built_in\">number</span>, \n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-built_in\">number</span>, \n  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-built_in\">number</span>, \n  [<span class=\"hljs-attr\">key</span>:<span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span>\n}\n</code></pre>\n<p>元组的第二个元素是一个数组，数组的每一个元素是当前区域的视图：</p>\n<p><code>ViewTree[]</code>。</p>\n<p>接下来我们就来看代码的实现。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/view/view.js</span>\n\n<span class=\"hljs-keyword\">import</span> { computeFlexViews } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./flex'</span>;\n<span class=\"hljs-keyword\">import</span> { computeFacetViews } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./facet'</span>;\n<span class=\"hljs-keyword\">import</span> { computeLayerViews } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./layer'</span>;\n<span class=\"hljs-keyword\">import</span> { descendants, group } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-comment\">// 支持 4 种类型的节点</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createViews</span>(<span class=\"hljs-params\">root, computes = {\n  layer: computeLayerViews,\n  col: computeFlexViews,\n  row: computeFlexViews,\n  facet: computeFacetViews,\n}</span>) {\n  <span class=\"hljs-comment\">// 获得视图树的所有节点</span>\n  <span class=\"hljs-keyword\">const</span> nodes = <span class=\"hljs-title function_\">descendants</span>(root);\n  \n  <span class=\"hljs-comment\">// 计算根节点视图区域大小</span>\n  <span class=\"hljs-keyword\">const</span> { width = <span class=\"hljs-number\">640</span>, height = <span class=\"hljs-number\">480</span>, x = <span class=\"hljs-number\">0</span>, y = <span class=\"hljs-number\">0</span> } = root;\n  <span class=\"hljs-keyword\">const</span> rootView = { width, height, x, y };\n  \n  <span class=\"hljs-comment\">// 根据节点索引视图</span>\n  <span class=\"hljs-keyword\">const</span> nodeView = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[root, rootView]]);\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> node <span class=\"hljs-keyword\">of</span> nodes) {\n    <span class=\"hljs-keyword\">const</span> view = nodeView.<span class=\"hljs-title function_\">get</span>(node);\n    <span class=\"hljs-keyword\">const</span> { children = [], type } = node;\n    <span class=\"hljs-keyword\">const</span> computeChildrenViews = computes[type];\n    <span class=\"hljs-keyword\">if</span> (computeChildrenViews) {\n      <span class=\"hljs-comment\">// 计算孩子节点的区域大小</span>\n      <span class=\"hljs-keyword\">const</span> childrenViews = <span class=\"hljs-title function_\">computeChildrenViews</span>(view, node);\n      <span class=\"hljs-keyword\">if</span> (computeChildrenViews !== computeFacetViews) {\n      <span class=\"hljs-comment\">// 如果不是分面节点，孩子节点和计算出来的区域一一对应</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [i, child] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(children)) {\n          nodeView.<span class=\"hljs-title function_\">set</span>(child, childrenViews[i]);\n        }\n      } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-comment\">// 如果是分面节点，将产生一些新的孩子节点</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> child <span class=\"hljs-keyword\">of</span> children) {\n          <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> view <span class=\"hljs-keyword\">of</span> childrenViews) {\n            nodeView.<span class=\"hljs-title function_\">set</span>({ ...child }, view);\n          }\n        }\n      }\n    }\n  }\n\n  <span class=\"hljs-comment\">// 将计算好的视图根据区域去分组</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">key</span> = (<span class=\"hljs-params\">d</span>) =&gt; <span class=\"hljs-string\">`<span class=\"hljs-subst\">${d.x}</span>-<span class=\"hljs-subst\">${d.y}</span>-<span class=\"hljs-subst\">${d.width}</span>-<span class=\"hljs-subst\">${d.height}</span>`</span>;\n  <span class=\"hljs-keyword\">const</span> keyViews = <span class=\"hljs-title function_\">group</span>(<span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(nodeView.<span class=\"hljs-title function_\">entries</span>()), <span class=\"hljs-function\">(<span class=\"hljs-params\">[, view]</span>) =&gt;</span> <span class=\"hljs-title function_\">key</span>(view));\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(keyViews.<span class=\"hljs-title function_\">values</span>()).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">views</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> view = views[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>];\n    <span class=\"hljs-keyword\">const</span> nodes = views.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d[<span class=\"hljs-number\">0</span>]);\n    <span class=\"hljs-keyword\">return</span> [view, nodes];\n  });\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/utils/tree.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">descendants</span>(<span class=\"hljs-params\">root</span>) {\n  <span class=\"hljs-keyword\">const</span> nodes = [];\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">push</span> = (<span class=\"hljs-params\">d</span>) =&gt; nodes.<span class=\"hljs-title function_\">push</span>(d);\n  <span class=\"hljs-title function_\">bfs</span>(root, push);\n  <span class=\"hljs-keyword\">return</span> nodes;\n}\n\n<span class=\"hljs-comment\">// 使用宽度优先搜索遍历这棵树</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">bfs</span>(<span class=\"hljs-params\">root, callback</span>) {\n  <span class=\"hljs-keyword\">const</span> discovered = [root];\n  <span class=\"hljs-keyword\">while</span> (discovered.<span class=\"hljs-property\">length</span>) {\n    <span class=\"hljs-keyword\">const</span> node = discovered.<span class=\"hljs-title function_\">pop</span>();\n    <span class=\"hljs-title function_\">callback</span>(node);\n    discovered.<span class=\"hljs-title function_\">push</span>(...(node.<span class=\"hljs-property\">children</span> || []));\n  }\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/utils/index.js</span>\n\n<span class=\"hljs-keyword\">export</span> * <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./tree'</span>;\n</code></pre>\n<h2 data-id=\"heading-2\">图层（Layer）</h2>\n<p>图层（Layer）节点的孩子视图都是重合在一起的，该节点主要用于在一个区域中绘制多个几何元素，就比如如下的例子。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> temperatures = [\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jan'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Tokyo'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">7</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jan'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">3.9</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Feb'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Tokyo'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">6.9</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Feb'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">4.2</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Mar'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Tokyo'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">9.5</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Mar'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">5.7</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Apr'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Tokyo'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">14.5</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Apr'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">8.5</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'May'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Tokyo'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">18.4</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'May'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">11.9</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jun'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Tokyo'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">21.5</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jun'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">15.2</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jul'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Tokyo'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">25.2</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jul'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">17</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Aug'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Tokyo'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">26.5</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Aug'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">16.6</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Sep'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Tokyo'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">23.3</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Sep'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">14.2</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Oct'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Tokyo'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">18.3</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Oct'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">10.3</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Nov'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Tokyo'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">13.9</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Nov'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">6.6</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Dec'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Tokyo'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">9.6</span> },\n  { <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Dec'</span>, <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">temperature</span>: <span class=\"hljs-number\">4.8</span> },\n];\n</code></pre>\n<p>我们用折线图将上面的数据可视化得到如下的结果，可以发现在该图区域中有两种几何元素：线和点，它们的辅助元素可以简单理解为重合了。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e33b1b467c0e4efe84d63a9163dbbf21~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>对于如下的视图树，绘出来时如下的结果。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> viewTree = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'layer'</span>,\n  <span class=\"hljs-attr\">children</span>: [{}, {}],\n};\n\n<span class=\"hljs-keyword\">const</span> views = <span class=\"hljs-title function_\">createViews</span>(viewTree);\n</code></pre>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c73acfa389c45b58881f6001d5541ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>它的实现非常简单，把自己的区域大小返回作为孩子节点的区域就好。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/view/layer.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">computeLayerViews</span>(<span class=\"hljs-params\">box, node</span>) {\n  <span class=\"hljs-keyword\">const</span> { children = [] } = node;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(children.<span class=\"hljs-property\">length</span>).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">0</span>).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">() =&gt;</span> ({ ...box }));\n}\n</code></pre>\n<h2 data-id=\"heading-3\">弹性盒子（Flex）</h2>\n<p>弹性盒子（Flex）节点的孩子视图在水平或者竖直方向都是充满父容器的，该概念来自于前端开发中的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-grammar.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://ruanyifeng.com/blog/2015/07/flex-grammar.html\" ref=\"nofollow noopener noreferrer\">Flex 布局</a>。</p>\n<p>该节点主要用于将区域划分为子区域，不同的子区域拥有不同的视图。该节点节点又分为两种类型：row 和 col。比如如果将上面例子中的容器类型从 layer 改成 row 的话就会得到如下的结果。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c77cb283fcd042fcb50c40947d8aea30~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>对于如下的视图树，绘出来有如下的结果。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> viewTree = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'row'</span>, <span class=\"hljs-comment\">// 孩子水平排列</span>\n  <span class=\"hljs-attr\">flex</span>: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>], <span class=\"hljs-comment\">// 指定孩子的节点区域的比例</span>\n  <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-number\">40</span>, <span class=\"hljs-comment\">// 孩子节点区域的间距</span>\n  <span class=\"hljs-attr\">children</span>: [\n    {},\n    <span class=\"hljs-comment\">// 孩子竖直排列</span>\n    { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'col'</span>, <span class=\"hljs-attr\">children</span>: [{}, {}] }, \n  ],\n};\n\n<span class=\"hljs-keyword\">const</span> views = <span class=\"hljs-title function_\">createViews</span>(viewTree);\n</code></pre>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31cab5209bf549d4984b2f9e697a9ebb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>具体的代码实现如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/view/flex.js</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">computeFlexViews</span>(<span class=\"hljs-params\">box, node</span>) {\n  <span class=\"hljs-keyword\">const</span> { type, children, flex = children.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-number\">1</span>), padding = <span class=\"hljs-number\">40</span> } = node;\n  <span class=\"hljs-keyword\">const</span> [mainStart, mainSize, crossSize, crossStart] = type === <span class=\"hljs-string\">'col'</span>\n    ? [<span class=\"hljs-string\">'y'</span>, <span class=\"hljs-string\">'height'</span>, <span class=\"hljs-string\">'width'</span>, <span class=\"hljs-string\">'x'</span>]\n    : [<span class=\"hljs-string\">'x'</span>, <span class=\"hljs-string\">'width'</span>, <span class=\"hljs-string\">'height'</span>, <span class=\"hljs-string\">'y'</span>];\n\n  <span class=\"hljs-keyword\">const</span> sum = flex.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">total, value</span>) =&gt;</span> total + value);\n  <span class=\"hljs-keyword\">const</span> totalSize = box[mainSize] - padding * (children.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-keyword\">const</span> sizes = flex.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span> totalSize * (value / sum));\n\n  <span class=\"hljs-keyword\">const</span> childrenViews = [];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> next = box[mainStart], i = <span class=\"hljs-number\">0</span>; i &lt; sizes.<span class=\"hljs-property\">length</span>; next += sizes[i] + padding, i += <span class=\"hljs-number\">1</span>) {\n    childrenViews.<span class=\"hljs-title function_\">push</span>({\n      [mainStart]: next,\n      [mainSize]: sizes[i],\n      [crossStart]: box[crossStart],\n      [crossSize]: box[crossSize],\n    });\n  }\n  <span class=\"hljs-keyword\">return</span> childrenViews;\n}\n</code></pre>\n<h2 data-id=\"heading-4\">分面（Facet）</h2>\n<p>最后我们来看看分面（Facet）节点。分面是可视化中一个常用的手段，主要用于对数据进行分组，不同组的数据在不同的视图中展示。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> facet = [\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jan.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">18.9</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'a'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Feb.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">28.8</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'a'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Mar.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">39.3</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'a'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Apr.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">81.4</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'a'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'May'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">47</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'b'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jun.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">20.3</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'b'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jul.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">24</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'b'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'London'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Aug.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">35.6</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'b'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jan.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">12.4</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'a'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Feb.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">23.2</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'a'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Mar.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">34.5</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'a'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Apr.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">99.7</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'a'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'May'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">52.6</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'b'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jun.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">35.5</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'b'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Jul.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">37.4</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'b'</span> },\n  { <span class=\"hljs-attr\">city</span>: <span class=\"hljs-string\">'Berlin'</span>, <span class=\"hljs-attr\">month</span>: <span class=\"hljs-string\">'Aug.'</span>, <span class=\"hljs-attr\">rainfall</span>: <span class=\"hljs-number\">42.4</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'b'</span> },\n];\n</code></pre>\n<p>比如如果如上的数据 x 方向按照 type 字段分组，y 方向按照 city 字段分组就会得到如下的结果。不难发现：在左上角的条形图中只包含 <code>city === \"Berlin\"</code> 以及 <code>type === \"a\"</code> 的数据。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/086c1312ad0c4d9dbe4ec28e369e17dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>根据上面的案例我们可以发现，分面节点除了会计算孩子节点区域的大小，还会去过滤数据，所以它还会额外返回一个过滤数据的函数。使用方式如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> data = [\n  { <span class=\"hljs-attr\">sex</span>: <span class=\"hljs-string\">'male'</span>, <span class=\"hljs-attr\">skin</span>: <span class=\"hljs-string\">'white'</span> },\n  { <span class=\"hljs-attr\">sex</span>: <span class=\"hljs-string\">'male'</span>, <span class=\"hljs-attr\">skin</span>: <span class=\"hljs-string\">'black'</span> },\n  { <span class=\"hljs-attr\">sex</span>: <span class=\"hljs-string\">'female'</span>, <span class=\"hljs-attr\">skin</span>: <span class=\"hljs-string\">'white'</span> },\n  { <span class=\"hljs-attr\">sex</span>: <span class=\"hljs-string\">'female'</span>, <span class=\"hljs-attr\">skin</span>: <span class=\"hljs-string\">'yellow'</span> },\n];\n\n<span class=\"hljs-keyword\">const</span> views = <span class=\"hljs-title function_\">createViews</span>({\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'facet'</span>,\n  <span class=\"hljs-comment\">// 通过 encodings 这个配置去指定 x 和 y 方向的分组</span>\n  <span class=\"hljs-attr\">encodings</span>: {\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">'sex'</span>, <span class=\"hljs-comment\">// 根据 sex 属性分组</span>\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">'skin'</span>, <span class=\"hljs-comment\">// 根据 skin 属性分组</span>\n  },\n  data,\n  <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-number\">20</span>, <span class=\"hljs-comment\">// 指定区域之间的间隔</span>\n  <span class=\"hljs-attr\">children</span>: [{}, {}],\n});\n\n<span class=\"hljs-keyword\">const</span> [, [view]] = views;\n<span class=\"hljs-keyword\">const</span> { transform } = view; <span class=\"hljs-comment\">// 获取过滤数据的函数</span>\n<span class=\"hljs-title function_\">transform</span>(data); <span class=\"hljs-comment\">// [{ sex: 'male', skin: 'white' }]</span>\n</code></pre>\n<p>最后绘制出来的效果如下：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32c343ef4a4341ea8021fd168b2cf2c0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>代码实现如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/view/flex.js</span>\n\n<span class=\"hljs-keyword\">import</span> { group } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">computeFacetViews</span>(<span class=\"hljs-params\">box, {\n  data, encodings = {}, padding = <span class=\"hljs-number\">0</span>,\n  paddingLeft = <span class=\"hljs-number\">45</span>, paddingRight = <span class=\"hljs-number\">45</span>, paddingBottom = <span class=\"hljs-number\">45</span>, paddingTop = <span class=\"hljs-number\">60</span>,\n}</span>) {\n  <span class=\"hljs-keyword\">const</span> { x, y } = encodings;\n  <span class=\"hljs-keyword\">const</span> cols = x ? <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-title function_\">group</span>(data, <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d[x]).<span class=\"hljs-title function_\">keys</span>()) : [<span class=\"hljs-literal\">undefined</span>];\n  <span class=\"hljs-keyword\">const</span> rows = y ? <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-title function_\">group</span>(data, <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d[y]).<span class=\"hljs-title function_\">keys</span>()) : [<span class=\"hljs-literal\">undefined</span>];\n  <span class=\"hljs-keyword\">const</span> n = cols.<span class=\"hljs-property\">length</span>;\n  <span class=\"hljs-keyword\">const</span> m = rows.<span class=\"hljs-property\">length</span>;\n  <span class=\"hljs-keyword\">const</span> views = [];\n  <span class=\"hljs-keyword\">const</span> width = box.<span class=\"hljs-property\">width</span> - paddingLeft - paddingRight;\n  <span class=\"hljs-keyword\">const</span> height = box.<span class=\"hljs-property\">height</span> - paddingTop - paddingBottom;\n  <span class=\"hljs-keyword\">const</span> boxWidth = (width - padding * (n - <span class=\"hljs-number\">1</span>)) / n;\n  <span class=\"hljs-keyword\">const</span> boxHeight = (height - padding * (m - <span class=\"hljs-number\">1</span>)) / m;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i += <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>; j &lt; m; j += <span class=\"hljs-number\">1</span>) {\n      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">transform</span> = (<span class=\"hljs-params\">data</span>) =&gt; {\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">inRow</span> = (<span class=\"hljs-params\">d</span>) =&gt; d[x] === cols[i] || cols[i] === <span class=\"hljs-literal\">undefined</span>;\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">inCol</span> = (<span class=\"hljs-params\">d</span>) =&gt; d[y] === rows[j] || rows[j] === <span class=\"hljs-literal\">undefined</span>;\n        <span class=\"hljs-keyword\">return</span> data.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> <span class=\"hljs-title function_\">inRow</span>(d) &amp;&amp; <span class=\"hljs-title function_\">inCol</span>(d));\n      };\n      views.<span class=\"hljs-title function_\">push</span>({\n        <span class=\"hljs-attr\">x</span>: paddingLeft + box.<span class=\"hljs-property\">x</span> + padding * i + i * boxWidth,\n        <span class=\"hljs-attr\">y</span>: paddingTop + box.<span class=\"hljs-property\">y</span> + padding * j + j * boxHeight,\n        <span class=\"hljs-attr\">width</span>: boxWidth,\n        <span class=\"hljs-attr\">height</span>: boxHeight,\n        transform, <span class=\"hljs-comment\">// 指定过滤函数</span>\n      });\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> views;\n}\n</code></pre>\n<p>本章的所有视图计算函数就开发完成了，完整的代码可以在<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2Fsrc%2Fview\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/src/view\" ref=\"nofollow noopener noreferrer\">这里</a>浏览，同样也可以通过<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fview\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/view\" ref=\"nofollow noopener noreferrer\">这里</a>的测试代码来验证代码的正确性。</p>\n<h2 data-id=\"heading-5\">小结</h2>\n<p>分面这一章就到这里结束了，我们通过这一章了解到了如下的几种视图组合方式：</p>\n<ul>\n<li>图层（Layer）</li>\n<li>弹性盒子（Flex）</li>\n<li>分面（Facet）</li>\n</ul>\n<p>不同的组合方式有不同的使用场景，它可以帮助我们搭建复杂的可视化图表界面，也可以提高我们的分析能力。</p>\n<p>到目前为止，我们已经把渲染引擎和低级可视化模块开发完成了。接下来是时候将它们串联起来了，看看在整个渲染流程中它们该如何使用。下一章我们将进入 Sparrow 渲染流程 Plot 模块的开发。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/723fb646abdc4a96acc3e50010abf1e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "13\n实战：渲染流程 - Plot\n学习时长: 63分49秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>经过前面的学习，我们已经把渲染引擎和低级可视化模块开发完了，也了解了对应的可视化概念。那么这一章我们就把已经开发好的这些模块串起来，完成“从0到1开发一个图表库”的这一任务。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/723fb646abdc4a96acc3e50010abf1e8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>这一章我们将从 Sparrow 的 API 介绍开始，然后梳理渲染流程，这之后再开始介绍关键代码。这一章可以说是整个实战环节的画龙点睛之笔，那么接下来就让我们开始吧！</p>\n<h2 data-id=\"heading-0\">API 设计</h2>\n<p>首先我们来看看 API 设计，也就是了解一下该如何使用我们最后完成 Sparrow。</p>\n<p>Sparrow 最终只暴露出一个函数：<code>plot</code>。该函数根据指定的 options 渲染图表并且返回一个渲染好的 SVG 元素。函数签名可以用 TypeScript 简单地如下定义：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-title function_\">plot</span>(<span class=\"hljs-attr\">options</span>: <span class=\"hljs-title class_\">SPSpec</span>): <span class=\"hljs-title class_\">SVGSVGElement</span>\n</code></pre>\n<p>至于这个 options 的结构用 TypeScript 可以简单地如下定义：</p>\n<pre><code class=\"hljs language-ts\" lang=\"ts\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">SPSpec</span> = <span class=\"hljs-title class_\">SPNode</span>;\n\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">SPNode</span> = {\n  <span class=\"hljs-keyword\">type</span>?: <span class=\"hljs-built_in\">string</span>;\n  data?: <span class=\"hljs-built_in\">any</span>[],\n  scales?: <span class=\"hljs-title class_\">Recode</span>&lt;<span class=\"hljs-title class_\">ChannelTypes</span>, <span class=\"hljs-title class_\">Scale</span>&gt;,\n  transforms?: <span class=\"hljs-title class_\">Transform</span>[],\n  statistics?: <span class=\"hljs-title class_\">Statistic</span>[],\n  encodings?: <span class=\"hljs-title class_\">Recode</span>&lt;<span class=\"hljs-title class_\">ChannelTypes</span>, <span class=\"hljs-title class_\">Encode</span>&gt;,\n  guides?: <span class=\"hljs-title class_\">Recode</span>&lt;<span class=\"hljs-title class_\">ChannelTypes</span>, <span class=\"hljs-title class_\">Guide</span>&gt;,\n  styles?: <span class=\"hljs-title class_\">Record</span>&lt;<span class=\"hljs-built_in\">string</span>, <span class=\"hljs-built_in\">string</span>&gt;\n  children?: <span class=\"hljs-title class_\">SPNode</span>[];\n  paddingLeft?: <span class=\"hljs-built_in\">number</span>,\n  paddingRight?: <span class=\"hljs-built_in\">number</span>,\n  paddingTop?: <span class=\"hljs-built_in\">number</span>,\n  paddingBottom?: <span class=\"hljs-built_in\">number</span>,\n}\n</code></pre>\n<p>可以发现：它是一个嵌套的结构，描述的是上一章提到的视图树。</p>\n<p>每一个节点的 type 除了上一章提到的 layer、col、row 这些<strong>容器节点</strong>之外，还可以是所有几何元素的类型：interval、area、text 等等，这些被称为<strong>视图节点</strong>，当然上一章提到的 facet 节点也算是一个视图节点。容器节点可以有 children 属性，但是视图节点不能有 children 属性。</p>\n<p>下面对上面的节点的一些属性进行解释：</p>\n<ul>\n<li>data：任意类型的数据。</li>\n<li>scales：比例尺的配置，比如：<code>{type: 'ordinal', range: ['red', 'yellow']}</code></li>\n<li>transforms：数据预处理配置，比如：<code>data =&gt; data.sort()</code></li>\n<li>statistics：统计函数配置，比如：<code>{type: 'stackY'}</code></li>\n<li>encodings：指定几何元素的每个通道用什么编码，比如：<code>{x: 'genre', y: 'sold'}</code></li>\n<li>guides：指定辅助组件的配置，比如：<code>{type: 'axisY', display: false}</code></li>\n<li>styles：指定几何元素的样式，比如：<code>{strokeWidth: 10}</code></li>\n<li>paddingLeft：几何图形区域到整个图表区域的左边距。</li>\n<li>paddingRight：几何图形区域到整个图表区域的右边距。</li>\n<li>paddingTop：几何图形区域到整个图表区域的上边距。</li>\n<li>paddingBottom：几何图形区域到整个图表区域的下边距。</li>\n</ul>\n<p>对于容器节点来说，上面的属性对其没有效果，但是会被后代中视图节点继承。比如下面两种写法其实是等价的。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 可以理解为是下面的语法糖</span>\n<span class=\"hljs-keyword\">const</span> options = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'layer'</span>,\n  <span class=\"hljs-attr\">encodings</span>: {<span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">'name'</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">'value'</span>}\n  <span class=\"hljs-attr\">children</span>: [\n    {<span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'point'</span>},\n    {<span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'line'</span>}\n  ],\n}\n\n<span class=\"hljs-keyword\">const</span> options = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'layer'</span>,\n  <span class=\"hljs-attr\">children</span>: [\n    <span class=\"hljs-comment\">// encodings 这个配置继承于父亲</span>\n    {<span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'point'</span>, <span class=\"hljs-attr\">encodings</span>: {<span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">'name'</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">'value'</span>}},\n    {<span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'line'</span>, <span class=\"hljs-attr\">encodings</span>: {<span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">'name'</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">'value'</span>}}\n  ],\n}\n</code></pre>\n<p>有了上面的介绍，接下来来看一个简单的例子。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> sports = [\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Sports'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">275</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Strategy'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">115</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Action'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">120</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Shooter'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">350</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Other'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">150</span> },\n];\n</code></pre>\n<p>如果我们要用 Interval 去可视化上面的数据，那么我们将如下使用 Sparrow：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { plot } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@sparrow-vis/plot'</span>;\n\n<span class=\"hljs-title function_\">plot</span>({\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'interval'</span>, <span class=\"hljs-comment\">// 指定节点的种类是 interval</span>\n  <span class=\"hljs-attr\">data</span>: sports, <span class=\"hljs-comment\">// 指定数据</span>\n  <span class=\"hljs-attr\">encodings</span>: {\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">'genre'</span>, <span class=\"hljs-comment\">// 指定 x 通道由数据的 genre 属性决定</span>\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">'sold'</span>, <span class=\"hljs-comment\">// 指定 y 通道由数据的 sold 属性决定</span>\n  },\n});\n</code></pre>\n<p>最后的效果如下图：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7da9b55aa0584523b7a5bdbd5570c765~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>接下来我们来看一个稍微复杂一点的例子，同样是上面的例子，这次我们来绘制一个饼图。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { plot } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@sparrow-vis/plot'</span>;\n\n<span class=\"hljs-title function_\">plot</span>({\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'interval'</span>,\n  <span class=\"hljs-attr\">data</span>: sports,\n  <span class=\"hljs-comment\">// 将数据的 sold 字段转换成百分比形式</span>\n  <span class=\"hljs-attr\">transforms</span>: [<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> sum = data.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">total, d</span>) =&gt;</span> total + d.<span class=\"hljs-property\">sold</span>, <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">return</span> data.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ genre, sold }</span>) =&gt;</span> ({ genre, <span class=\"hljs-attr\">sold</span>: sold / sum }));\n  }],\n  <span class=\"hljs-comment\">// 使用两个坐标系变换：transpose 和 polar</span>\n  <span class=\"hljs-attr\">coordinates</span>: [{ <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'transpose'</span> }, { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'polar'</span> }],\n  <span class=\"hljs-comment\">// 使用一个统计变换 stackY</span>\n  <span class=\"hljs-attr\">statistics</span>: [{ <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'stackY'</span> }],\n  <span class=\"hljs-comment\">// 设置 x 通道使用的比例尺的 padding 属性</span>\n  <span class=\"hljs-comment\">// interval 的 x 通道必须使用 band 比例尺，所以有 padding 属性</span>\n  <span class=\"hljs-attr\">scales</span>: {\n    <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-number\">0</span> },\n  },\n  <span class=\"hljs-attr\">guides</span>: {\n    <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> }, <span class=\"hljs-comment\">// 不显示 x 方向的坐标轴</span>\n    <span class=\"hljs-attr\">y</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> }, <span class=\"hljs-comment\">// 不显示 y 方向的坐标轴</span>\n  },\n  <span class=\"hljs-attr\">encodings</span>: {\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">'sold'</span>, <span class=\"hljs-comment\">// y 通道和 sold 属性绑定</span>\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'genre'</span>, <span class=\"hljs-comment\">// fill 通道和 genre 属性绑定</span>\n  },\n  <span class=\"hljs-comment\">// 设置饼图的样式</span>\n  <span class=\"hljs-attr\">styles</span>: {\n    <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'#000'</span>, \n    <span class=\"hljs-attr\">strokeWidth</span>: <span class=\"hljs-number\">2</span>,\n  },\n})\n</code></pre>\n<p>最后的效果如下：</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a83a2a45f0d24cd0819c06c21aa1baee~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>了解完了 API 设计，接下来就来看看渲染流程，看看 plot 函数是如何将配置转换成 SVG 元素的，或者是如何把数据转换成像素点的。(更多的使用方式可以参看这里的<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Fblob%2Fmain%2F__tests__%2Fplot%2Fplot.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/blob/main/__tests__/plot/plot.spec.js\" ref=\"nofollow noopener noreferrer\">测试代码</a>）。</p>\n<p><strong>在开始看代码之前，大家可以先去 Sparrow 的<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fsparrow-vis.github.io%2F%23%2Fintroduction\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://sparrow-vis.github.io/#/introduction\" ref=\"nofollow noopener noreferrer\">官网</a>看看案例，了解一下 Sparrow 的具体使用方式，然后可以先想想自己会如何去实现。</strong> 这之后再读代码的话可以做到事半功倍的效果。</p>\n<h2 data-id=\"heading-1\">渲染流程</h2>\n<p>Sparrow 整个的渲染流程主要分为下面几个阶段：</p>\n<ul>\n<li>预处理：视图节点继承祖先容器节点的属性，同时合并同一区域的属性。</li>\n<li>获取通道值：\n<ul>\n<li>通过 transforms 函数转换数据，获得需要可视化的表格数据。</li>\n<li>根据编码 encodings 配置从数据中去提取几何图形每个通道对应的值。</li>\n<li>通过 statsitcs 函数处理获得的通道值，获得最后真正被可视化出来的通道值。</li>\n</ul>\n</li>\n<li>创建比例尺：根据当前的通道值以及 scales 配置去推断对应比例尺                                                       种类，定义域和值域的值。</li>\n<li>创建辅助组件：根据推断出来的比例尺以及 guides 配置去创建对应的辅助元素。</li>\n<li>创建坐标系：根据 coordinates 配置去创建对应的坐标系。</li>\n<li>绘制：\n<ul>\n<li>绘制辅助组件。</li>\n<li>绘制几何元素。</li>\n</ul>\n</li>\n</ul>\n<p>我们通过上面饼图的例子来展示一下这个流程。最开始的数据如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> data = [\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Sports'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">275</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Strategy'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">115</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Action'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">120</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Shooter'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">350</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Other'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">150</span> },\n];\n</code></pre>\n<p>首先数据会经过如下 transforms 函数的转换，这里面的转换会被合成一个函数。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-title function_\">plot</span>({\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">transforms</span>: [<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> sum = data.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">total, d</span>) =&gt;</span> total + d.<span class=\"hljs-property\">sold</span>, <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">return</span> data.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ genre, sold }</span>) =&gt;</span> ({ genre, <span class=\"hljs-attr\">sold</span>: sold / sum }));\n  }]\n  <span class=\"hljs-comment\">// ...</span>\n})\n</code></pre>\n<p>这一步之后的数据如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> transformedData = [\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Sports'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">0.2722772277227723</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Strategy'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">0.11386138613861387</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Action'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">0.1188118811881188</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Shooter'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">0.3465346534653465</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Other'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">0.1485148514851485</span> },\n];\n</code></pre>\n<p>数据转换之后将会根据 encodings 去提取数据。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-title function_\">plot</span>({\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">encodings</span>: {\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">'sold'</span>, <span class=\"hljs-comment\">// y 通道和 sold 属性绑定</span>\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'genre'</span>, <span class=\"hljs-comment\">// fill 通道和 genre 属性绑定</span>\n  },\n  <span class=\"hljs-comment\">// ...</span>\n})\n</code></pre>\n<p>根据如上的配置会得到如下的结果：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> values = {\n  <span class=\"hljs-comment\">// fill 和 'genre' 字段绑定，所以提取出来是 'genre' 字段的值</span>\n  <span class=\"hljs-attr\">fill</span>: [<span class=\"hljs-string\">'Sports'</span>, <span class=\"hljs-string\">'Strategy'</span>, <span class=\"hljs-string\">'Action'</span>, <span class=\"hljs-string\">'Shooter'</span>, <span class=\"hljs-string\">'Other'</span>],\n  <span class=\"hljs-comment\">// 没有指定 x 通道的值，默认为 0</span>\n  <span class=\"hljs-attr\">x</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n  <span class=\"hljs-comment\">// 没有指定 x 通道的值，默认为 0</span>\n  <span class=\"hljs-attr\">y1</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n  <span class=\"hljs-comment\">// y 和 'sold' 字段绑定，所以提取出来是 'sold' 字段的值</span>\n  <span class=\"hljs-attr\">y</span>: [<span class=\"hljs-number\">0.2722772277227723</span>, <span class=\"hljs-number\">0.11386138613861387</span>, <span class=\"hljs-number\">0.1188118811881188</span>, <span class=\"hljs-number\">0.3465346534653465</span>, <span class=\"hljs-number\">0.1485148514851485</span>]\n};\n</code></pre>\n<p>这之后就会就会经过 statistics 去处理数据。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-title function_\">plot</span>({\n  <span class=\"hljs-comment\">// ... </span>\n  <span class=\"hljs-attr\">statistics</span>: [{ <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'stackY'</span> }],\n  <span class=\"hljs-comment\">// ...</span>\n})\n</code></pre>\n<p>处理后的数据如下，可以发现 y 方向的通道已经被堆叠过了。这个阶段获得的 <code>transformedValues</code> 就是获得的通道值。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> transformedValues = {\n  <span class=\"hljs-comment\">// fill 和 'genre' 字段绑定，所以提取出来是 'genre' 字段的值</span>\n  <span class=\"hljs-attr\">fill</span>: [<span class=\"hljs-string\">'Sports'</span>, <span class=\"hljs-string\">'Strategy'</span>, <span class=\"hljs-string\">'Action'</span>, <span class=\"hljs-string\">'Shooter'</span>, <span class=\"hljs-string\">'Other'</span>],\n  <span class=\"hljs-comment\">// 没有指定 x 通道的值，默认为 0</span>\n  <span class=\"hljs-attr\">x</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>],\n  <span class=\"hljs-comment\">// 没有指定 x 通道的值，默认为 0</span>\n  <span class=\"hljs-attr\">y1</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.2722772277227723</span>, <span class=\"hljs-number\">0.38613861386138615</span>, <span class=\"hljs-number\">0.504950495049505</span>, <span class=\"hljs-number\">0.8514851485148515</span>],\n  <span class=\"hljs-comment\">// y 和 'sold' 字段绑定，所以提取出来是 'sold' 字段的值</span>\n  <span class=\"hljs-attr\">y</span>: [<span class=\"hljs-number\">0.2722772277227723</span>, <span class=\"hljs-number\">0.38613861386138615</span>, <span class=\"hljs-number\">0.504950495049505</span>, <span class=\"hljs-number\">0.8514851485148515</span>, <span class=\"hljs-number\">1</span>]\n};\n</code></pre>\n<p>接下来就是根据获得的通道值创建比例尺了。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-title function_\">plot</span>({\n  <span class=\"hljs-comment\">// ... </span>\n  <span class=\"hljs-attr\">scales</span>: {\n    <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-number\">0</span>}\n  },\n  <span class=\"hljs-comment\">// ...</span>\n})\n</code></pre>\n<p>下面只展示了根据通道值和 scales 配置推断出来的比例尺比较重要的属性。这里的推断规则会后面介绍。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> scaleDescriptors = {\n  <span class=\"hljs-comment\">// stroke 和 fill 通道都是用 color 比例尺</span>\n  <span class=\"hljs-attr\">color</span>: {\n    <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-string\">'Sports'</span>, <span class=\"hljs-string\">'Strategy'</span>, <span class=\"hljs-string\">'Action'</span>, <span class=\"hljs-string\">'Shooter'</span>, <span class=\"hljs-string\">'Other'</span>],\n    <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-string\">'#5B8FF9'</span>, <span class=\"hljs-string\">'#5AD8A6'</span>, <span class=\"hljs-comment\">/* ... */</span>]\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'ordinal'</span>,\n  },\n  <span class=\"hljs-comment\">// x 方向的通道（x1、x）都使用 x 比例尺</span>\n  <span class=\"hljs-attr\">x</span>: {\n    <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>],\n    <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'band'</span>\n  },\n  <span class=\"hljs-comment\">// y 方向的通道（y1、y）都使用 y 比例尺</span>\n  <span class=\"hljs-attr\">y</span>: {\n    <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n    <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>],\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'linear'</span>\n  }\n}\n</code></pre>\n<p>这之后会根据 scaleDescriptors 和 guides 的配置去推断 guidesDescriptors。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-title function_\">plot</span>({\n  <span class=\"hljs-comment\">// ... </span>\n  <span class=\"hljs-attr\">guides</span>: {\n    <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> }, <span class=\"hljs-comment\">// 不显示 x 方向的坐标轴</span>\n    <span class=\"hljs-attr\">y</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> }, <span class=\"hljs-comment\">// 不显示 y 方向的坐标轴</span>\n  },\n  <span class=\"hljs-comment\">// ...</span>\n})\n</code></pre>\n<p>最后得到的 guidesDescriptors 如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> guidesDescriptors = {\n  <span class=\"hljs-comment\">// color 通道的辅助组件是 legendSwatches</span>\n  <span class=\"hljs-comment\">// x 和 y 因为都设置为 display: false 了，所以不现实</span>\n  <span class=\"hljs-attr\">color</span>: {\n    <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-string\">'Sports'</span>, <span class=\"hljs-string\">'Strategy'</span>, <span class=\"hljs-string\">'Action'</span>, <span class=\"hljs-string\">'Shooter'</span>, <span class=\"hljs-string\">'Other'</span>]\n    <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">'genre'</span>,\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'legendSwatches'</span>,\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">45</span>, \n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>\n  }\n}\n</code></pre>\n<p>这之后创建坐标系，绘制辅助组件和几何图形就没有太多需要说的地方了。接下来就进入我们的写代码环节：因为 Plot 这个模块一共有 500 多行代码，所以就不全部在文章中讲解了，这里只会讲解一些比较重要的部分。</p>\n<h2 data-id=\"heading-2\">plot</h2>\n<p>我们首先从 plot 函数开始，该函数会预处理我们的配置，然后解析描述的视图树，将嵌套的视图树拍平成一个视图树组，最后通过 plotView 函数绘制每一个视图。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/plot/plot.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createViews } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../view'</span>;\n<span class=\"hljs-keyword\">import</span> { createRenderer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../renderer'</span>;\n<span class=\"hljs-keyword\">import</span> { createCoordinate } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../coordinate'</span>;\n<span class=\"hljs-keyword\">import</span> { create } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./create'</span>;\n<span class=\"hljs-keyword\">import</span> { inferScales, applyScales } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./scale'</span>;\n<span class=\"hljs-keyword\">import</span> { initialize } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./geometry'</span>;\n<span class=\"hljs-keyword\">import</span> { inferGuides } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./guide'</span>;\n<span class=\"hljs-keyword\">import</span> { bfs, identity, map, assignDefined } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">plot</span>(<span class=\"hljs-params\">root</span>) {\n  <span class=\"hljs-comment\">// 创建渲染引擎</span>\n  <span class=\"hljs-keyword\">const</span> { width = <span class=\"hljs-number\">640</span>, height = <span class=\"hljs-number\">480</span>, <span class=\"hljs-attr\">renderer</span>: plugin } = root;\n  <span class=\"hljs-keyword\">const</span> renderer = <span class=\"hljs-title function_\">createRenderer</span>(width, height, plugin);\n  \n  <span class=\"hljs-comment\">// 将配置从容器节点流向视图节点</span>\n  <span class=\"hljs-title function_\">flow</span>(root);\n  \n  <span class=\"hljs-comment\">// 将视图树转换成视图树组</span>\n  <span class=\"hljs-keyword\">const</span> views = <span class=\"hljs-title function_\">createViews</span>(root);\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [view, nodes] <span class=\"hljs-keyword\">of</span> views) {\n    <span class=\"hljs-keyword\">const</span> { transform = identity, ...dimensions } = view;\n    <span class=\"hljs-keyword\">const</span> geometries = [];\n    <span class=\"hljs-keyword\">const</span> scales = {};\n    <span class=\"hljs-keyword\">const</span> guides = {};\n    <span class=\"hljs-keyword\">let</span> coordinates = [];\n    <span class=\"hljs-keyword\">const</span> chartNodes = nodes.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ type }</span>) =&gt;</span> <span class=\"hljs-title function_\">isChartNode</span>(type));\n    <span class=\"hljs-comment\">// 合并同一区域的所拥有视图的配置</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> options <span class=\"hljs-keyword\">of</span> chartNodes) {\n      <span class=\"hljs-keyword\">const</span> {\n        <span class=\"hljs-attr\">scales</span>: s = {},\n        <span class=\"hljs-attr\">guides</span>: g = {},\n        <span class=\"hljs-attr\">coordinates</span>: c = [],\n        transforms = [],\n        paddingLeft, paddingRight, paddingBottom, paddingTop,\n        ...geometry\n      } = options;\n      <span class=\"hljs-title function_\">assignDefined</span>(scales, s); <span class=\"hljs-comment\">// 合并 scales 配置</span>\n      <span class=\"hljs-title function_\">assignDefined</span>(guides, g); <span class=\"hljs-comment\">// 合并 guides 配置</span>\n      <span class=\"hljs-comment\">// 合并 padding 等配置</span>\n      <span class=\"hljs-title function_\">assignDefined</span>(dimensions, { paddingLeft, paddingRight, paddingBottom, paddingTop });\n      <span class=\"hljs-keyword\">if</span> (c) coordinates = c; <span class=\"hljs-comment\">// 使用最后一个视图的坐标系</span>\n      <span class=\"hljs-comment\">// 收集该区域的所有几何图形</span>\n      geometries.<span class=\"hljs-title function_\">push</span>({ ...geometry, <span class=\"hljs-attr\">transforms</span>: [transform, ...transforms] }); \n    }\n    <span class=\"hljs-comment\">// 绘制每一个区域</span>\n    <span class=\"hljs-title function_\">plotView</span>({ renderer, scales, guides, geometries, coordinates, ...dimensions });\n  }\n  <span class=\"hljs-comment\">// 返回 SVG 元素</span>\n  <span class=\"hljs-keyword\">return</span> renderer.<span class=\"hljs-title function_\">node</span>();\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/plot/plot.js</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">flow</span>(<span class=\"hljs-params\">root</span>) {\n  <span class=\"hljs-title function_\">bfs</span>(root, <span class=\"hljs-function\">(<span class=\"hljs-params\">{ type, children, ...options }</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isChartNode</span>(type)) <span class=\"hljs-keyword\">return</span>;\n    <span class=\"hljs-keyword\">if</span> (!children || children.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span>;\n    <span class=\"hljs-keyword\">const</span> keyDescriptors = [\n      <span class=\"hljs-string\">'o:encodings'</span>, <span class=\"hljs-string\">'o:scales'</span>, <span class=\"hljs-string\">'o:guides'</span>, <span class=\"hljs-string\">'o:styles'</span>,\n      <span class=\"hljs-string\">'a:coordinates'</span>, <span class=\"hljs-string\">'a:statistics'</span>, <span class=\"hljs-string\">'a:transforms'</span>, <span class=\"hljs-string\">'a:data'</span>,\n    ];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> child <span class=\"hljs-keyword\">of</span> children) {\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> descriptor <span class=\"hljs-keyword\">of</span> keyDescriptors) {\n        <span class=\"hljs-keyword\">const</span> [type, key] = descriptor.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">':'</span>);\n        <span class=\"hljs-keyword\">if</span> (type === <span class=\"hljs-string\">'o'</span>) {\n          child[key] = { ...options[key], ...child[key] };\n        } <span class=\"hljs-keyword\">else</span> {\n          child[key] = child[key] || options[key];\n        }\n      }\n    }\n  });\n}\n</code></pre>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/plot/plot.js</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isChartNode</span>(<span class=\"hljs-params\">type</span>) {\n  <span class=\"hljs-keyword\">switch</span> (type) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'layer'</span>: <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'col'</span>: <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'row'</span>: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-attr\">default</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n  }\n}\n</code></pre>\n<h2 data-id=\"heading-3\">plotView</h2>\n<p>接下来我们来看看 plotView 函数，该函数是真正把图表渲染出来的地方。</p>\n<p>在这个流程中有两个函数比较关键：第一个就是 <code>initialize</code> 函数，这是获取每个几何图形通道值的地方；第二就是 <code>inferScales</code> 这个函数，这是给每个通道选择比例尺的地方，只要比例尺选择对了，那么绘制的几何图形就基本上没有问题了。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/plot/plot.js</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">plotView</span>(<span class=\"hljs-params\">{\n  renderer,\n  scales: scalesOptions,\n  guides: guidesOptions,\n  coordinates: coordinateOptions,\n  geometries: geometriesOptions,\n  width, height, x, y,\n  paddingLeft = <span class=\"hljs-number\">45</span>, paddingRight = <span class=\"hljs-number\">45</span>, paddingBottom = <span class=\"hljs-number\">45</span>, paddingTop = <span class=\"hljs-number\">60</span>,\n}</span>) {\n  <span class=\"hljs-comment\">// 获得每个通道的值</span>\n  <span class=\"hljs-keyword\">const</span> geometries = geometriesOptions.<span class=\"hljs-title function_\">map</span>(initialize);\n  <span class=\"hljs-keyword\">const</span> channels = geometries.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">channels</span>);\n  \n  <span class=\"hljs-comment\">// 推断 scales 和 guides</span>\n  <span class=\"hljs-keyword\">const</span> scaleDescriptors = <span class=\"hljs-title function_\">inferScales</span>(channels, scalesOptions);\n  <span class=\"hljs-keyword\">const</span> guidesDescriptors = <span class=\"hljs-title function_\">inferGuides</span>(scaleDescriptors, { x, y, paddingLeft }, guidesOptions);\n\n  <span class=\"hljs-comment\">// 生成 scales 和 guides</span>\n  <span class=\"hljs-keyword\">const</span> scales = <span class=\"hljs-title function_\">map</span>(scaleDescriptors, create);\n  <span class=\"hljs-keyword\">const</span> guides = <span class=\"hljs-title function_\">map</span>(guidesDescriptors, create);\n\n  <span class=\"hljs-comment\">// 生成坐标系</span>\n  <span class=\"hljs-keyword\">const</span> transforms = <span class=\"hljs-title function_\">inferCoordinates</span>(coordinateOptions).<span class=\"hljs-title function_\">map</span>(create);\n  <span class=\"hljs-keyword\">const</span> coordinate = <span class=\"hljs-title function_\">createCoordinate</span>({\n    <span class=\"hljs-attr\">x</span>: x + paddingLeft,\n    <span class=\"hljs-attr\">y</span>: y + paddingTop,\n    <span class=\"hljs-attr\">width</span>: width - paddingLeft - paddingRight,\n    <span class=\"hljs-attr\">height</span>: height - paddingTop - paddingBottom,\n    transforms,\n  });\n\n  <span class=\"hljs-comment\">// 绘制辅助组件</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, guide] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(guides)) {\n    <span class=\"hljs-keyword\">const</span> scale = scales[key];\n    <span class=\"hljs-title function_\">guide</span>(renderer, scale, coordinate);\n  }\n\n  <span class=\"hljs-comment\">// 绘制几何元素</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> { index, geometry, channels, styles } <span class=\"hljs-keyword\">of</span> geometries) {\n    <span class=\"hljs-keyword\">const</span> values = <span class=\"hljs-title function_\">applyScales</span>(channels, scales);\n    <span class=\"hljs-title function_\">geometry</span>(renderer, index, scales, values, styles, coordinate);\n  }\n}\n</code></pre>\n<p>那么接下来我们就一起来看看 <code>initialize</code> 和 <code>inferScales</code> 这两个函数。</p>\n<h2 data-id=\"heading-4\">initialize</h2>\n<p><code>initialize</code> 主要流程代码如下，具体的实现可以参考注释。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/plot/geometry.js</span>\n\n<span class=\"hljs-keyword\">import</span> { compose, indexOf } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n<span class=\"hljs-keyword\">import</span> { inferEncodings, valueOf } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./encoding'</span>;\n<span class=\"hljs-keyword\">import</span> { create } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./create'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">initialize</span>(<span class=\"hljs-params\">{\n  data,\n  type,\n  encodings: E = {},\n  statistics: statisticsOptions = [],\n  transforms: transformsOptions = [],\n  styles,\n}</span>) {\n  <span class=\"hljs-comment\">// 执行 transform</span>\n  <span class=\"hljs-comment\">// 把所有的 transform 都合成一个函数</span>\n  <span class=\"hljs-keyword\">const</span> transform = <span class=\"hljs-title function_\">compose</span>(...transformsOptions.<span class=\"hljs-title function_\">map</span>(create));\n  <span class=\"hljs-keyword\">const</span> transformedData = <span class=\"hljs-title function_\">transform</span>(data);\n  <span class=\"hljs-keyword\">const</span> index = <span class=\"hljs-title function_\">indexOf</span>(transformedData);\n\n  <span class=\"hljs-comment\">// 执行 valueOf</span>\n  <span class=\"hljs-comment\">// 从表格数据里面提取各个通道的值</span>\n  <span class=\"hljs-keyword\">const</span> encodings = <span class=\"hljs-title function_\">inferEncodings</span>(type, transformedData, E);\n  <span class=\"hljs-keyword\">const</span> constants = {};\n  <span class=\"hljs-keyword\">const</span> values = {};\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, e] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(encodings)) {\n    <span class=\"hljs-keyword\">if</span> (e) {\n      <span class=\"hljs-keyword\">const</span> { type, value } = e;\n      <span class=\"hljs-keyword\">if</span> (type === <span class=\"hljs-string\">'constant'</span>) constants[key] = value;\n      <span class=\"hljs-keyword\">else</span> values[key] = <span class=\"hljs-title function_\">valueOf</span>(transformedData, e);\n    }\n  }\n\n  <span class=\"hljs-comment\">// 执行 statistics</span>\n  <span class=\"hljs-comment\">// 把所有的 statistics 都合成一个函数</span>\n  <span class=\"hljs-keyword\">const</span> statistic = <span class=\"hljs-title function_\">compose</span>(...statisticsOptions.<span class=\"hljs-title function_\">map</span>(create));\n  <span class=\"hljs-keyword\">const</span> { <span class=\"hljs-attr\">values</span>: transformedValues, <span class=\"hljs-attr\">index</span>: I } = <span class=\"hljs-title function_\">statistic</span>({ index, values });\n\n  <span class=\"hljs-comment\">// 创建通道</span>\n  <span class=\"hljs-keyword\">const</span> geometry = <span class=\"hljs-title function_\">create</span>({ type });\n  <span class=\"hljs-keyword\">const</span> channels = {};\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, channel] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(geometry.<span class=\"hljs-title function_\">channels</span>())) {\n    <span class=\"hljs-keyword\">const</span> values = transformedValues[key];\n    <span class=\"hljs-keyword\">const</span> { optional } = channel;\n    <span class=\"hljs-keyword\">if</span> (values) {\n      channels[key] = <span class=\"hljs-title function_\">createChannel</span>(channel, values, encodings[key]);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!optional) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`Missing values for channel:<span class=\"hljs-subst\">${key}</span>`</span>);\n    }\n  }\n\n  <span class=\"hljs-comment\">// 返回处理好数据</span>\n  <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">index</span>: I, geometry, channels, <span class=\"hljs-attr\">styles</span>: { ...styles, ...constants } };\n}\n</code></pre>\n<p>其中比较关键的函数之一是 <code>inferEncodings</code>这个函数，这个函数一方面会推断出我们编码的种类，一方面会补全我们的编码信息。下面我们将通过两个例子来说明。</p>\n<p>首先我们来看看对编码种类的推断。编码本质上也是一个函数，从数据里面提取一列数据。在 Sparrow 里面的编码有三种类型：</p>\n<ul>\n<li>field：从数据中提取对应字段的值。</li>\n<li>transform：对数据的每一条数据进行转换获得一列值。</li>\n<li>value：返回一个常量数组。</li>\n</ul>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/plot/encoding</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">valueOf</span>(<span class=\"hljs-params\">data, { type, value }</span>) {\n  <span class=\"hljs-keyword\">if</span> (type === <span class=\"hljs-string\">'transform'</span>) <span class=\"hljs-keyword\">return</span> data.<span class=\"hljs-title function_\">map</span>(value); <span class=\"hljs-comment\">// transform encoding</span>\n  <span class=\"hljs-keyword\">if</span> (type === <span class=\"hljs-string\">'value'</span>) <span class=\"hljs-keyword\">return</span> data.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">() =&gt;</span> value); <span class=\"hljs-comment\">// value encoding</span>\n  <span class=\"hljs-keyword\">return</span> data.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d[value]); <span class=\"hljs-comment\">// field encoding</span>\n}\n</code></pre>\n<p>具体参考下面这个例子，最后的效果如下图。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> sports = [\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Sports'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">275</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Strategy'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">115</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Action'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">120</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Shooter'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">350</span> },\n  { <span class=\"hljs-attr\">genre</span>: <span class=\"hljs-string\">'Other'</span>, <span class=\"hljs-attr\">sold</span>: <span class=\"hljs-number\">150</span> },\n];\n\n<span class=\"hljs-keyword\">const</span> options = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'interval'</span>,\n  <span class=\"hljs-attr\">data</span>: sports,\n  <span class=\"hljs-attr\">encodings</span>: {\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">'genre'</span>, <span class=\"hljs-comment\">// field encoding</span>\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">d</span> =&gt;</span> d.<span class=\"hljs-property\">sold</span> * <span class=\"hljs-number\">2</span>, <span class=\"hljs-comment\">// transform encoding</span>\n    <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">'steelblue'</span> <span class=\"hljs-comment\">// value encoding</span>\n  },\n}\n</code></pre>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8804cd5b459a45468015ee2465e755bd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>具体的推断方法可以查看<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Fblob%2Fmain%2Fsrc%2Fplot%2Fencoding.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/blob/main/src/plot/encoding.js\" ref=\"nofollow noopener noreferrer\">这里</a>的 <code>inferType</code> 函数。</p>\n<p>接下来我们来看看补全编码信息。在上面绘制条形图的时候，我们对图表的描述如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> options = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'interval'</span>,\n  <span class=\"hljs-attr\">data</span>: sports,\n  <span class=\"hljs-attr\">encodings</span>: {\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">'genre'</span>,\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">'sold'</span>,\n  },\n}\n</code></pre>\n<p>可以发现在描述中我们是希望通过一个 interval 去可视化数据，并且指定了 interval 的 x 和 y 通道，但是 interval 的 y1 通道却没有指定！这个时候我们就需将这个 y1 通道的编码信息推断出来，最后的结果等于下面的图表描述：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> options = {\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'interval'</span>,\n  <span class=\"hljs-attr\">data</span>: sports,\n  <span class=\"hljs-attr\">encodings</span>: {\n    <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">'genre'</span>,\n    <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">'sold'</span>,\n    <span class=\"hljs-attr\">y1</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-comment\">// 推断出来 y1 为 0</span>\n  },\n}\n</code></pre>\n<p>不同的几何图形有不同的推断规则，具体可以查看<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Fblob%2Fmain%2Fsrc%2Fplot%2Fencoding.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/blob/main/src/plot/encoding.js\" ref=\"nofollow noopener noreferrer\">这里</a>的 <code>inferEncodings</code> 函数。</p>\n<h2 data-id=\"heading-5\">inferScales</h2>\n<p>了解了 <code>initialize</code> 函数，我们接下来看看 <code>inferScales</code>，<strong>这个函数可以说是整个渲染流程的灵魂</strong>。因为通过前面的学习我们了解到：可视化就是一个数据到图形的过程，而从数据属性到视觉属性需要比例尺去映射。</p>\n<p>创建比例尺是一个比较难以理解和麻烦的过程，是使用 D3 等底层可视化组件的过程中需要考虑的问题。但是对于上层可视化框架来说，这部分是要自动完成的的。</p>\n<p>而比例尺的创建无非就三个步骤：</p>\n<ul>\n<li>确定比例尺类型</li>\n<li>确定值域</li>\n<li>确定定义域</li>\n</ul>\n<p>具体的实现如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/plot/scale.js</span>\n\n<span class=\"hljs-keyword\">import</span> { firstOf, group, lastOf, map, defined } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../utils'</span>;\n<span class=\"hljs-keyword\">import</span> { interpolateColor, interpolateNumber } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'../scale'</span>;\n<span class=\"hljs-keyword\">import</span> { categoricalColors, ordinalColors } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./theme'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inferScales</span>(<span class=\"hljs-params\">channels, options</span>) {\n  <span class=\"hljs-keyword\">const</span> scaleChannels = <span class=\"hljs-title function_\">group</span>(channels.<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\">entries</span>), <span class=\"hljs-function\">(<span class=\"hljs-params\">[name]</span>) =&gt;</span> <span class=\"hljs-title function_\">scaleName</span>(name));\n  <span class=\"hljs-keyword\">const</span> scales = {};\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [name, channels] <span class=\"hljs-keyword\">of</span> scaleChannels) {\n    <span class=\"hljs-keyword\">const</span> channel = <span class=\"hljs-title function_\">mergeChannels</span>(name, channels);\n    <span class=\"hljs-keyword\">const</span> o = options[name] || {};\n    <span class=\"hljs-keyword\">const</span> type = <span class=\"hljs-title function_\">inferScaleType</span>(channel, o); <span class=\"hljs-comment\">// 推断种类</span>\n    scales[name] = {\n      ...o,\n      ...<span class=\"hljs-title function_\">inferScaleOptions</span>(type, channel, o),\n      <span class=\"hljs-attr\">domain</span>: <span class=\"hljs-title function_\">inferScaleDomain</span>(type, channel, o), <span class=\"hljs-comment\">// 推断定义域</span>\n      <span class=\"hljs-attr\">range</span>: <span class=\"hljs-title function_\">inferScaleRange</span>(type, channel, o), <span class=\"hljs-comment\">// 推断值域</span>\n      <span class=\"hljs-attr\">label</span>: <span class=\"hljs-title function_\">inferScaleLabel</span>(type, channel, o), \n      type,\n    };\n  }\n  <span class=\"hljs-keyword\">return</span> scales;\n}\n</code></pre>\n<p>推断比例尺最核心的就是推断比例尺的类型，这里参考 [Observable Plot](<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fobservablehq%2Fplot%2Fblob%2Fmain%2Fsrc%2Fscales.j\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/observablehq/plot/blob/main/src/scales.j\" ref=\"nofollow noopener noreferrer\">github.com/observableh…</a> s) 里面的推断方法，具体的实现如下。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// src/plot/scale.js</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inferScaleType</span>(<span class=\"hljs-params\">channel, options</span>) {\n  <span class=\"hljs-keyword\">const</span> { name, scale, values } = channel; <span class=\"hljs-comment\">// 当前通道信息</span>\n  <span class=\"hljs-keyword\">const</span> { type, domain, range } = options; <span class=\"hljs-comment\">// options.scales 里面的配置</span>\n  \n  <span class=\"hljs-comment\">// 如果通道本身有默认的 scale 种类就是返回当前的种类</span>\n  <span class=\"hljs-comment\">// 比如 interval 的 x 的 scale 就是 band</span>\n  <span class=\"hljs-keyword\">if</span> (scale) <span class=\"hljs-keyword\">return</span> scale;\n  \n  <span class=\"hljs-comment\">// 如果用户在配置中声明了 type 就返回当前 type</span>\n  <span class=\"hljs-comment\">// 比如 scales: { type: log }</span>\n  <span class=\"hljs-keyword\">if</span> (type) <span class=\"hljs-keyword\">return</span> type;\n  \n  <span class=\"hljs-comment\">// 如果配置中的 range 或者 domain 的长度大于了 2 就说明是离散比例尺</span>\n  <span class=\"hljs-comment\">// 比如 scales: {fill: {range: ['red', 'yellow', 'green']}}</span>\n  <span class=\"hljs-keyword\">if</span> ((domain || range || []).<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">asOrdinalType</span>(name);\n  \n  <span class=\"hljs-comment\">// 根据配置中 domain 的数据类型决定 scale 的种类</span>\n  <span class=\"hljs-keyword\">if</span> (domain !== <span class=\"hljs-literal\">undefined</span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isOrdinal</span>(domain)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">asOrdinalType</span>(name);\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isTemporal</span>(domain)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'time'</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'linear'</span>;\n  }\n  \n  <span class=\"hljs-comment\">// 根据 channel 对应的 values 决定 scale 的种类</span>\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isOrdinal</span>(values)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">asOrdinalType</span>(name);\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isTemporal</span>(values)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'time'</span>;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isUnique</span>(values)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'identity'</span>;\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'linear'</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">asOrdinalType</span>(<span class=\"hljs-params\">name</span>) {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isPosition</span>(name)) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'dot'</span>; <span class=\"hljs-comment\">// 就是 point 比例尺</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'ordinal'</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isPosition</span>(<span class=\"hljs-params\">name</span>) {\n  <span class=\"hljs-keyword\">return</span> name === <span class=\"hljs-string\">'x'</span> || name === <span class=\"hljs-string\">'y'</span>;\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isOrdinal</span>(<span class=\"hljs-params\">values</span>) {\n  <span class=\"hljs-keyword\">return</span> values.<span class=\"hljs-title function_\">some</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> type = <span class=\"hljs-keyword\">typeof</span> v;\n    <span class=\"hljs-keyword\">return</span> type === <span class=\"hljs-string\">'string'</span> || type === <span class=\"hljs-string\">'value'</span>;\n  });\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isTemporal</span>(<span class=\"hljs-params\">values</span>) {\n  <span class=\"hljs-keyword\">return</span> values.<span class=\"hljs-title function_\">some</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">v</span>) =&gt;</span> v <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">Date</span>);\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">isUnique</span>(<span class=\"hljs-params\">values</span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(values)).<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">1</span>;\n}\n</code></pre>\n<p>本章的渲染流程比较重要的代码就在这里介绍完了，完整的代码可以在<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2Fsrc%2Fplot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/src/plot\" ref=\"nofollow noopener noreferrer\">这里</a>浏览，同样也可以通过<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Ftree%2Fmain%2F__tests__%2Fplot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/tree/main/__tests__/plot\" ref=\"nofollow noopener noreferrer\">这里</a>的测试代码来验证代码的正确性。</p>\n<h2 data-id=\"heading-6\">小结</h2>\n<p>到目前为止，我们的 Sparrow 就全部开发完成了，没有借助任何依赖，不到 2000 行代码，可以绘制出平时使用的 80% 的图表（具体的图表可以参考<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fsparrow%2Fblob%2Fmain%2F__tests__%2Fplot%2Fplot.spec.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/sparrow/blob/main/__tests__/plot/plot.spec.js\" ref=\"nofollow noopener noreferrer\">这里</a>的测试代码），是不是很有成就感？（发布我们的图表库到 NPM 可以参考这篇<a href=\"https://juejin.cn/post/7052307032971411463\" target=\"_blank\" title=\"https://juejin.cn/post/7052307032971411463\">文章</a>）</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/879e056ccea346e1bca703561b752506~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>在实战部分，我们从渲染引擎开始，到一个个低级可视化绘制模块，最后再到本章的 Plot 模块的开发。这个过程我们不仅了解了更多可视化概念，这了解了一些编程方面的知识（比如函数式编程等）。</p>\n<p>实战完了接下来就进入我们的分析环节，看看用我们的 Sparrow 能否回答之前提出的问题！</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "14\n分析：表格带你浅尝数据分析\n学习时长: 21分17秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>从这一章开始我们将进入分析部分，这部分我们将用 Sparrow 去可视化数据，去解决下面提出的问题：</p>\n<ol>\n<li>揭露中世纪是一个压抑的时代。（展现时代和哲学家数量的相关性和异常值）。</li>\n<li>证明哲学家谈论的都是一些永恒的问题。（展现哲学家观点的特征）。</li>\n<li>哲学家，哲学问题和流派的数量关系是怎样的？（展现哲学家，哲学问题和流派的数量的特征）。</li>\n<li>哲学问题，哲学家和流派的数量随着时间是如何变化的？（探索哲学问题，哲学家，流派的数量的趋势，以及它们和时间的依赖关系）。</li>\n<li>有多少哲学家的寿命超过了40岁，其中年龄最大和最小分别是多少？（探索哲学家寿命的分布和极值）。</li>\n<li>每个哲学家回答了哪些问题？每个问题有哪些哲学家回答了？哲学家和问题之间的关系又如何？（探索哲学家和问题——网络数据之间的拓扑结构）。</li>\n<li>每个流派有哪些哲学家？哪个流派的哲学家比较多？哪个比较少？（探索哲学家和流派——网络数据之间的拓扑结构）。</li>\n<li>哲学的中心是怎么变化的的？（哲学家聚集地点——几何数据的形状）。</li>\n</ol>\n<p>一般来说，在真正设计我们的可视化之前，我们大概看一下数据，然后再确定可视化设计。了解数据最基础的手段就是通过表格，那么这一章我们就用表格先去了解一下 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fvisualize-sophie-world%2Fblob%2Fmain%2Fdata%2Fphilosophers.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/visualize-sophie-world/blob/main/data/philosophers.json\" ref=\"nofollow noopener noreferrer\">philosophers.json</a> 这份数据。</p>\n<h2 data-id=\"heading-0\">Sparrow</h2>\n<p>首先我们用我们的 Sparrow 去绘制表格，这里的思路就是用 Text 几何元素去绘制。具体的代码和效果如下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\">(<span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-comment\">// 获得数据</span>\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/d345d2d7-a35d-4d27-af92-4982b3e6b213.json\"</span>\n  );\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n  \n  <span class=\"hljs-comment\">// 行头</span>\n  <span class=\"hljs-keyword\">const</span> keys = [<span class=\"hljs-string\">\"id\"</span>, <span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"country\"</span>, <span class=\"hljs-string\">\"lifespan\"</span>, <span class=\"hljs-string\">\"points\"</span>];\n  \n  <span class=\"hljs-keyword\">return</span> sp.<span class=\"hljs-title function_\">plot</span>({\n    data,\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"layer\"</span>,\n    <span class=\"hljs-attr\">transforms</span>: [\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> data.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">_, i</span>) =&gt;</span> i &lt; <span class=\"hljs-number\">10</span>),\n      <span class=\"hljs-comment\">// 预处理数据</span>\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span>\n        data.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ lifespan, points, ...rest }</span>) =&gt;</span> ({\n          ...rest,\n          <span class=\"hljs-attr\">lifespan</span>: <span class=\"hljs-string\">`[<span class=\"hljs-subst\">${lifespan[<span class=\"hljs-number\">0</span>]}</span>, <span class=\"hljs-subst\">${lifespan[<span class=\"hljs-number\">1</span>]}</span>]`</span>,\n          <span class=\"hljs-attr\">points</span>: <span class=\"hljs-string\">`[<span class=\"hljs-subst\">${points\n            .slice(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>)\n            .map((d) =&gt; d.slice(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>) + <span class=\"hljs-string\">\"...\"</span>)\n            .join(<span class=\"hljs-string\">\", \"</span>)}</span>]`</span>,\n        })),\n      <span class=\"hljs-comment\">// 转换成一系列文本</span>\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> {\n        <span class=\"hljs-keyword\">const</span> ths = [<span class=\"hljs-string\">\"index\"</span>, ...keys].<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> ({\n          <span class=\"hljs-attr\">index</span>: -<span class=\"hljs-number\">1</span>,\n          key,\n          <span class=\"hljs-attr\">value</span>: key,\n          <span class=\"hljs-attr\">header</span>: <span class=\"hljs-literal\">true</span>,\n        }));\n        <span class=\"hljs-keyword\">const</span> tds = data.<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d, i</span>) =&gt;</span> {\n          <span class=\"hljs-keyword\">const</span> cell = keys.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> ({ <span class=\"hljs-attr\">index</span>: i, key, <span class=\"hljs-attr\">value</span>: d[key] }));\n          <span class=\"hljs-keyword\">return</span> [...cell, { <span class=\"hljs-attr\">index</span>: i, <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">\"index\"</span>, <span class=\"hljs-attr\">value</span>: i }];\n        });\n        <span class=\"hljs-keyword\">return</span> [...ths, ...tds].<span class=\"hljs-title function_\">reverse</span>();\n      },\n    ],\n    <span class=\"hljs-attr\">scales</span>: {\n      <span class=\"hljs-attr\">y</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"band\"</span>, <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-number\">0</span> },\n      <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-string\">\"index\"</span>, ...keys], <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-number\">0</span> },\n      <span class=\"hljs-attr\">fontWeight</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"identity\"</span> },\n    },\n    <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">900</span>,\n    <span class=\"hljs-attr\">guides</span>: {\n      <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> },\n      <span class=\"hljs-attr\">y</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> },\n    },\n    <span class=\"hljs-attr\">encodings</span>: {\n      <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">\"index\"</span>,\n      <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">\"key\"</span>,\n    },\n    <span class=\"hljs-attr\">children</span>: [\n      { <span class=\"hljs-comment\">// 背景的表格</span>\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"cell\"</span>,\n        <span class=\"hljs-attr\">encodings</span>: {\n          <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"none\"</span>,\n          <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"#eee\"</span>,\n        },\n      },\n      { <span class=\"hljs-comment\">// 前面的文字</span>\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"text\"</span>,\n        <span class=\"hljs-attr\">paddingTop</span>: <span class=\"hljs-number\">10</span>,\n        <span class=\"hljs-attr\">paddingLeft</span>: <span class=\"hljs-number\">10</span>,\n        <span class=\"hljs-attr\">paddingBottom</span>: <span class=\"hljs-number\">10</span>,\n        <span class=\"hljs-attr\">encodings</span>: {\n          <span class=\"hljs-attr\">text</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> (d.<span class=\"hljs-property\">header</span> ? d.<span class=\"hljs-property\">value</span>.<span class=\"hljs-title function_\">toUpperCase</span>() : d.<span class=\"hljs-property\">value</span>),\n          <span class=\"hljs-attr\">fontWeight</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> (d.<span class=\"hljs-property\">header</span> ? <span class=\"hljs-string\">\"bold\"</span> : <span class=\"hljs-string\">\"normal\"</span>),\n        },\n        <span class=\"hljs-attr\">styles</span>: {\n          <span class=\"hljs-attr\">dx</span>: <span class=\"hljs-string\">\"0.5em\"</span>,\n          <span class=\"hljs-attr\">dy</span>: <span class=\"hljs-string\">\"-1em\"</span>,\n        },\n      },\n    ],\n  });\n})();\n</code></pre>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/826a4322fd0349f29a7e989e986f9e55~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\">\n可以发现 Sparrow 确实也可以绘制简单的表格，但是也存在不少问题：</p>\n<ul>\n<li>容器高度不能根据行数自适应，所以只能绘制少部分数据。</li>\n<li>不具有交互功能：不能改变每个行或者列的占比。</li>\n<li>绘制交叉表会比较麻烦，只适合绘制非嵌套的数据。</li>\n</ul>\n<p>那么接下来我们就试试 AntV 的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fs2.antv.vision%2Fzh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://s2.antv.vision/zh\" ref=\"nofollow noopener noreferrer\">S2</a>，去绘制相同的数据，并且<strong>找出哲学家观点关键词的信息洞察</strong>。</p>\n<h2 data-id=\"heading-1\">任务分析</h2>\n<p>我们先来分析一下“找出哲学家观点关键词的信息洞察” 这个任务。</p>\n<p>这个任务需要分析哲学和问题之间的关系，分成几步：</p>\n<ul>\n<li>罗列出哲学家信息和观点，然后将观点进行分词，获得所有关键词以及出现频次，获得要分析的数据。</li>\n<li>基于原生数据进行基本数据分析，确定数据间的基本关联关系。</li>\n<li>使用表可视化分析引擎 [S2] 绘制多维分析表。</li>\n<li>为了更加直观看出哲学家思考方向的差异性，我们使用不同背景颜色表现哲学家关键词的权重占比。</li>\n<li>获取数据洞察。</li>\n</ul>\n<h2 data-id=\"heading-2\">可视分析</h2>\n<h3 data-id=\"heading-3\">数据处理</h3>\n<p>首先我们处理一下 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fvisualize-sophie-world%2Fblob%2Fmain%2Fdata%2Fphilosophers.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/visualize-sophie-world/blob/main/data/philosophers.json\" ref=\"nofollow noopener noreferrer\">philosophers.json</a> 这里的数据，获取所有哲学家的观点列表，以及观点中的关键字所占词频，然后使用社区开源的&nbsp;<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fnodejieba\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://www.npmjs.com/package/nodejieba\" ref=\"nofollow noopener noreferrer\">nodejieba</a>&nbsp;进行关键词抽取。</p>\n<h3 data-id=\"heading-4\">数据分析</h3>\n<p>在进行数据分析之前，我们先来了解几个简单的基本概念：</p>\n<ul>\n<li>度量（指标）：数值本身，比如价格、数量等。</li>\n<li>维度：可以理解为分析数据的角度，比如省份、类型等。</li>\n</ul>\n<p>通过观察一条样例数据，我们可以得到「国家」、「姓名」、「出生年份」、 「逝世年份」、 「观点」、「关键词」六个维度，以及关键词 「权重」这个指标。我们可以根据「国家」将哲学家进行分组，而每个哲学家提出的观点又可以按照 「关键词」进行拆分，每个关键词用 「权重」数据去描述。这样一来我们就可以按照以下看数思路进行分析：</p>\n<ul>\n<li>查看一个国家有哪些哲学家</li>\n<li>每个哲学家的基本信息有哪些</li>\n<li>哲学家分别提出了怎样的观点</li>\n<li>每个观点对应的关键词有哪些</li>\n</ul>\n<h3 data-id=\"heading-5\">用 S2 绘制多维分析表</h3>\n<p>在绘制多维分析表之前，我们需要了解 S2 是怎么绘制多维分析表的。S2 是数据驱动的表可视分析引擎。通过 <code>schema</code> 指定行列维度和指标的位置，结合配置项设置相关分析属性，将明细数据和行列维度关联起来。从代码层面来反应整体分为三步：</p>\n<ol>\n<li>数据准备</li>\n<li>配置项准备</li>\n<li>渲染</li>\n</ol>\n<h4 data-id=\"heading-6\">1、数据准备</h4>\n<ul>\n<li>首先将原始数据按照「关键词」维度进行拆分，将数据打平，得到如下 S2 可以直接消费的明细数据：\n(<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgw.alipayobjects.com%2Fos%2Fbmw-prod%2F24cac0f7-70f0-4131-be61-df11da3ca921.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://gw.alipayobjects.com/os/bmw-prod/24cac0f7-70f0-4131-be61-df11da3ca921.json\" ref=\"nofollow noopener noreferrer\">全量数据</a>)</li>\n</ul>\n<pre><code class=\"hljs language-json\" lang=\"json\"><span class=\"hljs-punctuation\">[</span>\n    <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">\"points\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"水是万物之源。\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"name\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"泰利斯\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"country\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"希腊\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"word\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"水是\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"weight\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">11.739204307083542</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"start\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">-624</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"end\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">-546</span>\n   <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n   <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">\"points\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"水是万物之源。\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"name\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"泰利斯\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"country\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"希腊\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"word\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"万物\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"weight\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">7.75434839431</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"start\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">-624</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"end\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">-546</span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">\"points\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"水是万物之源。\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"name\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"泰利斯\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"country\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"希腊\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"word\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"之源\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"weight\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">9.23723855786</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"start\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">-624</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"end\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">-546</span>\n  <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  ...\n」\n</code></pre>\n<ul>\n<li>将维度按照数据分析确定的维度顺序依次放置在行维度位置，并指定「频率」为指标。</li>\n</ul>\n<pre><code class=\"hljs language-kotlin\" lang=\"kotlin\"><span class=\"hljs-keyword\">const</span> s2DataConfig = { \n  fields: { <span class=\"hljs-comment\">// 维度指标配置项\t</span>\n    rows: [<span class=\"hljs-string\">'country'</span>, <span class=\"hljs-string\">'name'</span>, <span class=\"hljs-string\">'start'</span>, <span class=\"hljs-string\">'end'</span>, <span class=\"hljs-string\">'points'</span>, <span class=\"hljs-string\">'word'</span>], <span class=\"hljs-comment\">// 行头</span>\n    columns: [], <span class=\"hljs-comment\">// 列头</span>\n    values: [<span class=\"hljs-string\">'weight'</span>], <span class=\"hljs-comment\">// 数值</span>\n  },\n  meta: [ <span class=\"hljs-comment\">// 对各个维度指标进行别名、格式化配置</span>\n    {\n      field: <span class=\"hljs-string\">'word'</span>,  <span class=\"hljs-comment\">// 维度</span>\n      name: <span class=\"hljs-string\">'关键词'</span>,  <span class=\"hljs-comment\">// 别名</span>\n    },\n    {\n      field: <span class=\"hljs-string\">'points'</span>,\n      name: <span class=\"hljs-string\">'观点'</span>,\n    },\n    {\n      field: <span class=\"hljs-string\">'name'</span>,\n      name: <span class=\"hljs-string\">'姓名'</span>,\n    },\n    {\n      field: <span class=\"hljs-string\">'country'</span>,\n      name: <span class=\"hljs-string\">'国家'</span>,\n    },\n    {\n      field: <span class=\"hljs-string\">'start'</span>,\n      name: <span class=\"hljs-string\">'出生'</span>,\n      formatter: getFormatter, <span class=\"hljs-comment\">// 格式化方法</span>\n    },\n    {\n      field: <span class=\"hljs-string\">'end'</span>,\n      name: <span class=\"hljs-string\">'逝世'</span>,\n      formatter: getFormatter,\n    },\n    {\n      field: <span class=\"hljs-string\">'weight'</span>,\n      name: <span class=\"hljs-string\">'权重'</span>,\n      formatter: (<span class=\"hljs-keyword\">val</span>) =&gt; <span class=\"hljs-keyword\">val</span>.toFixed(<span class=\"hljs-number\">2</span>),\n    },\n  ],\n  <span class=\"hljs-keyword\">data</span>, <span class=\"hljs-comment\">// 可从 GitHub 中下载</span>\n};\n\n<span class=\"hljs-keyword\">const</span> getFormatter = (<span class=\"hljs-keyword\">val</span>) =&gt; {\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">val</span> &lt; <span class=\"hljs-number\">0</span>) {\n    <span class=\"hljs-keyword\">return</span> `公元前${replace(<span class=\"hljs-keyword\">val</span>, <span class=\"hljs-string\">'-'</span>, <span class=\"hljs-string\">''</span>)}年`;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> `${<span class=\"hljs-keyword\">val</span>}年`;\n  }\n};\n</code></pre>\n<h3 data-id=\"heading-7\">2. 配置项准备</h3>\n<p>这一步除了基本表体展示交互相关的基础配置项，主要做的就是文本和单元格背景颜色通道映射的配置。\n首先准备一个色板如下：</p>\n<pre><code class=\"hljs language-JSON\" lang=\"JSON\">const PALETTE_COLORS = <span class=\"hljs-punctuation\">[</span>\n  '#B8E1FF'<span class=\"hljs-punctuation\">,</span>\n  '#<span class=\"hljs-number\">9</span>AC5FF'<span class=\"hljs-punctuation\">,</span>\n  '#<span class=\"hljs-number\">7</span>DAAFF'<span class=\"hljs-punctuation\">,</span>\n  '#<span class=\"hljs-number\">5</span>B8FF9'<span class=\"hljs-punctuation\">,</span>\n  '#<span class=\"hljs-number\">3</span>D76DD'<span class=\"hljs-punctuation\">,</span>\n  '#<span class=\"hljs-number\">085</span>EC0'<span class=\"hljs-punctuation\">,</span>\n  '#<span class=\"hljs-number\">0047</span>A5'<span class=\"hljs-punctuation\">,</span>\n  '#<span class=\"hljs-number\">00318</span>A'<span class=\"hljs-punctuation\">,</span>\n  '#<span class=\"hljs-number\">001</span>D70'<span class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-punctuation\">]</span>;\n</code></pre>\n<p>计算得到该组数据的最大最小值：</p>\n<pre><code class=\"hljs language-JSON\" lang=\"JSON\">import <span class=\"hljs-punctuation\">{</span> max<span class=\"hljs-punctuation\">,</span> min<span class=\"hljs-punctuation\">}</span> from 'lodash';\n\nconst weights = data.map((item) =&gt; item.weight);\nconst maxWeight = max(weights);\nconst minWeight = min(weights);\nconst weightSpan = maxWeight - minWeight;\n</code></pre>\n<p>将数值区间和颜色区间进行关联，并将权重数值映射到对应颜色区间：</p>\n<pre><code class=\"hljs language-scss\" lang=\"scss\">const s2Options = {\n  <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-string\">''</span>,\n  height: <span class=\"hljs-number\">400</span>,\n  conditions: { <span class=\"hljs-comment\">// 字段标记</span>\n    text: [ // 权重（weight）大于 <span class=\"hljs-number\">20</span> 的数值展示为白色\n      {\n        field: <span class=\"hljs-string\">'weight'</span>,\n        mapping(value) {\n          if (value &gt;= <span class=\"hljs-number\">20</span>) { \n            return {\n              fill: <span class=\"hljs-string\">'#fff'</span>,\n            };\n          }\n        },\n      },\n    ],\n    <span class=\"hljs-attribute\">background</span>: [ // 权重（weight）在不同的范围，展示不同的背景色\n      {\n        field: <span class=\"hljs-string\">'weight'</span>,\n        mapping(value) {\n          let backgroundColor;\n          const colorIndex =\n                Math<span class=\"hljs-selector-class\">.floor</span>(\n                  (((value - minWeight) / weightSpan) * <span class=\"hljs-number\">100</span>) /\n                  PALETTE_COLORS<span class=\"hljs-selector-class\">.length</span>,\n                ) - <span class=\"hljs-number\">1</span>;\n          if (colorIndex &lt;= <span class=\"hljs-number\">0</span>) {\n            backgroundColor = PALETTE_COLORS<span class=\"hljs-selector-attr\">[0]</span>;\n          } else if (colorIndex &gt;= PALETTE_COLORS.length) {\n            backgroundColor = PALETTE_COLORS<span class=\"hljs-selector-attr\">[PALETTE_COLORS.length - 1]</span>;\n          } else {\n            backgroundColor = PALETTE_COLORS<span class=\"hljs-selector-attr\">[colorIndex]</span>;\n          }\n\n          return {\n            fill: backgroundColor,\n          };\n        },\n      },\n    ],\n  },\n  interaction: { <span class=\"hljs-comment\">// 关闭部分交互操作</span>\n    selectedCellsSpotlight: false,\n    hoverHighlight: false,\n  },\n};\n</code></pre>\n<h3 data-id=\"heading-8\">3. 渲染</h3>\n<p>有了前面的准备工作，绘制多维分析表就很容易了。</p>\n<pre><code class=\"hljs language-ini\" lang=\"ini\">ReactDOM.render(\n  &lt;SheetComponent\n    <span class=\"hljs-attr\">dataCfg</span>={s2DataConfig}\n    <span class=\"hljs-attr\">options</span>={s2Options}\n    <span class=\"hljs-attr\">adaptive</span>={<span class=\"hljs-literal\">true</span>}\n    <span class=\"hljs-attr\">header</span>={{\n      title: '哲学家的观点',\n        extra: <span class=\"hljs-section\">[&lt;PaletteLegend /&gt;]</span>,\n    }}\n    <span class=\"hljs-attr\">onDataCellMouseUp</span>={<span class=\"hljs-literal\">on</span>DataCellMouseUp}\n    /&gt;,\n\n  document.getElementById('container'),\n)<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>最后绘制出来的效果如下图所示，也可以打开我们部署好的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fs2.antv.vision%2Fzh%2Fexamples%2Fcase%2Fcomparison%23philosophers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://s2.antv.vision/zh/examples/case/comparison#philosophers\" ref=\"nofollow noopener noreferrer\">线上示例</a></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/869c4c15e04649099267a00b07b42dfe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-9\">数据洞察</h2>\n<p>从中我们可以获取一些有效信息和洞察：</p>\n<ul>\n<li>每个国家有那些哲学家</li>\n<li>每个哲学家的详细信息</li>\n<li>哲学家每个关键词的权重占比</li>\n</ul>\n<h2 data-id=\"heading-10\">拓展</h2>\n<h3 data-id=\"heading-11\">透视表</h3>\n<p>在统计学中，透视表是矩阵格式的一种表格，显示多变量频率分布。它们提供了两个变量（或者多个）之间的相互关系的基本画面，可以帮助发现它们之间的相互作用，帮助业务进行交叉探索分析，是目前商业&nbsp;<code>BI</code>&nbsp;分析领域中使用频率最高的图表之一。</p>\n<h3 data-id=\"heading-12\">S2</h3>\n<p><code>S2</code> 是 <code>AntV</code> 团队推出的<strong>数据表可视化引擎</strong>，是多维交叉分析领域的表格解决方案，数据驱动视图，提供底层核心库、基础组件库、业务场景库，具备自由扩展的能力，让开发者既能开箱即用，也能基于自身场景自由发挥。\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75e16a49ce134218b6fe5c35a7e56c9b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"官网demo示例\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-13\">小结</h2>\n<p>这一章带大家用表格去展示和认识数据，表格其实也算一种古老的数据可视化方法。再一次认识数据之后，接下来我们就正式进入分析环节！</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "15\n分析：压抑的中世纪发生了什么？\n学习时长: 27分27秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>上一章我们学习了如何用 Sparrow 和 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fs2.antv.vision%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://s2.antv.vision/\" ref=\"nofollow noopener noreferrer\">AntV S2</a> 去绘制表格，简单了解了一下我们分析任务中的数据。这一章我们将完成其中一个任务：<strong>揭露中世纪是一个压抑的时代</strong>，也就是去看看压抑的中世纪到底发生了什么？</p>\n<p>本章我们先简单回顾一下之前学习的视觉编码理论，并且进行一些比较深入了解。这之后我们会用 Sparrow 基于提到的理论去完成相应的可视化，最后给大家介绍如何用信息图展示我们的结果。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73146a5c03984ad4a3851191fb60f1dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-0\">视觉编码理论基础</h2>\n<ul>\n<li>visual encodings 视觉编码是可视化设计的核心环节之一。</li>\n<li>如何视觉编码？即让 mark 标记和控制其外观的 channel 视觉通道进行正交组合。</li>\n</ul>\n<p>《Visualization Analysis &amp; Design》中，作者专门使用一章节介绍 mark 和 channel ：mark 标记是描述项目或链接的「基本几何元素」，channel 通道控制 mark 的「外观」。下面我们就以这本书的内容作为理论指导，介绍如何设计更有效、更友好的可视化。</p>\n<p>简单回顾一下 mark 标记的类型：点、线、面。channel 通道类型：位置、颜色、形状、角度、尺寸。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66597bb2e02249a6afbcd14737c2e36d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>channel 通道的有效性取决于它的类型：在感知上「magnitude 程度」通道与「ordered 有序」数据很匹配，而「identity 特征」通道与「categorical 分类」数据很匹配。下图总结了 channel 的有效性排行情况。我们可以看到左列排名前几为：同比例尺的位置通道、不同比例尺的位置通道、长度、角度、面积等等，右列则是空间区域、色相、运动、形状。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a77304e485994d6aa9328d6a94dcf427~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>上述 channel 的有效性排行还包括了5个维度的考虑：<strong>准确性、可辨别性、可分离性、凸显性</strong>和<strong>分组能力</strong>。我们进一步了解可视化设计还应该注意的维度：</p>\n<ul>\n<li>\n<p>准确性：Cleveland 和 McGill 提供了每种通道类型的感知准确性的排名（针对 magnitude 程度通道）：<strong>这个排名是和上面图的左列排名相对应</strong>。同为：同比例尺的位置通道、不同比例尺的位置通道、长度、角度、面积。Heer 和 Bostock 后来的工作发现长度和角度的准确性大致相等。</p>\n</li>\n<li>\n<p>可辨别性：通道的程度差异是否是可感知的？如果程度差异很小，视觉上是很难区分差异的。因此应该确保该通道的<strong>每个 bin 是有区分度的分段</strong>。例如线的宽度：图下中用三个程度（500、250、100）来展示线宽度的分段范围。</p>\n</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d758c2be54c4aff919ac43debeacf53~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<ul>\n<li>可分离的：如下图所示，**左1图是一对完全可分离的通道：位置和色相。**我们可以很容易地看到点的位置分布及其颜色。左2图是大小和色相的组合。我们很容易根据圆的大小对其分类，但是色相在大小映射的混淆下不那么容易被区分。宽度和高度的组合衍生出了大小这个视觉通道，也变得更难被区分了。红色与绿色的组合则更甚。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5a355c52f6e4d45a664c6d69a0a9560~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<ul>\n<li>凸显性：许多通道具备凸显性，包括（a）倾斜，（b）大小，（c）形状，（d）接近，和（e）阴影方向。(f) 平行线的效果没有前者们佳。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3472281e5347454b98eb9875f007b29f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<ul>\n<li>分组能力：如何设计才能展示分组的效果呢？\n<ul>\n<li>方式一：<strong>使用链接型的 mark 标记。</strong> containment 包含区的分组性高于 connection 连接线。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/590948d62bd347deb70f1a2b3a7d09cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<ul>\n<li>方式二：<strong>使用 identity 特征型通道。</strong> identity 通道的感知分组不像使用 connection 或 containment 标记那样效果强烈，但好处是不会增加额外的杂乱。</li>\n<li>方式三：<strong>使用“亲近性”原则进行分组。</strong> 即同组元素放置同一个区域里。</li>\n</ul>\n<p>通过上述的知识，我们了解到了如何更有效地利用 channel 来展示可视化。但光是了解 mark 和 channel 还是不够的，设计还要从最根本的数据类型出发。</p>\n<h2 data-id=\"heading-1\">针对表格型数据的视觉编码理论</h2>\n<p>表格型数据无处不在，《苏菲的世界》的数据当然也包括了它。</p>\n<p>那么我们如何对「表格型数据」进行可视化设计呢？包括两个方面：「arrange 排布」数据以及「map 映射」数据。</p>\n<ul>\n<li>「arrange 排布」表格型数据：下图显示了四种设计选择。一是直接表达值。二是三种位置排布方式：对区域的分散、排序和对齐。三是轴的方向：矩形的、平行的或径向的。四是布局密度：密集的、空间填充型的。我们可以看到，他们都<strong>与空间通道（位置）相关。</strong></li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45c73364394a46d79e82b329c13825ff~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<ul>\n<li>「 map映射 」数据：颜色以及其他通道也是视觉编码的重要组成部分。这些与第一部分的 channel 介绍是差不多的，我们会在下面的分析问题中，将这些理论应用到可视化设计中去。</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b83a5cbc84af426480d26ce805cbc4ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-2\">问题分析</h2>\n<p>还记得小册子第二章的分析任务吗？我们可以用 Sparrow 来解决下面前两个问题：</p>\n<ul>\n<li>揭露中世纪是一个压抑的时代。（Present）</li>\n<li>哲学家们的年龄分布如何？有多少哲学家的寿命超过了 40 岁？（Discover）</li>\n<li>进一步探索：研究哲学的国家随时间发生了变化吗？最小寿命的哲学家是谁？感兴趣的哲学家都发表了什么样的观点？（Discover）</li>\n</ul>\n<p>上面两个问题可以换个思路提问：时代和哲学家寿命之间的<strong>关系是</strong>怎样的？这个问题可以侧面反映出哲学家在时代中的<strong>分布情况</strong>，同时又展现了哲学家的寿命情况（<strong>异常值</strong>）。</p>\n<h2 data-id=\"heading-3\">可视分析</h2>\n<p><em><strong>第一步：准备数据，认识数据</strong></em></p>\n<p>根据想要了解的内容，我们从《苏菲的世界》中获取了关于哲学家信息的数据（<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fvisualize-sophie-world\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/visualize-sophie-world\" ref=\"nofollow noopener noreferrer\">Github</a>）：</p>\n<pre><code class=\"hljs language-javascript\" lang=\"javascript\"><span class=\"hljs-keyword\">const</span> rawData = [\n  {\n    <span class=\"hljs-string\">\"points\"</span>: [<span class=\"hljs-string\">\"水是万物之源。\"</span>],\n    <span class=\"hljs-string\">\"words\"</span>: [{\n        <span class=\"hljs-string\">\"word\"</span>: <span class=\"hljs-string\">\"水是\"</span>,\n        <span class=\"hljs-string\">\"weight\"</span>: <span class=\"hljs-number\">11.739204307083542</span>\n    }, {\n        <span class=\"hljs-string\">\"word\"</span>: <span class=\"hljs-string\">\"之源\"</span>,\n        <span class=\"hljs-string\">\"weight\"</span>: <span class=\"hljs-number\">9.23723855786</span>\n    }, {\n        <span class=\"hljs-string\">\"word\"</span>: <span class=\"hljs-string\">\"万物\"</span>,\n        <span class=\"hljs-string\">\"weight\"</span>: <span class=\"hljs-number\">7.75434839431</span>\n    }],\n    <span class=\"hljs-string\">\"name\"</span>: <span class=\"hljs-string\">\"泰利斯\"</span>,\n    <span class=\"hljs-string\">\"lifespan\"</span>: [-<span class=\"hljs-number\">624</span>, -<span class=\"hljs-number\">546</span>],\n    <span class=\"hljs-string\">\"country\"</span>: <span class=\"hljs-string\">\"希腊\"</span>,\n    <span class=\"hljs-string\">\"id\"</span>: <span class=\"hljs-number\">66</span>\n\t},\n\t...\n]\n</code></pre>\n<p>观察数据后，我们知道「时代」和「哲学家的寿命」都可以从字段 lifespan 得来。将数据进行预处理一下，添加 born 出生年份和 age 年龄的维度：\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8b29be61f25469395ec295028d25663~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-javascript\" lang=\"javascript\"><span class=\"hljs-keyword\">const</span> data = rawData.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">datum</span> =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> { lifespan } = datum;\n  <span class=\"hljs-keyword\">return</span> {\n    ...datum,\n    <span class=\"hljs-attr\">born</span>: lifespan[<span class=\"hljs-number\">0</span>],\n    <span class=\"hljs-attr\">age</span>: lifespan[<span class=\"hljs-number\">1</span>] - lifespan[<span class=\"hljs-number\">0</span>],\n  }\n})\n</code></pre>\n<p><strong><em>第二步：视觉编码</em></strong></p>\n<p>现在数据和想要的维度已经有了，那么我们可以用什么图表来展示数据呢？</p>\n<ul>\n<li>思路：考虑维度的类型和数量（what），结合目标任务（why），进而选择「排布 arrange」方式，接着完善「mark」+「channel」映射（how），形成最终的图表。</li>\n<li>例子1：如果想查看两个具有数值型维度的组合结果（what），如观察相关性或关系（why），首先针对都是数值型的维度，对应直接表达值（arrange：express value）这种排布方式，即数值型维度被映射到沿轴分布的位置，且 mark 为一个点，因此用散点图来展示；</li>\n<li>例子2：如果想组合一个分类型维度和一个数值型维度（what），以比较各类型的值大小（why），可以使用元素对其布局（arrange：align），即将分类维度在轴上排开排布，再用长度通道映射数值型维度。对应的 mark 是 line。因此用柱形图来表示；</li>\n<li>例子3：如果我们要同时展示三个维度（why），维度分别是两个分类型+一个数值型（what），则让两个分类型维度分别沿着行、列对齐分布（arrange：align），mark 为 area，将数值型维度编码成颜色，因此热力图是合适的。</li>\n</ul>\n<p>根据本文提供的两个属于「数值型」 的维度（born、age），通过下表分析可以得出散点图这个设计方案。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th><strong>charts</strong></th><th>scatter plot</th></tr></thead><tbody><tr><td><strong>What：Data</strong></td><td>表格型数据：born 和 age 都是为数值型的数据维度。</td></tr><tr><td><strong>How：Encode</strong></td><td>1. arrange：express value（横、纵方向）；2. mark：point ；3. channel：position on common scale</td></tr><tr><td><strong>Why：Task</strong></td><td>关系：时代和哲学家寿命之间的关系；分布：哲学家的寿命分布；异常值：哲学家寿命的异常值</td></tr></tbody></table>\n<p><em><strong>第三步：数据可视化</strong></em></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82241c24e1a140599f561c38addb4e87~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-javascript\" lang=\"javascript\">(<span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/d345d2d7-a35d-4d27-af92-4982b3e6b213.json\"</span>\n  );\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n  <span class=\"hljs-keyword\">return</span> sp.<span class=\"hljs-title function_\">plot</span>({\n    data,\n    <span class=\"hljs-comment\">// 简单处理一下数据</span>\n    <span class=\"hljs-attr\">transforms</span>: [\n      <span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span>\n        data.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> ({\n          <span class=\"hljs-attr\">born</span>: +<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(d.<span class=\"hljs-property\">lifespan</span>[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>),\n          <span class=\"hljs-attr\">age</span>: d.<span class=\"hljs-property\">lifespan</span>[<span class=\"hljs-number\">1</span>] - d.<span class=\"hljs-property\">lifespan</span>[<span class=\"hljs-number\">0</span>],\n          <span class=\"hljs-attr\">name</span>: d.<span class=\"hljs-property\">name</span>,\n        })),\n    ],\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"point\"</span>,\n    <span class=\"hljs-attr\">paddingTop</span>: <span class=\"hljs-number\">30</span>,\n    <span class=\"hljs-attr\">guides</span>: {\n      <span class=\"hljs-attr\">x</span>: {\n        <span class=\"hljs-attr\">formatter</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> {\n          <span class=\"hljs-keyword\">const</span> year = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>(d).<span class=\"hljs-title function_\">getFullYear</span>();\n          <span class=\"hljs-keyword\">return</span> ((year / <span class=\"hljs-number\">50</span>) | <span class=\"hljs-number\">0</span>) * <span class=\"hljs-number\">50</span>;\n        },\n      },\n    },\n    <span class=\"hljs-attr\">encodings</span>: {\n      <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">\"born\"</span>,\n      <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">\"age\"</span>,\n    },\n  });\n})();\n</code></pre>\n<p><em><strong>第四步：数据洞察</strong></em></p>\n<ul>\n<li>上述的图表印证了我们的第一个观点：中世纪是一个压抑的时代。中世纪的范围是-5～1500年，从图中看出很少有哲学家被提及。当时的主流观点是，人类只是自然界的一部分，他们更关注上帝而不是自己。</li>\n<li>不同时期的哲学家大部分都是比较长寿的，在 60～90 岁之间。</li>\n<li>有一位哲学家小于 40 岁。</li>\n</ul>\n<h2 data-id=\"heading-4\">丰富表现力</h2>\n<p>上文我们通过位置的通道映射，用散点图印证了「抑郁的时代」，了解了时代与哲学家年龄的关系以及年龄的情况。但是，这个图表显然不是令人印象深刻的。并且 Sparrow 还不能进一步做交互来发现细节信息。</p>\n<p>接下来，我们使用 g2 ，采用<strong>隐喻的手法</strong>进一步丰富视觉效果，并增加一些交互，回答这些问题：研究哲学的国家随时间发生了变化吗？最小寿命的哲学家是谁？感兴趣的哲学家都发表了什么样的观点？</p>\n<p>我们把每一位哲学家比作一朵花，来营造「百花齐放」的氛围。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4306885761474e0bb98f23a66981f919~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>最终效果图如下：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73146a5c03984ad4a3851191fb60f1dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>对应的映射设计思路如下：我们基于原有的散点图来扩展设计。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78e7f5ef71b84ee58c51339ea89bc16a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>首先 born 和 age 的映射不变，然后让颜色映射不同的国家，并增加元素花瓣来隐喻哲学家的观点：</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th><strong>数据属性</strong></th><th><strong>视觉标记 mark</strong></th><th><strong>视觉通道 channel</strong></th><th><strong>隐喻</strong></th></tr></thead><tbody><tr><td>born</td><td>花蕊 (point)</td><td>position</td><td>所在时间轴位置反应出生的时间</td></tr><tr><td>age</td><td>花蕊 (point)</td><td>position</td><td>高度比喻寿命长短</td></tr><tr><td>points</td><td>花瓣</td><td>/</td><td>一个花瓣比喻一个观点，花瓣越多，产出的观点越多</td></tr><tr><td>country</td><td>花瓣</td><td>color</td><td>不同的花瓣颜色=不同种类，比喻不同的国家</td></tr></tbody></table>\n<p>实现如下：我们需要用 g2 的 registerShape 方法来自定义一些图形。先来实现一个简单的花蕊（散点）+花瓣：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2703cf9309be4230a74a4af82d4c4598~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-javascript\" lang=\"javascript\"><span class=\"hljs-comment\">// 1. 自定义 shape</span>\n<span class=\"hljs-variable constant_\">G2</span>.<span class=\"hljs-title function_\">registerShape</span>(<span class=\"hljs-string\">'point'</span>, <span class=\"hljs-string\">'glyph'</span>, {\n  <span class=\"hljs-title function_\">draw</span>(<span class=\"hljs-params\">cfg, container</span>) {\n    cfg.<span class=\"hljs-property\">points</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">parsePoints</span>(cfg.<span class=\"hljs-property\">points</span>);\n    <span class=\"hljs-keyword\">const</span> group = container.<span class=\"hljs-title function_\">addGroup</span>();\n    <span class=\"hljs-comment\">// 花瓣</span>\n    <span class=\"hljs-title function_\">createPetals</span>(group, cfg);\n    <span class=\"hljs-comment\">// 花蕊</span>\n    <span class=\"hljs-title function_\">createStamen</span>(group, cfg);\n    <span class=\"hljs-keyword\">return</span> group;\n  }\n});\n\n<span class=\"hljs-comment\">// 2. 创建图表</span>\n<span class=\"hljs-keyword\">const</span> chart = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">G2</span>.<span class=\"hljs-title class_\">Chart</span>({\n  <span class=\"hljs-attr\">container</span>: <span class=\"hljs-string\">'container'</span>,\n  <span class=\"hljs-attr\">autoFit</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">700</span>,\n  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">400</span>,\n});\n\n<span class=\"hljs-comment\">// 3. 绑定数据，调整比例尺</span>\nchart\n  .<span class=\"hljs-title function_\">data</span>(data)\n  .<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">'born'</span>, {\n    <span class=\"hljs-attr\">tickCount</span>: <span class=\"hljs-number\">10</span>,\n    <span class=\"hljs-attr\">nice</span>: <span class=\"hljs-literal\">true</span>,\n  })\n  .<span class=\"hljs-title function_\">scale</span>(<span class=\"hljs-string\">'age'</span>, {\n    <span class=\"hljs-attr\">nice</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">max</span>: <span class=\"hljs-number\">100</span>\n  });\n\n<span class=\"hljs-comment\">// 4. 绘制点，绑定维度（包括组件样式调整）</span>\nchart.<span class=\"hljs-title function_\">point</span>()\n  .<span class=\"hljs-title function_\">shape</span>(<span class=\"hljs-string\">'circle'</span>)\n  .<span class=\"hljs-title function_\">position</span>(<span class=\"hljs-string\">'born*age'</span>)\n\t.<span class=\"hljs-title function_\">color</span>(<span class=\"hljs-string\">'#7693eb'</span>)\n\nchart.<span class=\"hljs-title function_\">legend</span>(<span class=\"hljs-string\">'age'</span>, <span class=\"hljs-literal\">false</span>);\nchart.<span class=\"hljs-title function_\">axis</span>(<span class=\"hljs-string\">'age'</span>, {\n  <span class=\"hljs-attr\">grid</span>: <span class=\"hljs-literal\">null</span>\n});\n\n<span class=\"hljs-comment\">// 5. 渲染图表</span>\nchart.<span class=\"hljs-title function_\">render</span>();\n</code></pre>\n<p>对应的 createPetals 和 createStamen 函数：</p>\n<pre><code class=\"hljs language-javascript\" lang=\"javascript\"><span class=\"hljs-comment\">/**\n * 创建花瓣\n * <span class=\"hljs-doctag\">@param</span> group 元素容器\n * <span class=\"hljs-doctag\">@param</span> cfg 每个 item 的 cfg 配置信息\n */</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createPetals</span>(<span class=\"hljs-params\">group, cfg</span>) {\n  <span class=\"hljs-keyword\">const</span> { data, color } = cfg;\n  <span class=\"hljs-keyword\">const</span> { points } = data;\n  <span class=\"hljs-keyword\">const</span> maxCount = points.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">2</span> ? <span class=\"hljs-number\">5</span> : points.<span class=\"hljs-property\">length</span>;\n  <span class=\"hljs-keyword\">const</span> angleUnit = (<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span> * <span class=\"hljs-number\">2</span>) / maxCount;\n  <span class=\"hljs-keyword\">const</span> { x, y } = cfg.<span class=\"hljs-property\">points</span>[<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-keyword\">const</span> petalSize = <span class=\"hljs-number\">25</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> index <span class=\"hljs-keyword\">in</span> points) {\n    <span class=\"hljs-keyword\">const</span> petal = group.<span class=\"hljs-title function_\">addShape</span>(<span class=\"hljs-string\">\"path\"</span>, {\n      <span class=\"hljs-attr\">attrs</span>: {\n        <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">`\n        M<span class=\"hljs-subst\">${x}</span> <span class=\"hljs-subst\">${y}</span>\n        C<span class=\"hljs-subst\">${x - petalSize / <span class=\"hljs-number\">2.7</span>}</span> <span class=\"hljs-subst\">${y - petalSize / <span class=\"hljs-number\">2.5</span>}</span>\n        <span class=\"hljs-subst\">${x - petalSize / <span class=\"hljs-number\">2.7</span>}</span> <span class=\"hljs-subst\">${y - petalSize / <span class=\"hljs-number\">1.5</span>}</span>\n        <span class=\"hljs-subst\">${x}</span> <span class=\"hljs-subst\">${y - petalSize / <span class=\"hljs-number\">1.2</span>}</span>\n        C<span class=\"hljs-subst\">${x + petalSize / <span class=\"hljs-number\">2.7</span>}</span> <span class=\"hljs-subst\">${y - petalSize / <span class=\"hljs-number\">1.5</span>}</span>\n        <span class=\"hljs-subst\">${x + petalSize / <span class=\"hljs-number\">2.7</span>}</span> <span class=\"hljs-subst\">${y - petalSize / <span class=\"hljs-number\">2.5</span>}</span>\n        <span class=\"hljs-subst\">${x}</span> <span class=\"hljs-subst\">${y}</span>\n        `</span>,\n        <span class=\"hljs-attr\">shadowBlur</span>: <span class=\"hljs-number\">50</span>,\n        <span class=\"hljs-attr\">shadowColor</span>: color,\n        <span class=\"hljs-attr\">fillOpacity</span>: <span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">`l(90) 0:<span class=\"hljs-subst\">${color}</span> 0.2:<span class=\"hljs-subst\">${color}</span> 1:#fff`</span>\n      }\n    });\n    petal.<span class=\"hljs-title function_\">rotateAtPoint</span>(x, y, angleUnit * index);\n  }\n}\n\n<span class=\"hljs-comment\">/**\n * 创建花蕊\n * <span class=\"hljs-doctag\">@param</span> group 元素容器\n * <span class=\"hljs-doctag\">@param</span> cfg 每个 item 的 cfg 配置信息\n */</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createStamen</span>(<span class=\"hljs-params\">group, cfg</span>) {\n  <span class=\"hljs-keyword\">const</span> { points, color } = cfg;\n  <span class=\"hljs-keyword\">const</span> { x, y } = points[<span class=\"hljs-number\">0</span>];\n  group.<span class=\"hljs-title function_\">addShape</span>(<span class=\"hljs-string\">'circle'</span>, {\n    <span class=\"hljs-attr\">attrs</span>: {\n      <span class=\"hljs-attr\">r</span>: <span class=\"hljs-number\">2</span>,\n      x,\n      y,\n      <span class=\"hljs-attr\">stroke</span>: color,\n      <span class=\"hljs-attr\">fillOpacity</span>: <span class=\"hljs-number\">1</span>,\n      <span class=\"hljs-attr\">shadowColor</span>: <span class=\"hljs-string\">'#eee'</span>,\n      <span class=\"hljs-attr\">shadowBlur</span>: <span class=\"hljs-number\">5</span>,\n      <span class=\"hljs-attr\">fill</span>: color,\n      <span class=\"hljs-attr\">lineWidth</span>: <span class=\"hljs-number\">0</span>,\n    }\n  });\n}\n</code></pre>\n<p>继续添加映射与隐喻：花茎与叶子。剩下的代码思路是差不多的，详见(<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fjolly-mopsa-739hf%3Ffile%3D%2Fsrc%2Findex.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://codesandbox.io/s/jolly-mopsa-739hf?file=/src/index.js\" ref=\"nofollow noopener noreferrer\">CodeSandBox</a>)：</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th><strong>数据属性</strong></th><th><strong>视觉标记 mark</strong></th><th><strong>视觉通道 channel</strong></th><th><strong>隐喻</strong></th></tr></thead><tbody><tr><td>born</td><td>花蕊</td><td>position</td><td>所在时间轴位置反应出生的时间</td></tr><tr><td>age</td><td>花蕊 (point)、花茎</td><td>position、length</td><td>花蕊高度、花茎长度比喻寿命长短</td></tr><tr><td>points</td><td>花瓣</td><td>/</td><td>一个花瓣比喻一个观点，花瓣越多，产出的观点越多</td></tr><tr><td>country</td><td>花瓣</td><td>color</td><td>不同的花瓣颜色=不同种类，比喻不同的国家</td></tr><tr><td>words</td><td>叶子</td><td>/</td><td>一片叶子比喻一个关键词，表示叶子与花瓣不可分的关系</td></tr><tr><td>weight</td><td>叶子</td><td>size</td><td>关键词权重比喻叶子的养分</td></tr></tbody></table>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82bec5b753ef4c6fad4eeda11880564c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\">\n接下来，增加 tooltip 以查看细节：\n<img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ec4ebb1b96944d3bff1f16d70581472~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>回看该 channel 的设计如何结合视觉编码理论基础：</p>\n<ul>\n<li>从channel 准确性角度来说，针对数值型维度，使用了排名 1 的同比例尺的位置通道；针对分类型维度，“国家”属性使用空间区域映射可能是更合适的，由于散点图限制，结合隐喻使用了排名 2 的色相通道。</li>\n<li>由于映射通道较多，需要关注通道的可分离性，因此使用了最合适的位置 + 颜色的组合。</li>\n<li>size 通道会影响 color 通道的效果。例如看不清颜色或者容易忽略花瓣的数量，尤其是颜色较多的情况下。所以在此之前，撤回了对花瓣的大小通道映射。</li>\n</ul>\n<p>数据洞察：</p>\n<ul>\n<li>各国哲学家分阶段出现：国家从最初的雅典、希腊，转变成意大利，再到英法德。</li>\n<li>交互探索：寿命最短的是耶稣，仅34岁；</li>\n<li>交互探索：笛卡尔、康德、祁克果、马克思贡献的观点最多；观点内容包含了关于上帝、人类、物质的话题。</li>\n<li>权重最大的关键词“事物”来自亚里士多德。</li>\n</ul>\n<h2 data-id=\"heading-5\">小结</h2>\n<p>这一章和大家一起用“朴素”和“炫酷”的方式完成了：“<strong>揭露中世纪是一个压抑的时代</strong>”这一个任务，这里主要涉及的是<strong>表格数据</strong>的可视化方法。下一章我们将去看看“哲学家之间在讨论啥‘八卦’”，去看看文本可视化的其中一种方法。</p>\n<blockquote>\n<p>参考：Munzner, Tamara. <em>Visualization analysis and design</em>. CRC press, 2014.</p>\n</blockquote><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "16\n分析：哲学家之间在讨论啥“八卦”？\n学习时长: 23分21秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>本章我们将会使用可视化工具来分析苏菲的世界中，哲学家都在讨论什么八卦内容？这个问题最终可以抽象成“苏菲的世界中，涉及到的问题和回答的关键词是什么？”</p>\n<h2 data-id=\"heading-0\">任务分析</h2>\n<p>这个问题需要分析哲学问题和回答的关键词，分成几步：</p>\n<ul>\n<li>罗列出问题和回答，然后将问题和回答进行分词，获得所有关键词以及出现频次，获得要分析的数据</li>\n<li>使用词云图对关键词数据进行可视化，配合字体大小、颜色和频次关联，获得更好的视觉效果</li>\n<li>获取数据洞察</li>\n</ul>\n<p>下面会按照这几个步骤，去实现这样的一个词云图，并从中获得数据洞察。</p>\n<h2 data-id=\"heading-1\">数据处理</h2>\n<p>首先我们从《苏菲的世界》中，获取所有问题列表，以及所有的回答列表，然后使用社区开源的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fnodejieba\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://www.npmjs.com/package/nodejieba\" ref=\"nofollow noopener noreferrer\">nodejieba</a> 进行关键词抽取。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> nodejieba = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'nodejieba'</span>);\n<span class=\"hljs-keyword\">const</span> topN = <span class=\"hljs-number\">5</span>;\n<span class=\"hljs-keyword\">const</span> keywords = nodejieba.<span class=\"hljs-title function_\">extract</span>(<span class=\"hljs-string\">'世界上根本没有真正的变化，没有任何事物可以变成另外一种事物。'</span>, topN);\n</code></pre>\n<p>这里就不去过多介绍了，最后获取的关键词数据放在 GitHub 上（<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fchallenge-2021%2Fblob%2Fmain%2Fdata%2Fquestions.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/challenge-2021/blob/main/data/questions.json\" ref=\"nofollow noopener noreferrer\">问题</a>、<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fchallenge-2021%2Fblame%2Fmain%2Fdata%2Fphilosophers.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/challenge-2021/blame/main/data/philosophers.json\" ref=\"nofollow noopener noreferrer\">回答观点</a>）。</p>\n<h2 data-id=\"heading-2\">用 Sparrow 绘制词云</h2>\n<p>所谓的词云就是将关键字互不重叠的在画布上排列展示，文字的大小和词云的关键程度呈正相关。</p>\n<p>因为 Sparrow 本身没有实现词云布局算法，所以这里我们将先使用 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjasondavies%2Fd3-cloud\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/jasondavies/d3-cloud\" ref=\"nofollow noopener noreferrer\">d3-cloud</a> 去对词语进行布局，然后再用 Sparrow 去绘制。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5e380f7872946da8a418b4ec8df5e7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\">(<span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-comment\">// 获得数据</span>\n  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/d345d2d7-a35d-4d27-af92-4982b3e6b213.json\"</span>\n  );\n  <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n  \n  <span class=\"hljs-comment\">// 获得词语列表</span>\n  <span class=\"hljs-keyword\">const</span> words = data.<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span>\n    d.<span class=\"hljs-property\">words</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ weight, word }</span>) =&gt;</span> ({\n      <span class=\"hljs-attr\">value</span>: weight,\n      <span class=\"hljs-attr\">text</span>: word,\n      <span class=\"hljs-attr\">name</span>: d.<span class=\"hljs-property\">name</span>,\n    }))\n  );\n  \n  <span class=\"hljs-comment\">// 用 d3-cloud 对文字进行布局</span>\n  <span class=\"hljs-keyword\">const</span> width = <span class=\"hljs-number\">640</span>;\n  <span class=\"hljs-keyword\">const</span> height = <span class=\"hljs-number\">480</span>;\n  <span class=\"hljs-keyword\">const</span> computedWords = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span>\n    d3.<span class=\"hljs-property\">layout</span>\n      .<span class=\"hljs-title function_\">cloud</span>()\n      .<span class=\"hljs-title function_\">size</span>([width, height])\n      .<span class=\"hljs-title function_\">words</span>(words)\n      .<span class=\"hljs-title function_\">padding</span>(<span class=\"hljs-number\">2</span>)\n      .<span class=\"hljs-title function_\">rotate</span>(<span class=\"hljs-function\">() =&gt;</span> ~~(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() * <span class=\"hljs-number\">2</span>) * <span class=\"hljs-number\">90</span>) <span class=\"hljs-comment\">// 文字的旋转角度</span>\n      .<span class=\"hljs-title function_\">fontSize</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">value</span> * <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// 字号</span>\n      .<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">\"end\"</span>, resolve) <span class=\"hljs-comment\">// 计算布局完成的回掉函数</span>\n      .<span class=\"hljs-title function_\">start</span>() <span class=\"hljs-comment\">// 开始进行布局</span>\n  );\n\n  <span class=\"hljs-comment\">// 绘制处理好的文字</span>\n  <span class=\"hljs-keyword\">return</span> sp.<span class=\"hljs-title function_\">plot</span>({\n    <span class=\"hljs-attr\">data</span>: computedWords,\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"text\"</span>,\n    width,\n    height,\n    <span class=\"hljs-attr\">paddingTop</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">paddingBottom</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">paddingLeft</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">paddingRight</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">guides</span>: {\n      <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> },\n      <span class=\"hljs-attr\">y</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> },\n      <span class=\"hljs-attr\">color</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> },\n    },\n    <span class=\"hljs-attr\">scales</span>: {\n      <span class=\"hljs-attr\">fontSize</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"identity\"</span> },\n      <span class=\"hljs-attr\">rotate</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"identity\"</span> },\n      <span class=\"hljs-attr\">y</span>: { <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>] }, <span class=\"hljs-comment\">// 默认的 range 是 [1, 0]</span>\n    },\n    <span class=\"hljs-attr\">encodings</span>: {\n      <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">\"x\"</span>,\n      <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">\"y\"</span>,\n      <span class=\"hljs-attr\">rotate</span>: <span class=\"hljs-string\">\"rotate\"</span>,\n      <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">\"size\"</span>,\n      <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">\"text\"</span>,\n      <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"name\"</span>,\n    },\n    <span class=\"hljs-attr\">styles</span>: {\n      <span class=\"hljs-attr\">textAnchor</span>: <span class=\"hljs-string\">\"middle\"</span>,\n    },\n  });\n})();\n</code></pre>\n<p>一个简单的词云图就绘制完成了，但是这个地方存在一个问题，就是不能通过我们那的可视化结果去判断每一个词是哪一个哲学家说的。</p>\n<p>如果当鼠标移动到任意一个词上，会出现一个提示信息提示该词的来源就好了。可惜 Sparrow 不支持交互，所以接下来我们 AntV 的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FG2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/G2\" ref=\"nofollow noopener noreferrer\">G2</a> 再来绘制一下词云。</p>\n<h2 data-id=\"heading-3\">用 G2 绘制词云</h2>\n<p>在用 G2 绘制词云图之前，我们需要了解 G2 是怎么理解和绘制图表的。G2 是基于图形语法的统计图表引擎，它通过：</p>\n<ol>\n<li>不同的图元绘制不同类型的可视化图表。</li>\n<li>通过数据映射，将数据和图元的视觉属性绑定起来，比如：color、size、shape 等等。</li>\n</ol>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>图元 Geometry</th><th>视觉属性通道</th></tr></thead><tbody><tr><td><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/797846236c644264956d51f01a1c28c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></td><td><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7ea96f9ad394842b0d77a3f53bd4e2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr></tbody></table>\n<p>那么在绘制词云图的时候，我们使用 <code>point</code> 这个图元去绘制文字，然后文字的位置、大小、颜色都是和数据绑定的。所以绘制词云图分成为 3 个步骤。</p>\n<ul>\n<li><strong>视觉属性映射</strong></li>\n</ul>\n<p>将原始关键词的权重数据，通过数据转化，变化成文字的位置、大小、颜色信息，以便于下一步 G2 的绘制。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">DataSet</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@antv/data-set'</span>;\n\n<span class=\"hljs-keyword\">const</span> dv = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DataSet</span>().<span class=\"hljs-title function_\">createView</span>().<span class=\"hljs-title function_\">source</span>(data);\n<span class=\"hljs-keyword\">const</span> fontSize = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scale</span>.<span class=\"hljs-title class_\">Linear</span>({\n  <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">24</span>, <span class=\"hljs-number\">70</span>],\n  <span class=\"hljs-attr\">domain</span>: dv.<span class=\"hljs-title function_\">range</span>(<span class=\"hljs-string\">'value'</span>)\n});\n<span class=\"hljs-keyword\">const</span> [min, max] = dv.<span class=\"hljs-title function_\">range</span>(<span class=\"hljs-string\">'value'</span>);\n\ndv.<span class=\"hljs-title function_\">transform</span>({\n  <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'tag-cloud'</span>,\n  <span class=\"hljs-attr\">fields</span>: [<span class=\"hljs-string\">'word'</span>, <span class=\"hljs-string\">'value'</span>],\n  <span class=\"hljs-attr\">size</span>: [<span class=\"hljs-number\">800</span>, <span class=\"hljs-number\">600</span>], <span class=\"hljs-comment\">// 画布的大小</span>\n  <span class=\"hljs-attr\">font</span>: <span class=\"hljs-string\">'Verdana'</span>,\n  <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-comment\">// 映射旋转角度</span>\n  <span class=\"hljs-title function_\">rotate</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">let</span> random = ~~(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() * <span class=\"hljs-number\">4</span>) % <span class=\"hljs-number\">4</span>;\n    <span class=\"hljs-keyword\">if</span> (random === <span class=\"hljs-number\">2</span>) {\n      random = <span class=\"hljs-number\">0</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> random * <span class=\"hljs-number\">90</span>; <span class=\"hljs-comment\">// 0, 90, 270</span>\n  },\n  <span class=\"hljs-comment\">// 映射字体大小，范围为 [24px, 70px]</span>\n  <span class=\"hljs-title function_\">fontSize</span>(<span class=\"hljs-params\">d</span>) {\n    <span class=\"hljs-keyword\">return</span> d.<span class=\"hljs-property\">value</span> ? <span class=\"hljs-number\">24</span> + (<span class=\"hljs-number\">70</span> - <span class=\"hljs-number\">24</span>) / (max - min);\n  }\n});\n</code></pre>\n<p>这里用到了 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fdata-set\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/data-set\" ref=\"nofollow noopener noreferrer\">dat-set</a> 模块中的 <code>tag-cloud</code> 的数据处理函数，对数据进行词云图布局和视觉通道的映射，获得的数据结构为：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\">[{\n  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">26.6063055869</span>,\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">\"祁克果\"</span>,\n  <span class=\"hljs-attr\">word</span>: <span class=\"hljs-string\">\"阶段\"</span>,\n  <span class=\"hljs-attr\">font</span>: <span class=\"hljs-string\">\"Verdana\"</span>,\n  <span class=\"hljs-attr\">style</span>: <span class=\"hljs-string\">\"normal\"</span>,\n  <span class=\"hljs-attr\">weight</span>: <span class=\"hljs-string\">\"normal\"</span>,\n  <span class=\"hljs-attr\">rotate</span>: <span class=\"hljs-number\">270</span>,\n  <span class=\"hljs-attr\">size</span>: <span class=\"hljs-number\">70</span>,\n  <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">286</span>,\n  <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">188</span>\n}]\n</code></pre>\n<p>这个数据结构中，已经包含有文字渲染需要的所有信息，直接拿这个信息在 G2 中绘制即可。</p>\n<ul>\n<li><strong>定制词云图需要的图元 shape</strong></li>\n</ul>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Chart</span>, registerShape } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@antv/g2'</span>;\n\n<span class=\"hljs-comment\">// 准备图形：给 point 图元注册一个词云形状 cloud</span>\n<span class=\"hljs-title function_\">registerShape</span>(<span class=\"hljs-string\">'point'</span>, <span class=\"hljs-string\">'cloud'</span>, {\n  <span class=\"hljs-title function_\">draw</span>(<span class=\"hljs-params\">cfg, container</span>) {\n    <span class=\"hljs-comment\">// 从数据中获取视觉属性</span>\n    <span class=\"hljs-keyword\">const</span> attrs = {\n      ...cfg.<span class=\"hljs-property\">defaultStyle</span>,\n      ...cfg.<span class=\"hljs-property\">style</span>,\n      <span class=\"hljs-attr\">textAlign</span>: <span class=\"hljs-string\">'center'</span>,\n      <span class=\"hljs-attr\">textBaseline</span>: <span class=\"hljs-string\">'Alphabetic'</span>,\n      <span class=\"hljs-comment\">// 数据映射属性</span>\n      <span class=\"hljs-attr\">fontSize</span>: cfg.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">size</span>,\n      <span class=\"hljs-attr\">text</span>: cfg.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">text</span>,\n      <span class=\"hljs-attr\">fontFamily</span>: cfg.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">font</span>,\n      <span class=\"hljs-attr\">fill</span>: cfg.<span class=\"hljs-property\">color</span>,\n    }\n    <span class=\"hljs-keyword\">const</span> textShape = container.<span class=\"hljs-title function_\">addShape</span>(<span class=\"hljs-string\">'text'</span>, {\n      <span class=\"hljs-attr\">attrs</span>: {\n        ...attrs,\n        <span class=\"hljs-attr\">x</span>: cfg.<span class=\"hljs-property\">x</span>,\n        <span class=\"hljs-attr\">y</span>: cfg.<span class=\"hljs-property\">y</span>\n      }\n    });\n    <span class=\"hljs-comment\">// 旋转图形</span>\n    <span class=\"hljs-keyword\">if</span> (cfg.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">rotate</span>) {\n      <span class=\"hljs-title class_\">Util</span>.<span class=\"hljs-title function_\">rotate</span>(textShape, (cfg.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">rotate</span> * <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">PI</span>) / <span class=\"hljs-number\">180</span>);\n    }\n    <span class=\"hljs-keyword\">return</span> textShape;\n  }\n});\n</code></pre>\n<p>通过这个方式，在 G2 的图形池中，就增加了 <code>cloud</code> 类型的绘图，并且可以从数据中去指定 <code>fontSize</code>、<code>text</code>、<code>fontFamily</code>、<code>fill</code>、<code>rotate</code> 等属性。</p>\n<ul>\n<li><strong>使用 G2 绘制词云图</strong></li>\n</ul>\n<p>有了前面的准备工作，绘制词云图就很容易了。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Chart</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@antv/g2'</span>;\n\n<span class=\"hljs-comment\">// 1. 创建图表容器</span>\n<span class=\"hljs-keyword\">const</span> chart = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Chart</span>({\n  container,\n  <span class=\"hljs-attr\">autoFit</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">800</span>,\n  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">600</span>,\n  <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-number\">0</span>\n});\n\n<span class=\"hljs-comment\">// 2. 装载第一步中处理好的数据</span>\nchart.<span class=\"hljs-title function_\">data</span>(data);\nchart.<span class=\"hljs-title function_\">legend</span>(<span class=\"hljs-literal\">false</span>);\nchart.<span class=\"hljs-title function_\">axis</span>(<span class=\"hljs-literal\">false</span>);\nchart.<span class=\"hljs-title function_\">tooltip</span>({\n  <span class=\"hljs-attr\">showTitle</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">showMarkers</span>: <span class=\"hljs-literal\">false</span>\n});\n\nchart.<span class=\"hljs-title function_\">coordinate</span>().<span class=\"hljs-title function_\">reflect</span>();\n\n<span class=\"hljs-comment\">// 3. 使用 point 中的 cloud 形状，并将位置、颜色等视觉属性绑定到数据字段上</span>\nchart\n  .<span class=\"hljs-title function_\">point</span>()\n  .<span class=\"hljs-title function_\">position</span>(<span class=\"hljs-string\">'x*y'</span>)\n  .<span class=\"hljs-title function_\">color</span>(<span class=\"hljs-string\">'title'</span>, colors)\n  .<span class=\"hljs-title function_\">shape</span>(<span class=\"hljs-string\">'cloud'</span>)\n  .<span class=\"hljs-title function_\">tooltip</span>(<span class=\"hljs-string\">'title'</span>);\n\nchart.<span class=\"hljs-title function_\">render</span>();\n</code></pre>\n<p>最后绘制出来的效果如下图所示，也可以打开我们部署好的<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fobservablehq.com%2F%40pearmini%2Fvisualize-sophies-world-by-antv%23dataType\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://observablehq.com/@pearmini/visualize-sophies-world-by-antv#dataType\" ref=\"nofollow noopener noreferrer\">线上示例</a>。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>问题关键词分析</th><th>观点关键词分析</th></tr></thead><tbody><tr><td><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd5a6c31c8f046fc9869bee1714932e1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"question\" loading=\"lazy\" class=\"medium-zoom-image\"></td><td><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85292e0b6a554b1e834e15d2b1afef0b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"answer\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr></tbody></table>\n<h2 data-id=\"heading-4\">数据洞察</h2>\n<p>从中我们可以获取一些有效信息和洞察：</p>\n<ul>\n<li>人们更加关注上帝、世界的起源、理性与感性的关系。</li>\n<li>许多人试图回答来自大自然、心灵或精神的问题。</li>\n<li>马克思和笛卡尔对人类历史有着巨大的影响。</li>\n</ul>\n<h2 data-id=\"heading-5\">拓展</h2>\n<h3 data-id=\"heading-6\">图形语法（Grammar of Graphics）</h3>\n<p>首先我们理解什么是语法？就像我们 JavaScript 语法一样，通过一些正交的关键字，以及语法规范，可以让我们基于语法写出各种各样超越想象的应用。图形语法，顾名思义就是描述视觉图形的语法规范。</p>\n<p>人的眼睛（视觉）无论是在获信息的效率上，还是在获取信息的量级上，都是远高于其他的方式，比如听觉、触觉、嗅觉等等。而对于视觉，人脑处理不同视觉属性的速度不同，一般来说对于颜色最敏感，其次是大小，然后是形状，等等。</p>\n<p>数据可视化分析是建立在以上的客观的生理条件上的，因此基于图形语法的可视化引擎（<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fggplot2.tidyverse.org%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://ggplot2.tidyverse.org/\" ref=\"nofollow noopener noreferrer\">ggplot2</a>、<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fvega.github.io%2Fvega-lite%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://vega.github.io/vega-lite/\" ref=\"nofollow noopener noreferrer\">vega</a>、<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fg2.antv.vision%2Fzh%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://g2.antv.vision/zh/\" ref=\"nofollow noopener noreferrer\">G2</a>），大多会将一个可视化图表分成几大部分：</p>\n<ul>\n<li><strong>图形</strong>：不同的图形包含有不同的数据分析方法，比如折线一般用于看数据趋势，柱形一般用于进行数据的对比，点一般用于看分布，等等。</li>\n<li><strong>视觉属性通道</strong>：通过将数据和视觉属性绑定和映射，让人脑更容易从视觉上获取数据上的有效的信息。</li>\n<li><strong>坐标系</strong>：代表数据大小的图形区块，在画布中的展示方式不同，可能带来具有不同的分析效率。</li>\n</ul>\n<p>而上述的这些内容，社区上几乎所有的图表库多多少少都会涉及一些。比如在 d3 的代码中，经常遇到类似以下：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\">d3.<span class=\"hljs-title function_\">selectAll</span>(<span class=\"hljs-string\">\"p\"</span>).<span class=\"hljs-title function_\">style</span>(<span class=\"hljs-string\">\"color\"</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hsl(\"</span> + <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() * <span class=\"hljs-number\">360</span> + <span class=\"hljs-string\">\",100%,50%)\"</span>;\n});\n</code></pre>\n<p>这个过程实际就是通过回调的方式，将颜色这个视觉属性和数据绑定起来。</p>\n<h3 data-id=\"heading-7\">G2</h3>\n<p>G2 是 AntV 旗下的第一个数据可视化引擎，基于图形语法，专注于统计图表和数据分析。它的取名就是来自于 <strong>G</strong>rammar of <strong>G</strong>raphics 首字母，也是国内首个基于图形语法的统计图表引擎。这类图表引擎的优势和缺点都很明显。</p>\n<ul>\n<li>优势：更贴近数据分析语义、变幻出各种各样的可视化图表、灵活性非常高</li>\n<li>劣势：概念多，上手门槛高、实现业务需求还需要不少代码量</li>\n</ul>\n<p>如果想了解更多，可以去阅读 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fg2.antv.vision%2Fzh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://g2.antv.vision/zh\" ref=\"nofollow noopener noreferrer\">G2 官网教程</a>，未来我们将在 G2 图形语法的基础上，优化交互语法，增加动画语法，大大提升 G2 在实时数据、可视化叙事上的表达能力，并将会发表的学术论文，更详细体系的介绍它的技术模块和架构。</p>\n<h2 data-id=\"heading-8\">小结</h2>\n<p>这一章，我们通过数据分析的过程，去了解苏菲的世界中，哲学家讨论的一些话题情况。通过这个过程，可以大概了解文本可视化的基本概念。</p>\n<p>另外我们拓展讲了一些关于 G2 和图形语法的知识，现代的可视化图表技术，一般都离不开图形语法，理解这个就可以理解大部分的可视化内库，同样，上述的文本可视化，也是在图形语法基础上延伸出来的一个分支。在实际业务场景中，有大量的数据看板，会使用指标卡、富文本、词云图等去表达实际的业务含义。</p>\n<p>下一节，我们会用类似的方式，去介绍去如何实现关系数据可视化和分析。</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "17\n分析：抽象的哲学问题又有谁来解？\n学习时长: 20分5秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>本章我们将会使用可视化完成 “苏菲的世界中，问题和哲学家之间的关系是怎样的？” 这个任务。也就是看看哪些哲学家回答了哪些抽象的哲学问题。</p>\n<h2 data-id=\"heading-0\">任务分析</h2>\n<p>这个问题需要分析哲学和问题之间的关系，分成几步：</p>\n<ul>\n<li>罗列出哲学家和问题，然后将问题和哲学家进行连接， 使用力导图对问题和参与该问题的哲学家进行可视化</li>\n<li>蓝色代表问题，绿色代表哲学家，连线代表哲学家参与了该问题</li>\n<li>获取数据洞察</li>\n</ul>\n<p>前述从 0 到 1 开发的极简统计图表， 由于力导图的实现相对复杂，这里我们直接用 AntV 成熟的图可视化引擎 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2Fg6\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/g6\" ref=\"nofollow noopener noreferrer\">G6</a> 来绘制和完成任务。</p>\n<p>下面会按照这几个步骤，去实现这样的一个力导图，并从中获得数据洞察。</p>\n<h2 data-id=\"heading-1\">可视分析</h2>\n<h3 data-id=\"heading-2\">获取数据</h3>\n<p>首先我们从《苏菲的世界》中，获取所有问题列表，以及回答过该问题的哲学家，为了简化代码，我们仅列出少量数据和有代表性的数据项，全量数据可在 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fchallenge-2021%2Ftree%2Fmain%2Fdata\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/challenge-2021/tree/main/data\" ref=\"nofollow noopener noreferrer\">GitHub</a> 上下载。</p>\n<pre><code class=\"hljs language-ts\" lang=\"ts\"><span class=\"hljs-comment\">// 哲学家列表</span>\n<span class=\"hljs-keyword\">const</span> philosophers = [\n  {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"泰利斯\"</span>,\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">\"66\"</span>,\n  },\n  <span class=\"hljs-comment\">// ...</span>\n];\n<span class=\"hljs-comment\">// 问题列表</span>\n<span class=\"hljs-keyword\">const</span> questions = [\n  {\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">\"世界从何而来？\"</span>,\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">\"0\"</span>,\n  },\n  {\n    <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">\"我是谁？\"</span>,\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">\"1\"</span>,\n  },\n];\n<span class=\"hljs-comment\">// 关系列表</span>\n<span class=\"hljs-keyword\">const</span> relations = [\n  { <span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">\"151\"</span>, <span class=\"hljs-attr\">to</span>: <span class=\"hljs-string\">\"66\"</span> },\n  <span class=\"hljs-comment\">// ...</span>\n];\n</code></pre>\n<h3 data-id=\"heading-3\">用 Sparrow 绘制力导向图</h3>\n<p>力导向图是图可视化的一种，通过算法模拟自然界的引力和斥力去给图中的节点布局。和词云图一样，Sparrow 也没有实现力导向布局算法，所以这里我们用 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fd3%2Fd3-force\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/d3/d3-force\" ref=\"nofollow noopener noreferrer\">d3-force</a> 去计算布局，然后再用 Sparrow 去绘制。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a65062bb54644932b4a4b01afdce8a58~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\">(<span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-comment\">// 请求数据</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">URLS</span> = [\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/d345d2d7-a35d-4d27-af92-4982b3e6b213.json\"</span>,\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/3df5a34b-9141-453b-b1c9-5dd0eba32273.json\"</span>,\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/188bb992-7a9b-4e0e-a036-d1d0e4269738.json\"</span>,\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/61a39597-9564-4f7e-9eb3-3bdd2280061d.json\"</span>,\n  ];\n  <span class=\"hljs-keyword\">const</span> [people, questions, schools, relations] = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(\n    <span class=\"hljs-variable constant_\">URLS</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">async</span> (url) =&gt; {\n      <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n    })\n  );\n\n  <span class=\"hljs-comment\">// 把扁平的数据转化成嵌套的数据</span>\n  <span class=\"hljs-keyword\">const</span> qidPid = d3.<span class=\"hljs-title function_\">group</span>(\n    relations.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">\"1\"</span>),\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> +d.<span class=\"hljs-property\">from</span>\n  );\n  <span class=\"hljs-keyword\">const</span> pidData = d3.<span class=\"hljs-title function_\">group</span>([...people, ...schools], <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> +d.<span class=\"hljs-property\">id</span>);\n  <span class=\"hljs-keyword\">const</span> data = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"永恒的问题\"</span>,\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"问题\"</span>,\n    <span class=\"hljs-attr\">children</span>: questions\n      .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ id }</span>) =&gt;</span> qidPid.<span class=\"hljs-title function_\">has</span>(id))\n      .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ title, id }</span>) =&gt;</span> ({\n        <span class=\"hljs-attr\">name</span>: title,\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"问题\"</span>,\n        <span class=\"hljs-attr\">children</span>: <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(qidPid.<span class=\"hljs-title function_\">get</span>(id)).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> {\n          <span class=\"hljs-keyword\">const</span> [people] = pidData.<span class=\"hljs-title function_\">get</span>(+d.<span class=\"hljs-property\">to</span>);\n          <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-attr\">name</span>: people.<span class=\"hljs-property\">name</span>,\n            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"哲学家\"</span>,\n          };\n        }),\n      })),\n  };\n\n  <span class=\"hljs-comment\">// 计算布局</span>\n  <span class=\"hljs-keyword\">const</span> root = d3.<span class=\"hljs-title function_\">hierarchy</span>(data);\n  <span class=\"hljs-keyword\">const</span> links = root.<span class=\"hljs-title function_\">links</span>();\n  <span class=\"hljs-keyword\">const</span> nodes = root.<span class=\"hljs-title function_\">descendants</span>();\n  <span class=\"hljs-keyword\">const</span> simulation = d3\n    .<span class=\"hljs-title function_\">forceSimulation</span>(nodes)\n    .<span class=\"hljs-title function_\">force</span>(\n      <span class=\"hljs-string\">\"link\"</span>,\n      d3\n        .<span class=\"hljs-title function_\">forceLink</span>(links)\n        .<span class=\"hljs-title function_\">id</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">id</span>)\n        .<span class=\"hljs-title function_\">distance</span>(<span class=\"hljs-number\">0</span>)\n        .<span class=\"hljs-title function_\">strength</span>(<span class=\"hljs-number\">1</span>)\n    )\n    .<span class=\"hljs-title function_\">force</span>(<span class=\"hljs-string\">\"charge\"</span>, d3.<span class=\"hljs-title function_\">forceManyBody</span>().<span class=\"hljs-title function_\">strength</span>(-<span class=\"hljs-number\">50</span>))\n    .<span class=\"hljs-title function_\">force</span>(<span class=\"hljs-string\">\"x\"</span>, d3.<span class=\"hljs-title function_\">forceX</span>())\n    .<span class=\"hljs-title function_\">force</span>(<span class=\"hljs-string\">\"y\"</span>, d3.<span class=\"hljs-title function_\">forceY</span>())\n    .<span class=\"hljs-title function_\">stop</span>();\n\n  <span class=\"hljs-comment\">// @see https://bl.ocks.org/mbostock/1667139</span>\n  <span class=\"hljs-comment\">// compute a static force layout</span>\n  <span class=\"hljs-keyword\">const</span> n = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">ceil</span>(\n    <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">log</span>(simulation.<span class=\"hljs-title function_\">alphaMin</span>()) / <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-number\">1</span> - simulation.<span class=\"hljs-title function_\">alphaDecay</span>())\n  );\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) {\n    simulation.<span class=\"hljs-title function_\">tick</span>();\n  }\n\n  <span class=\"hljs-comment\">// 绘制</span>\n  <span class=\"hljs-keyword\">return</span> sp.<span class=\"hljs-title function_\">plot</span>({\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"layer\"</span>,\n    <span class=\"hljs-attr\">guides</span>: {\n      <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> },\n      <span class=\"hljs-attr\">y</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> },\n    },\n    <span class=\"hljs-attr\">children</span>: [\n      {\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"link\"</span>,\n        <span class=\"hljs-attr\">data</span>: links,\n        <span class=\"hljs-attr\">encodings</span>: {\n          <span class=\"hljs-attr\">x</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">source</span>.<span class=\"hljs-property\">x</span>,\n          <span class=\"hljs-attr\">y</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">source</span>.<span class=\"hljs-property\">y</span>,\n          <span class=\"hljs-attr\">x1</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">x</span>,\n          <span class=\"hljs-attr\">y1</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">y</span>,\n          <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"#ddd\"</span>,\n        },\n      },\n      {\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"point\"</span>,\n        <span class=\"hljs-attr\">data</span>: nodes,\n        <span class=\"hljs-attr\">encodings</span>: {\n          <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">\"x\"</span>,\n          <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">\"y\"</span>,\n          <span class=\"hljs-attr\">r</span>: <span class=\"hljs-number\">10</span>,\n          <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">type</span>,\n          <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">type</span>,\n        },\n        <span class=\"hljs-attr\">styles</span>: {\n          <span class=\"hljs-attr\">fillOpacity</span>: <span class=\"hljs-number\">0.7</span>,\n        },\n      },\n    ],\n  });\n})();\n</code></pre>\n<p>Sparrow 虽然可以快速绘制简单的力到导向图，但是不能展示每个节点的具体信息，所以接下来我们使用 AntV 的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fg6.antv.vision%2Fzh%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://g6.antv.vision/zh/\" ref=\"nofollow noopener noreferrer\">G6</a> 去绘制力导向图。</p>\n<h3 data-id=\"heading-4\">用 G6 绘制力导向图</h3>\n<p>在绘制力导图之前，我们需要简单了解一下 G6。G6 是图可视化引擎，它通过：</p>\n<ol>\n<li>通过多种图展现形式，让关系变得透明、简单</li>\n<li>多种视觉盛宴，让用户获得关系数据的 Insight</li>\n</ol>\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th align=\"center\">大规模图下钻探索模式</th><th align=\"center\">图说“水深火热”的澳大利亚道</th></tr></thead><tbody><tr><td align=\"center\"><img height=\"260\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54a69394c6c14b1f8228acb231ccc346~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" loading=\"lazy\" class=\"medium-zoom-image\"></td><td align=\"center\"><img height=\"260\" src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/100ad1db8c064ca7b915221c9b6377c2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr></tbody></table>\n<p>接下来我们分两步绘制力导图。</p>\n<ul>\n<li><strong>数据组装</strong></li>\n</ul>\n<p>由于 G6 对数据格式有一定的限制，我们需要将上面获取到的哲学家列表、问题列表和关系列表进行简单组装，输出为 G6 所需的 nodes 和 edges，通过颜色区分哲学家和问题。 我们将关系列表作为边，其它的作为节点，详细转换见线上 Demo。</p>\n<ul>\n<li>哲学家：绿色节点 <code>#BDEFDB</code></li>\n<li>问题：蓝色节点 <code>#BDD2FD</code></li>\n</ul>\n<pre><code class=\"hljs language-ts\" lang=\"ts\"><span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">nodes</span>: [\n    {\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">\"66\"</span>,\n      <span class=\"hljs-attr\">style</span>: { <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"#BDEFDB\"</span> },\n    },\n    {\n      <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">\"151\"</span>,\n      <span class=\"hljs-attr\">style</span>: { <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"#BDD2FD\"</span> },\n    },\n  ],\n  <span class=\"hljs-comment\">// 需要将 from、to 转换为 source、target</span>\n  <span class=\"hljs-attr\">edges</span>: [\n    {\n      <span class=\"hljs-attr\">source</span>: <span class=\"hljs-string\">\"151\"</span>,\n      <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">\"66\"</span>,\n    },\n  ],\n};\n</code></pre>\n<ul>\n<li><strong>使用 G6 绘制力导图</strong></li>\n</ul>\n<p>有了前面的准备工作，绘制力导图就很容易了。</p>\n<pre><code class=\"hljs language-ts\" lang=\"ts\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-variable constant_\">G6</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@antv/g6\"</span>;\n\n<span class=\"hljs-comment\">// 1. 创建图表容器</span>\n<span class=\"hljs-keyword\">const</span> graph = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-variable constant_\">G6</span>.<span class=\"hljs-title class_\">Graph</span>({\n  <span class=\"hljs-attr\">container</span>: <span class=\"hljs-string\">\"container\"</span>,\n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">800</span>,\n  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">600</span>,\n  <span class=\"hljs-attr\">layout</span>: {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"force\"</span>,\n    <span class=\"hljs-attr\">preventOverlap</span>: <span class=\"hljs-literal\">true</span>,\n  },\n});\n<span class=\"hljs-comment\">// 2. 转载第一步中处理好的数据</span>\ngraph.<span class=\"hljs-title function_\">data</span>(data);\n<span class=\"hljs-comment\">// 3. 渲染</span>\ngraph.<span class=\"hljs-title function_\">render</span>();\n</code></pre>\n<p>最后绘制出来的效果如下图所示。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19b5fa855d3246abbfe79faad92d4762~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h3 data-id=\"heading-5\">数据洞察</h3>\n<p>从中我们可以获取一些有效信息和洞察：</p>\n<ul>\n<li>一个哲学家/学派可能对多个问题感兴趣。</li>\n<li>有趣的问题往往能吸引更多哲学家。</li>\n</ul>\n<h2 data-id=\"heading-6\">延伸</h2>\n<h3 data-id=\"heading-7\">图布局</h3>\n<p>可视化是一种利用计算机图形学和图像处理技术，将数据转换成图形或图像在屏幕上显示出来，再进行交互处理的理论、方法和技术。数据在经过图可视化的方式展示后能够辅助用户去分析复杂的关系数据，从而发现数据中蕴含的价值。而图布局则是图可视化中非常重要的基石，对可视化图进行合理的布局可以帮助我们快速分析，准确定位问题。</p>\n<p>在可视化领域中常见的布局有树形布局、Dagre 布局、力导布局、同心圆布局、网格布局等。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th align=\"center\">布局方案</th><th align=\"center\">适用场景</th><th align=\"center\">示例</th></tr></thead><tbody><tr><td align=\"center\">力导布局</td><td align=\"center\">适用于描述事物间关系，比如社交网络关系、计算机网络关系、资金交易关系等各类关系网络场景</td><td align=\"center\"><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a90488b4f9bb4103a67457e92a15bcca~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr><tr><td align=\"center\">网格布局</td><td align=\"center\">节点按一定排序网状排开，适应于分层网络，便于看清整体层次</td><td align=\"center\"><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfc12334c191440fa658b8fb48147d23~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr><tr><td align=\"center\">同心圆布局</td><td align=\"center\">将节点按照度数排序，节点度数大的一群点会排列在最中心，度数小的节点会分布在最外层，使其以同心圆的方式排布，适应于快速查找出度数较多的节点</td><td align=\"center\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ad25286430b48ca88986278f3a10608~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr><tr><td align=\"center\">圆形布局</td><td align=\"center\">适用于查找关联关系较多的关键节点场景，例如在圆形布局的图中可以明显分辨出哪些节点关联关系较多</td><td align=\"center\"><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0892a9af60244935abcb3ad76b97a5ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr><tr><td align=\"center\">树形布局 / Dagre布局</td><td align=\"center\">适应于层次分明，或者需要严密拓扑性质的场景，比如分层网络图、流程图等</td><td align=\"center\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70f27da68f894dcb89ea59b49686f123~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr></tbody></table>\n<h3 data-id=\"heading-8\">G6</h3>\n<p>AntV G6 是一款开源的图可视化引擎，专注于图可视化及图分析，使用 G6，你可以发挥无限想象，创造出炫酷的图可视化。中文字“图”在大家的传统认知里指的是图画、图像，而图论与可视化中的“图”—— Graph 则有着更精确的定位：主体（objects）与关系（relationships）的组成。它甚至不局限于视觉，主体与关系的数据也可以称为图。</p>\n<blockquote>\n<p>摘自文章：Graph Visualization · 知多少 之 《HelloWorld 图可视化》。</p>\n</blockquote>\n<p>在 G6 中，Graph 对象是图的载体，它包含了图上的所有元素（节点、边等），同时挂载了图的相关操作（如交互监听、元素操作、渲染等）。</p>\n<p>Graph 对象的生命周期为：初始化 —&gt; 加载数据 —&gt; 渲染 —&gt; 更新 —&gt; 销毁。</p>\n<p>同时，G6 里面内置了大量的布局算法，例如模式匹配、最短路径、LOUVAIN 自动类聚等。</p>\n<p>如果想了解更多，可以去阅读 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fg6.antv.vision%2Fzh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://g6.antv.vision/zh\" ref=\"nofollow noopener noreferrer\">G6 官网教程</a>，未来将会发表的学术论文，更详细体系的介绍它的技术模块和架构。</p>\n<h2 data-id=\"heading-9\">小结</h2>\n<p>这一章我们知道了：“抽象的哲学问题又有谁来解？”，也简单认识了一下图可视化，那么接下来我们将继续探索下一个问题：“哲学流派的“组织架构”是啥样的？”</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "18\n分析：哲学流派的“组织架构”是啥样的？\n学习时长: 17分15秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>本章我们将会使用可视化完成 “哲学家和哲学流派的关系，哪些哲学家属于同一个流派？” 这个分析任务。</p>\n<h2 data-id=\"heading-0\">任务分析</h2>\n<p>首先我们需要拿到哲学家以及对应的哲学流派的关系数据，然后用一种可以表示包含关系的图表来进行可视化展示。</p>\n<ul>\n<li>将哲学家以及关联的哲学流派的数据关联起来，获得要分析的数据</li>\n<li>使用 CirclePacking 对数据进行可视化，通过这种图形嵌套的方式可以很好地看清数据的层次关系</li>\n<li>获取数据洞察</li>\n</ul>\n<h2 data-id=\"heading-1\">可视分析</h2>\n<h3 data-id=\"heading-2\">获取数据</h3>\n<p>相关数据在 Github 上（<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fchallenge-2021%2Fblob%2Fmain%2Fdata%2Fschools.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/challenge-2021/blob/main/data/schools.json\" ref=\"nofollow noopener noreferrer\">哲学流派</a>、<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fchallenge-2021%2Fblame%2Fmain%2Fdata%2Fphilosophers.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/challenge-2021/blame/main/data/philosophers.json\" ref=\"nofollow noopener noreferrer\">哲学家</a> 以及 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fchallenge-2021%2Fblame%2Fmain%2Fdata%2Frelations.csv\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/challenge-2021/blame/main/data/relations.csv\" ref=\"nofollow noopener noreferrer\">哲学家和哲学流派的关系数据</a>)</p>\n<h3 data-id=\"heading-3\">用 Sparrow 绘制 CirclePacking</h3>\n<p>在绘制 CirclePacking 之前，我们需要了解 CirclePacking。</p>\n<p>CirclePacking 也称为圆形树图，是矩阵树图的变体。它的图元使用的是圆圈而不是矩形，每个分支都表示为圆，其子分支表示为其内部的圆。每个圆的区域也可用于表示额外的任意值，如数量或文件大小，数值越大，圆的区域大小越大。</p>\n<p>此外，颜色也可以用于分配类别或通过不同的色调表示另一个变量。</p>\n<p>CirclePacking 不像矩阵树图那样空间效率高，因为圈子里有很多空位。尽管如此，CirclePacking 实际上揭示了比矩阵树图更好的层次结构。</p>\n<p>和力导向图一样，Sparrow 也没有实现 CirclePacking 的布局算法，所以这里我们使用 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fd3%2Fd3-hierarchy%23pack\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/d3/d3-hierarchy#pack\" ref=\"nofollow noopener noreferrer\">d3-hierarchy</a> 里面相关的布局算法。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17223bb4a900450bb321d363ef65418c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\">(<span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-comment\">// 请求数据</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">URLS</span> = [\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/d345d2d7-a35d-4d27-af92-4982b3e6b213.json\"</span>,\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/188bb992-7a9b-4e0e-a036-d1d0e4269738.json\"</span>,\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/61a39597-9564-4f7e-9eb3-3bdd2280061d.json\"</span>,\n  ];\n  <span class=\"hljs-keyword\">const</span> [people, schools, relations] = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(\n    <span class=\"hljs-variable constant_\">URLS</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">async</span> (url) =&gt; {\n      <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n    })\n  );\n\n  <span class=\"hljs-comment\">// 将表格数据转换成层次数据</span>\n  <span class=\"hljs-keyword\">const</span> sidPid = d3.<span class=\"hljs-title function_\">group</span>(\n    relations.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">type</span> === <span class=\"hljs-string\">\"0\"</span>),\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> +d.<span class=\"hljs-property\">from</span>\n  );\n  <span class=\"hljs-keyword\">const</span> pidData = d3.<span class=\"hljs-title function_\">group</span>(people, <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> +d.<span class=\"hljs-property\">id</span>);\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">name</span> = (<span class=\"hljs-params\">d</span>) =&gt; {\n    <span class=\"hljs-keyword\">const</span> { name } = d.<span class=\"hljs-property\">data</span>;\n    <span class=\"hljs-keyword\">return</span> name.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">4</span> ? name.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>) + <span class=\"hljs-string\">\"...\"</span> : name;\n  };\n  <span class=\"hljs-keyword\">const</span> data = {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"哲学家\"</span>,\n    <span class=\"hljs-attr\">children</span>: schools\n      .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ id }</span>) =&gt;</span> sidPid.<span class=\"hljs-title function_\">has</span>(id))\n      .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ name, id }</span>) =&gt;</span> ({\n        name,\n        <span class=\"hljs-attr\">children</span>: <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(sidPid.<span class=\"hljs-title function_\">get</span>(id)).<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> {\n          <span class=\"hljs-keyword\">const</span> [people] = pidData.<span class=\"hljs-title function_\">get</span>(+d.<span class=\"hljs-property\">to</span>);\n          <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-attr\">name</span>: people.<span class=\"hljs-property\">name</span>,\n          };\n        }),\n      })),\n  };\n\n  <span class=\"hljs-comment\">// 计算布局</span>\n  <span class=\"hljs-keyword\">const</span> width = <span class=\"hljs-number\">800</span>;\n  <span class=\"hljs-keyword\">const</span> height = <span class=\"hljs-number\">800</span>;\n  <span class=\"hljs-keyword\">const</span> margin = <span class=\"hljs-number\">5</span>;\n  <span class=\"hljs-keyword\">const</span> padding = <span class=\"hljs-number\">5</span>;\n  <span class=\"hljs-keyword\">const</span> root = d3.<span class=\"hljs-title function_\">hierarchy</span>(data);\n  root.<span class=\"hljs-title function_\">count</span>();\n\n  <span class=\"hljs-keyword\">const</span> descendants = root.<span class=\"hljs-title function_\">descendants</span>();\n  d3\n    .<span class=\"hljs-title function_\">pack</span>()\n    .<span class=\"hljs-title function_\">size</span>([width - margin * <span class=\"hljs-number\">2</span>, height - margin * <span class=\"hljs-number\">2</span>])\n    .<span class=\"hljs-title function_\">padding</span>(padding)(root);\n   \n  <span class=\"hljs-comment\">// 绘制</span>\n  <span class=\"hljs-keyword\">return</span> sp.<span class=\"hljs-title function_\">plot</span>({\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"layer\"</span>,\n    <span class=\"hljs-attr\">data</span>: descendants,\n    width,\n    height,\n    <span class=\"hljs-attr\">guides</span>: {\n      <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> },\n      <span class=\"hljs-attr\">y</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> },\n      <span class=\"hljs-attr\">color</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> },\n    },\n    <span class=\"hljs-attr\">scales</span>: {\n      <span class=\"hljs-attr\">r</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"identity\"</span> },\n      <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, width - margin * <span class=\"hljs-number\">2</span>] },\n      <span class=\"hljs-attr\">y</span>: { <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, height - margin * <span class=\"hljs-number\">2</span>], <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>] },\n    },\n    <span class=\"hljs-attr\">encodings</span>: {\n      <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">\"x\"</span>,\n      <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">\"y\"</span>,\n    },\n    <span class=\"hljs-attr\">children</span>: [\n      {\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"point\"</span>,\n        <span class=\"hljs-attr\">paddingLeft</span>: margin,\n        <span class=\"hljs-attr\">paddingRight</span>: margin,\n        <span class=\"hljs-attr\">paddingBottom</span>: margin,\n        <span class=\"hljs-attr\">paddingTop</span>: margin,\n        <span class=\"hljs-attr\">encodings</span>: {\n          <span class=\"hljs-attr\">r</span>: <span class=\"hljs-string\">\"r\"</span>,\n          <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"height\"</span>,\n          <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"height\"</span>,\n        },\n      },\n      {\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"text\"</span>,\n        <span class=\"hljs-attr\">transforms</span>: [<span class=\"hljs-function\">(<span class=\"hljs-params\">data</span>) =&gt;</span> data.<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">height</span> === <span class=\"hljs-number\">0</span>)],\n        <span class=\"hljs-attr\">encodings</span>: {\n          <span class=\"hljs-attr\">text</span>: name,\n        },\n        <span class=\"hljs-attr\">styles</span>: {\n          <span class=\"hljs-attr\">textAnchor</span>: <span class=\"hljs-string\">\"middle\"</span>,\n          <span class=\"hljs-attr\">dy</span>: <span class=\"hljs-string\">\"0.5em\"</span>,\n        },\n      },\n    ],\n  });\n})();\n</code></pre>\n<p>Sparrow 虽然可以如上去绘制 CirclePacking，但是还是会比较麻烦，接下来我们就用 AntV 的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fg2plot.antv.vision%2Fzh%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://g2plot.antv.vision/zh/\" ref=\"nofollow noopener noreferrer\">G2Plot</a> 去实现相同的效果。</p>\n<h3 data-id=\"heading-4\">G2Plot 绘制 Circle Packing</h3>\n<p>了解之后，我们可以直接使用 G2Plot CirclePacking 来进行绘制：</p>\n<ol>\n<li>数据处理成树型结构。处理完成的数据结构大概如下：</li>\n</ol>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> data = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"哲学家\"</span>,\n  <span class=\"hljs-attr\">children</span>: [\n    { \n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"自然学派\"</span>,\n      <span class=\"hljs-attr\">children</span>: [\n        { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"泰利斯\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span> },\n        { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"安纳克西曼德\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span> },\n        <span class=\"hljs-comment\">// ...</span>\n      ]\n    },\n    { \n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"雅典的哲学\"</span>,\n      <span class=\"hljs-attr\">children</span>: [\n        { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"普罗塔格拉斯\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span> },\n        { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"苏格拉底\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span> },\n        <span class=\"hljs-comment\">// ...</span>\n      ]\n    },\n    {\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"希腊哲学\"</span>,\n      <span class=\"hljs-attr\">children</span>: [\n        { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"第欧根尼\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span> },\n        { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"伊壁鸠鲁\"</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">1</span> },\n        <span class=\"hljs-comment\">// ...</span>\n      ]\n    },\n    <span class=\"hljs-comment\">// ...</span>\n  ]\n}\n</code></pre>\n<ol start=\"2\">\n<li>使用 G2Plot 绘制</li>\n</ol>\n<p>在这里，我们按照分类的大小 <code>r</code>(数据中对应的是 <code>r</code> 字段对应的数值) 来设置颜色，以增强区分度：</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-comment\">// 前提，需要有一个图表容器: html`&lt;div id=\"container\"&gt;&lt;/div&gt;`</span>\n<span class=\"hljs-keyword\">const</span> plot = <span class=\"hljs-keyword\">new</span> G2Plot.<span class=\"hljs-title class_\">CirclePacking</span>(<span class=\"hljs-string\">'container'</span>, {\n  <span class=\"hljs-attr\">width</span>: <span class=\"hljs-number\">600</span>,\n  <span class=\"hljs-attr\">height</span>: <span class=\"hljs-number\">600</span>,\n  <span class=\"hljs-attr\">appendPadding</span>: <span class=\"hljs-number\">30</span>,\n  <span class=\"hljs-attr\">autoFit</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">padding</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-title function_\">getCirclePackingData</span>(),\n  <span class=\"hljs-attr\">colorField</span>: <span class=\"hljs-string\">'r'</span>,\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'rgb(252, 253, 191)-rgb(231, 82, 99)-rgb(183, 55, 121)'</span>,\n  <span class=\"hljs-attr\">pointStyle</span>: {\n    <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">'rgb(183, 55, 121)'</span>,\n    <span class=\"hljs-attr\">lineWidth</span>: <span class=\"hljs-number\">0.5</span>\n  },\n  <span class=\"hljs-attr\">legend</span>: <span class=\"hljs-literal\">false</span>\n});\n\nplot.<span class=\"hljs-title function_\">render</span>();\n</code></pre>\n<h3 data-id=\"heading-5\">数据洞察</h3>\n<p>下图是绘制出来的可视化结果：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76414317912846528fc0b19326d48afd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>从中我们可以洞察到：</p>\n<ul>\n<li>绝大多数的哲学家倾向于“自然学派”（最大的那个圆，对应的颜色也是最深的）。</li>\n<li>而类似于“共产主义”、“存在主义”、“理性主义”和“个人主义”代表的哲学家就相对较少。</li>\n</ul>\n<h2 data-id=\"heading-6\">延伸</h2>\n<h3 data-id=\"heading-7\">G2Plot</h3>\n<p>G2Plot 是基于 G2 封装的开箱即用、易于配置、具有良好视觉和交互体验的通用统计图表库。它主要以图表分类学的角度去封装，既减少用户理解图形语法的成本、降低上手门槛，也基于 AntV 的可视化设计原则做了交互体验优化。</p>\n<p>G2Plot 的核心技术架构非常简单，所有的 Plot 图表都继承于一个基类，基类为所有的图表提供的了通用的 API 方法，而每个具体的可视化图表仅仅处理自己不同的配置项。所以 API 部分，所有图表基本都是一样，除了部分图表（比如：仪表盘、水波图）在 changeData API 上有细微的区别。</p>\n<p>如果想了解更多，可以去阅读 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fg2plot.antv.vision%2Fzh\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://g2plot.antv.vision/zh\" ref=\"nofollow noopener noreferrer\">G2Plot 官网教程</a>，官网也提供了较多的案例 demo，方便业务直接取用自己需要的图表。</p>\n<h2 data-id=\"heading-8\">小结</h2>\n<p>这一章我们探索了：“哲学流派的“组织架构”是啥样的？”，又了解一种可视化层次数据的办法。那么下一章我们去探索：“西方哲学中心的“迁徙之旅”，同时简单了解一下地理可视化相关的东西。</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "19\n分析：西方哲学中心的“迁徙之旅”\n学习时长: 44分52秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>本章我们将以地理视角看哲学家，学会使用地理可视化完成 “苏菲的世界中，哲学中心如何变化？” 这个任务。</p>\n<h2 data-id=\"heading-0\">任务分析</h2>\n<p>我们要分析哲学家的地理位置分布，首先需要找到与“地理”相关的信息，这里刚好有哲学家的所在国家名，我们以哲学家的所在国家作为地理数据，就可以分析“哲学家所在国家分布情况”，然后我们可以利用哲学家的出生日期来分析“哲学中心如何变化”。</p>\n<p>大致需要以下几步完成任务</p>\n<ul>\n<li>拾取全世界各个国家的地理数据</li>\n<li>将国家名与拾取到的国家地理进行关联</li>\n<li>使用地理数据可视化库 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7\" ref=\"nofollow noopener noreferrer\">L7</a> &amp; <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7Plot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7Plot\" ref=\"nofollow noopener noreferrer\">L7Plot</a> 将数据给可视化出来</li>\n<li>获取数据洞察</li>\n</ul>\n<p>下面按照这几个步骤，实现一个哲学家所在国的区域分布图与哲学中心变化图，并从中获得数据洞察。</p>\n<h2 data-id=\"heading-1\">可视分析</h2>\n<h3 data-id=\"heading-2\">获取数据</h3>\n<p>我们要分析的数据”<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fchallenge-2021%2Fblob%2Fmain%2Fdata%2Fphilosophers.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/challenge-2021/blob/main/data/philosophers.json\" ref=\"nofollow noopener noreferrer\">哲学家的所在国家</a>”，数据格式如下：</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th align=\"left\">name</th><th>points</th><th>lifespan</th><th>country</th></tr></thead><tbody><tr><td align=\"left\">泰利斯</td><td>\"水是万物之源。\"</td><td>[-624, -546]</td><td>希腊</td></tr><tr><td align=\"left\">安纳克西曼德</td><td>\"形成万物的物质不可能是一定是这些已经被创造出来的物质。\"</td><td>[-610, -546]</td><td>希腊</td></tr><tr><td align=\"left\">亚里士多德</td><td>\"现实生活中最高层次的事物不是那些我们用理性来探索的事物，而是我们用感官察觉的事物。\",\"事物是由本身的形式与质料和谐一致的事物所构成的，质料总是致力于实现一种内在的可能性。\"</td><td>[-384, -322]</td><td>雅典</td></tr><tr><td align=\"left\">苏格拉底</td><td>\"我只知道一件事情，就是我一无所知。\", \"明辨是非的能力就存在于人的理性中，而不存在于社会中。\"</td><td>[-470, -399]</td><td>雅典</td></tr><tr><td align=\"left\">普罗汀</td><td>\"宇宙间万事万物都是一体的，因为上帝存在于万事万物之中。\"</td><td>[-270, -205]</td><td>意大利</td></tr></tbody></table>\n<p>接下来拾取全世界各个<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fchallenge-2021%2Fblob%2Fgeo-map%2Fdata%2Fcountrys.json\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/challenge-2021/blob/geo-map/data/countrys.json\" ref=\"nofollow noopener noreferrer\">国家的地理数据</a>，这里使用地理数据共享开源组织 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fdownload.geofabrik.de%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://download.geofabrik.de/\" ref=\"nofollow noopener noreferrer\">openstreetmap</a> 的数据，为了方便使用采用 GeoJson 格式的地理数据，数据格式如下：</p>\n<pre><code class=\"hljs language-json\" lang=\"json\"><span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">\"type\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"FeatureCollection\"</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">\"features\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span>\n    <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">\"type\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"Feature\"</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">\"geometry\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">\"type\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"Polygon\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"coordinates\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span> <span class=\"hljs-comment\">// ... ]</span>\n      <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">\"properties\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">\"name\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"希腊\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"centroid\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">22.989178297364294</span><span class=\"hljs-punctuation\">,</span><span class=\"hljs-number\">39.04355317366236</span><span class=\"hljs-punctuation\">]</span>\n      <span class=\"hljs-punctuation\">}</span>\n    <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-attr\">\"type\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"Feature\"</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">\"geometry\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">\"type\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"Polygon\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"coordinates\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span> <span class=\"hljs-comment\">// ... ]</span>\n      <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n      <span class=\"hljs-attr\">\"properties\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">\"name\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">\"意大利\"</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">\"centroid\"</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">12.075174042231398</span><span class=\"hljs-punctuation\">,</span><span class=\"hljs-number\">42.78877076169903</span><span class=\"hljs-punctuation\">]</span>\n      <span class=\"hljs-punctuation\">}</span>\n    <span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-punctuation\">]</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<h3 data-id=\"heading-3\">Sparrow 绘制气泡地图</h3>\n<p>有了数据之后，我们首先尝试用 Sparrow 去绘制一个气泡地图。如果在书中出现了该国家的哲学家，那么这个国家会有一个气泡，出现的哲学家数量越多，这个地方的气泡越大。</p>\n<p>同样 Sparrow 本身不具备计算地图路径的能力，所以这个地方我们借助 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fd3%2Fd3-geo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/d3/d3-geo\" ref=\"nofollow noopener noreferrer\">d3-geo</a> 去完成我们的可视化。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6c35274a9d04dcea366b3483346a6a1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<pre><code class=\"hljs language-js\" lang=\"js\">(<span class=\"hljs-keyword\">async</span> () =&gt; {\n  <span class=\"hljs-comment\">//@see https://observablehq.com/@d3/world-airports?collection=@d3/d3-geo</span>\n\n  <span class=\"hljs-comment\">// 获取数据</span>\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">URLS</span> = [\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/a51018d2-69ef-4e6b-8095-5d4f5815166e.json\"</span>,\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/d345d2d7-a35d-4d27-af92-4982b3e6b213.json\"</span>,\n    <span class=\"hljs-string\">\"https://gw.alipayobjects.com/os/bmw-prod/1070dc04-329e-4655-95b0-f1dc094206b1.json\"</span>,\n  ];\n  <span class=\"hljs-keyword\">const</span> [world, people, country] = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>(\n    <span class=\"hljs-variable constant_\">URLS</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">async</span> (url) =&gt; {\n      <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url);\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> response.<span class=\"hljs-title function_\">json</span>();\n    })\n  );\n\n  <span class=\"hljs-keyword\">const</span> projection = d3.<span class=\"hljs-title function_\">geoNaturalEarth1</span>();\n\n  <span class=\"hljs-comment\">// 确定视图大小</span>\n  <span class=\"hljs-keyword\">const</span> outline = { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"Sphere\"</span> };\n  <span class=\"hljs-keyword\">const</span> width = <span class=\"hljs-number\">800</span>;\n  <span class=\"hljs-keyword\">const</span> height = (<span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> [[x0, y0], [x1, y1]] = d3\n      .<span class=\"hljs-title function_\">geoPath</span>(projection.<span class=\"hljs-title function_\">fitWidth</span>(width, outline))\n      .<span class=\"hljs-title function_\">bounds</span>(outline);\n    <span class=\"hljs-keyword\">const</span> dy = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">ceil</span>(y1 - y0),\n      l = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">min</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">ceil</span>(x1 - x0), dy);\n    projection.<span class=\"hljs-title function_\">scale</span>((projection.<span class=\"hljs-title function_\">scale</span>() * (l - <span class=\"hljs-number\">1</span>)) / l).<span class=\"hljs-title function_\">precision</span>(<span class=\"hljs-number\">0.2</span>);\n    <span class=\"hljs-keyword\">return</span> dy;\n  })();\n\n  <span class=\"hljs-comment\">// compute paths data</span>\n  <span class=\"hljs-keyword\">const</span> path = d3.<span class=\"hljs-title function_\">geoPath</span>(projection);\n  <span class=\"hljs-keyword\">const</span> land = topojson.<span class=\"hljs-title function_\">feature</span>(world, world.<span class=\"hljs-property\">objects</span>.<span class=\"hljs-property\">land</span>);\n  <span class=\"hljs-keyword\">const</span> graticule = d3.<span class=\"hljs-title function_\">geoGraticule10</span>();\n  <span class=\"hljs-keyword\">const</span> paths = [\n    { <span class=\"hljs-attr\">d</span>: <span class=\"hljs-title function_\">path</span>(land), <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"#ddd\"</span>, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"none\"</span> },\n    { <span class=\"hljs-attr\">d</span>: <span class=\"hljs-title function_\">path</span>(graticule), <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"none\"</span>, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"#ddd\"</span> },\n    { <span class=\"hljs-attr\">d</span>: <span class=\"hljs-title function_\">path</span>(outline), <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"none\"</span>, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"black\"</span> },\n  ];\n\n  <span class=\"hljs-comment\">// 计算气泡数据</span>\n  <span class=\"hljs-keyword\">const</span> countryCentroid = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(\n    country.<span class=\"hljs-property\">features</span>\n      .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">properties</span>.<span class=\"hljs-property\">name</span>)\n      .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> [d.<span class=\"hljs-property\">properties</span>.<span class=\"hljs-property\">name</span>, d.<span class=\"hljs-property\">properties</span>.<span class=\"hljs-property\">centroid</span>])\n  );\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">countryName</span> = (<span class=\"hljs-params\">d</span>) =&gt; (d === <span class=\"hljs-string\">\"雅典\"</span> ? <span class=\"hljs-string\">\"希腊\"</span> : d);\n  <span class=\"hljs-keyword\">const</span> countries = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(\n    d3.<span class=\"hljs-title function_\">group</span>(people, <span class=\"hljs-function\">(<span class=\"hljs-params\">d</span>) =&gt;</span> d.<span class=\"hljs-property\">country</span>),\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">[country, people]</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> [x, y] = <span class=\"hljs-title function_\">projection</span>(countryCentroid.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-title function_\">countryName</span>(country)));\n      <span class=\"hljs-keyword\">return</span> {\n        country,\n        <span class=\"hljs-attr\">count</span>: people.<span class=\"hljs-property\">length</span>,\n        x,\n        y,\n      };\n    }\n  );\n\n  <span class=\"hljs-comment\">// 绘制</span>\n  <span class=\"hljs-keyword\">return</span> sp.<span class=\"hljs-title function_\">plot</span>({\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"layer\"</span>,\n    width,\n    height,\n    <span class=\"hljs-attr\">children</span>: [\n      {\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"path\"</span>,\n        <span class=\"hljs-attr\">data</span>: paths,\n        <span class=\"hljs-attr\">scales</span>: {\n          <span class=\"hljs-attr\">color</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"identity\"</span> },\n        },\n        <span class=\"hljs-attr\">guides</span>: { <span class=\"hljs-attr\">color</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> } },\n        <span class=\"hljs-attr\">encodings</span>: {\n          <span class=\"hljs-attr\">d</span>: <span class=\"hljs-string\">\"d\"</span>,\n          <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"fill\"</span>,\n          <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"stroke\"</span>,\n        },\n      },\n      {\n        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"point\"</span>,\n        <span class=\"hljs-attr\">guides</span>: { <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> }, <span class=\"hljs-attr\">y</span>: { <span class=\"hljs-attr\">display</span>: <span class=\"hljs-literal\">false</span> } },\n        <span class=\"hljs-attr\">scales</span>: {\n          <span class=\"hljs-attr\">y</span>: { <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>], <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, height] },\n          <span class=\"hljs-attr\">x</span>: { <span class=\"hljs-attr\">domain</span>: [<span class=\"hljs-number\">0</span>, width] },\n          <span class=\"hljs-attr\">r</span>: { <span class=\"hljs-attr\">range</span>: [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>] },\n        },\n        <span class=\"hljs-attr\">paddingLeft</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attr\">paddingTop</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attr\">paddingBottom</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attr\">paddingRight</span>: <span class=\"hljs-number\">0</span>,\n        <span class=\"hljs-attr\">data</span>: countries,\n        <span class=\"hljs-attr\">encodings</span>: {\n          <span class=\"hljs-attr\">x</span>: <span class=\"hljs-string\">\"x\"</span>,\n          <span class=\"hljs-attr\">y</span>: <span class=\"hljs-string\">\"y\"</span>,\n          <span class=\"hljs-attr\">r</span>: <span class=\"hljs-string\">\"count\"</span>,\n          <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"steelblue\"</span>,\n          <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"steelblue\"</span>,\n        },\n      },\n    ],\n  });\n})();\n</code></pre>\n<p>虽然 Sparrow 已经把一个简单的地图绘制完成了，但是可以发现过程还是比较繁琐的，为了解决这个问题，我们来看看 AntV 的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fl7.antv.vision%2Fzh%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://l7.antv.vision/zh/\" ref=\"nofollow noopener noreferrer\">L7</a> 是如何绘制地图的。</p>\n<h3 data-id=\"heading-4\">L7 绘制地图</h3>\n<p>L7 同样需要把地理数据给关联上，通过国家名称字段将我们拾取的地理数据关联，最后将数据处为理常用的 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgeojson.org%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://geojson.org/\" ref=\"nofollow noopener noreferrer\">GeoJson</a> 格式，需要注意的是，数据中的“雅典”是“希腊”的首都。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MappingName</span> = { 雅典: <span class=\"hljs-string\">\"希腊\"</span> };\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">joinData</span> = (<span class=\"hljs-params\">philosophers, geoData</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> philosopherCountryMap = philosophers.<span class=\"hljs-title function_\">reduce</span>(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">countryMap, philosopher</span>) =&gt;</span> {\n      <span class=\"hljs-keyword\">const</span> { country } = philosopher;\n      <span class=\"hljs-keyword\">const</span> mappingCountry = <span class=\"hljs-title class_\">MappingName</span>[country] || country;\n      <span class=\"hljs-keyword\">if</span> (countryMap[mappingCountry]) {\n        countryMap[mappingCountry].<span class=\"hljs-title function_\">push</span>(philosopher);\n      } <span class=\"hljs-keyword\">else</span> {\n        countryMap[mappingCountry] = [philosopher];\n      }\n      <span class=\"hljs-keyword\">return</span> countryMap;\n    },\n    {}\n  );\n  <span class=\"hljs-keyword\">const</span> features = geoData.<span class=\"hljs-property\">features</span>.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">feature</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">const</span> countryName = feature.<span class=\"hljs-property\">properties</span>.<span class=\"hljs-property\">name</span>;\n    <span class=\"hljs-keyword\">const</span> philosophers = philosopherCountryMap[countryName] || [];\n    <span class=\"hljs-keyword\">const</span> philosopherSum = philosophers.<span class=\"hljs-property\">length</span>;\n    <span class=\"hljs-keyword\">const</span> currentFeature = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>({}, feature, {\n      <span class=\"hljs-attr\">properties</span>: {\n        ...feature.<span class=\"hljs-property\">properties</span>,\n        philosophers,\n        philosopherSum,\n      },\n    });\n\n    <span class=\"hljs-keyword\">return</span> currentFeature;\n  });\n  <span class=\"hljs-keyword\">const</span> geoPhilosophers = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>({}, geoData, { features });\n\n  <span class=\"hljs-keyword\">return</span> geoPhilosophers;\n};\n</code></pre>\n<p>我们有了数据，就可以开始利用数据做可视分析了。根据数据中各个国家的哲学家数量，我们先来实现一个<strong>气泡图</strong>，气泡的地理位置采用国家的行政中心，\n气泡大小与各个国家的哲学家数量正相关，这里可视化库我们使用 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7\" ref=\"nofollow noopener noreferrer\">L7</a> 。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Scene</span>, <span class=\"hljs-title class_\">Mapbox</span>, <span class=\"hljs-title class_\">PointLayer</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@antv/l7\"</span>;\n<span class=\"hljs-keyword\">import</span> countrys <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./countrys.json\"</span>;\n<span class=\"hljs-keyword\">import</span> philosophers <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./philosophers.json\"</span>;\n\n<span class=\"hljs-comment\">// 1. 创建场景，并创建 Mapbox 作为地图的底图</span>\n<span class=\"hljs-keyword\">const</span> scene = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scene</span>({\n  <span class=\"hljs-attr\">id</span>: container,\n  <span class=\"hljs-attr\">map</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Mapbox</span>({\n    <span class=\"hljs-attr\">style</span>: <span class=\"hljs-string\">\"light\"</span>,\n    <span class=\"hljs-attr\">pitch</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">zoom</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">center</span>: [<span class=\"hljs-number\">43.3573729</span>, <span class=\"hljs-number\">9.5221543</span>],\n  }),\n});\n\n<span class=\"hljs-comment\">// 2. 生成地理数据</span>\n<span class=\"hljs-keyword\">const</span> geoPhilosophers = <span class=\"hljs-title function_\">joinData</span>(philosophers, countrys);\n<span class=\"hljs-keyword\">const</span> geoPositions = geoPhilosophers.<span class=\"hljs-property\">features</span>\n  .<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ properties }</span>) =&gt;</span> properties)\n  .<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">{ philosopherSum }</span>) =&gt;</span> philosopherSum);\n\n<span class=\"hljs-comment\">// 3. 创建气泡图层，并将气泡大小映射到数据字段上</span>\n<span class=\"hljs-keyword\">const</span> pointLayer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PointLayer</span>({\n  <span class=\"hljs-attr\">autoFit</span>: <span class=\"hljs-literal\">true</span>,\n})\n  .<span class=\"hljs-title function_\">source</span>(geoPositions, {\n    <span class=\"hljs-attr\">parser</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"json\"</span>, <span class=\"hljs-attr\">coordinates</span>: <span class=\"hljs-string\">\"centroid\"</span> },\n  })\n  .<span class=\"hljs-title function_\">shape</span>(<span class=\"hljs-string\">\"circle\"</span>)\n  .<span class=\"hljs-title function_\">size</span>(<span class=\"hljs-string\">\"philosopherSum\"</span>, [<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">60</span>])\n  .<span class=\"hljs-title function_\">color</span>(<span class=\"hljs-string\">\"#204CCF\"</span>)\n  .<span class=\"hljs-title function_\">style</span>({ <span class=\"hljs-attr\">opacity</span>: <span class=\"hljs-number\">0.6</span> });\n\n<span class=\"hljs-comment\">// 4. 创建文本标注图层</span>\n<span class=\"hljs-keyword\">const</span> labelLayer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">PointLayer</span>({})\n  .<span class=\"hljs-title function_\">source</span>(geoPositions, {\n    <span class=\"hljs-attr\">parser</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"json\"</span>, <span class=\"hljs-attr\">coordinates</span>: <span class=\"hljs-string\">\"centroid\"</span> },\n  })\n  .<span class=\"hljs-title function_\">shape</span>(<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"text\"</span>)\n  .<span class=\"hljs-title function_\">size</span>(<span class=\"hljs-number\">10</span>)\n  .<span class=\"hljs-title function_\">color</span>(<span class=\"hljs-string\">\"#000\"</span>)\n  .<span class=\"hljs-title function_\">style</span>({ <span class=\"hljs-attr\">opacity</span>: <span class=\"hljs-number\">0.8</span>, <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"#fff\"</span>, <span class=\"hljs-attr\">strokeWidth</span>: <span class=\"hljs-number\">2</span> });\n\n<span class=\"hljs-comment\">// 5. 将图层挂载到场景上</span>\nscene.<span class=\"hljs-title function_\">addLayer</span>(pointLayer);\nscene.<span class=\"hljs-title function_\">addLayer</span>(labelLayer);\n</code></pre>\n<p>绘制出来的效果见下图。从图中可以看出，利用气泡的方式只能看国家点的分布，接下来我们来做国家区域分布的图，利用区域的颜色映射哲学家的数量，这里使用 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7Plot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7Plot\" ref=\"nofollow noopener noreferrer\">L7Plot</a> 来完成一个<strong>区域分布图</strong>，关于 L7 与 L7Plot 的关系见后文“延伸”部分。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Area</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@antv/l7plot\"</span>;\n<span class=\"hljs-keyword\">import</span> countrys <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./countrys.json\"</span>;\n<span class=\"hljs-keyword\">import</span> philosophers <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./philosophers.json\"</span>;\n\n<span class=\"hljs-comment\">// 1. 生成地理数据</span>\n<span class=\"hljs-keyword\">const</span> geoPhilosophers = <span class=\"hljs-title function_\">joinData</span>(philosophers, countrys);\n\n<span class=\"hljs-comment\">// 2. 创建图表</span>\n<span class=\"hljs-keyword\">const</span> areaMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Area</span>(container, {\n  <span class=\"hljs-attr\">map</span>: {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"mapbox\"</span>,\n    <span class=\"hljs-attr\">style</span>: <span class=\"hljs-string\">\"light\"</span>,\n    <span class=\"hljs-attr\">pitch</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">zoom</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">center</span>: [<span class=\"hljs-number\">12.075174042231398</span>, <span class=\"hljs-number\">42.78877076169903</span>],\n  },\n  <span class=\"hljs-attr\">source</span>: {\n    <span class=\"hljs-attr\">data</span>: geoPhilosophers,\n    <span class=\"hljs-attr\">parser</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"geojson\"</span> },\n  },\n  <span class=\"hljs-attr\">autoFit</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">color</span>: {\n    <span class=\"hljs-attr\">field</span>: <span class=\"hljs-string\">\"philosopherSum\"</span>,\n    <span class=\"hljs-attr\">value</span>: [<span class=\"hljs-string\">\"#B8E1FF\"</span>, <span class=\"hljs-string\">\"#7DAAFF\"</span>, <span class=\"hljs-string\">\"#3D76DD\"</span>, <span class=\"hljs-string\">\"#0047A5\"</span>],\n    <span class=\"hljs-attr\">scale</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"quantize\"</span> },\n  },\n  <span class=\"hljs-attr\">style</span>: {\n    <span class=\"hljs-attr\">opacity</span>: <span class=\"hljs-number\">0.8</span>,\n    <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"#F2F7F7\"</span>,\n    <span class=\"hljs-attr\">lineType</span>: <span class=\"hljs-string\">\"dash\"</span>,\n    <span class=\"hljs-attr\">lineDash</span>: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>],\n    <span class=\"hljs-attr\">lineWidth</span>: <span class=\"hljs-number\">0.6</span>,\n    <span class=\"hljs-attr\">lineOpacity</span>: <span class=\"hljs-number\">0.8</span>,\n  },\n  <span class=\"hljs-attr\">label</span>: {\n    <span class=\"hljs-attr\">field</span>: <span class=\"hljs-string\">\"name\"</span>,\n    <span class=\"hljs-attr\">style</span>: { <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"#000\"</span>, <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"#fff\"</span>, <span class=\"hljs-attr\">strokeWidth</span>: <span class=\"hljs-number\">2</span> },\n  },\n  <span class=\"hljs-attr\">tooltip</span>: { <span class=\"hljs-attr\">items</span>: [<span class=\"hljs-string\">\"name\"</span>, <span class=\"hljs-string\">\"adcode\"</span>] },\n  <span class=\"hljs-attr\">zoom</span>: { <span class=\"hljs-attr\">position</span>: <span class=\"hljs-string\">\"bottomright\"</span> },\n  <span class=\"hljs-attr\">legend</span>: { <span class=\"hljs-attr\">position</span>: <span class=\"hljs-string\">\"bottomleft\"</span> },\n});\n</code></pre>\n<p>绘制出来的效果见下图。接下来我们以哲学家的出生日期为时间线，对相同生平区间的哲学家进行分组，来做一个哲学区域变化图，以时间递增顺序渲染哲学区域。</p>\n<pre><code class=\"hljs language-js\" lang=\"js\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title class_\">Area</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"@antv/l7plot\"</span>;\n<span class=\"hljs-keyword\">import</span> countrys <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./countrys.json\"</span>;\n<span class=\"hljs-keyword\">import</span> philosophers <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./philosophers.json\"</span>;\n\n<span class=\"hljs-comment\">// 1. 以时间顺序对相同生平区间的哲学家进行分组</span>\n<span class=\"hljs-keyword\">const</span> philosopherGroups = philosophers.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">groups, philosopher</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (groups.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> [[philosopher]];\n  <span class=\"hljs-keyword\">const</span> lastGroup = groups[groups.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>];\n  <span class=\"hljs-keyword\">const</span> lastPhilosopherLifeEndTime =\n    lastGroup[lastGroup.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>].<span class=\"hljs-property\">lifespan</span>[<span class=\"hljs-number\">1</span>];\n  <span class=\"hljs-keyword\">const</span> currentPhilosopherLifeStartTime = philosopher.<span class=\"hljs-property\">lifespan</span>[<span class=\"hljs-number\">0</span>];\n  <span class=\"hljs-keyword\">if</span> (lastPhilosopherLifeEndTime &gt;= currentPhilosopherLifeStartTime) {\n    lastGroup.<span class=\"hljs-title function_\">push</span>(philosopher);\n  } <span class=\"hljs-keyword\">else</span> {\n    groups.<span class=\"hljs-title function_\">push</span>([philosopher]);\n  }\n  <span class=\"hljs-keyword\">return</span> groups;\n}, []);\n\n<span class=\"hljs-comment\">// 2. 创建图表</span>\n<span class=\"hljs-keyword\">const</span> areaMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Area</span>(container, {\n  <span class=\"hljs-attr\">map</span>: {\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"mapbox\"</span>,\n    <span class=\"hljs-attr\">style</span>: <span class=\"hljs-string\">\"light\"</span>,\n    <span class=\"hljs-attr\">center</span>: [<span class=\"hljs-number\">20.3573729</span>, <span class=\"hljs-number\">40.5221543</span>],\n    <span class=\"hljs-attr\">zoom</span>: <span class=\"hljs-number\">3</span>,\n    <span class=\"hljs-attr\">pitch</span>: <span class=\"hljs-number\">0</span>,\n  },\n  <span class=\"hljs-attr\">source</span>: {\n    <span class=\"hljs-attr\">data</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"FeatureCollection\"</span>, <span class=\"hljs-attr\">features</span>: [] },\n    <span class=\"hljs-attr\">parser</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"geojson\"</span> },\n  },\n  <span class=\"hljs-attr\">autoFit</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">color</span>: {\n    <span class=\"hljs-attr\">field</span>: <span class=\"hljs-string\">\"philosopherSum\"</span>,\n    <span class=\"hljs-attr\">value</span>: [<span class=\"hljs-string\">\"#B8E1FF\"</span>, <span class=\"hljs-string\">\"#7DAAFF\"</span>, <span class=\"hljs-string\">\"#3D76DD\"</span>, <span class=\"hljs-string\">\"#0047A5\"</span>],\n    <span class=\"hljs-attr\">scale</span>: { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"quantize\"</span> },\n  },\n  <span class=\"hljs-attr\">style</span>: {\n    <span class=\"hljs-attr\">opacity</span>: <span class=\"hljs-number\">0.8</span>,\n    <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"#F2F7F7\"</span>,\n    <span class=\"hljs-attr\">lineType</span>: <span class=\"hljs-string\">\"dash\"</span>,\n    <span class=\"hljs-attr\">lineDash</span>: [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>],\n    <span class=\"hljs-attr\">lineWidth</span>: <span class=\"hljs-number\">0.6</span>,\n    <span class=\"hljs-attr\">lineOpacity</span>: <span class=\"hljs-number\">0.8</span>,\n  },\n  <span class=\"hljs-attr\">label</span>: {\n    <span class=\"hljs-attr\">field</span>: <span class=\"hljs-string\">\"name\"</span>,\n    <span class=\"hljs-attr\">style</span>: { <span class=\"hljs-attr\">fill</span>: <span class=\"hljs-string\">\"#000\"</span>, <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-attr\">stroke</span>: <span class=\"hljs-string\">\"#fff\"</span>, <span class=\"hljs-attr\">strokeWidth</span>: <span class=\"hljs-number\">2</span> },\n  },\n  <span class=\"hljs-attr\">state</span>: { <span class=\"hljs-attr\">active</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">select</span>: <span class=\"hljs-literal\">false</span> },\n  <span class=\"hljs-attr\">tooltip</span>: {\n    <span class=\"hljs-attr\">items</span>: [\n      { <span class=\"hljs-attr\">field</span>: <span class=\"hljs-string\">\"name\"</span> },\n      { <span class=\"hljs-attr\">field</span>: <span class=\"hljs-string\">\"philosopherSum\"</span> },\n      {\n        <span class=\"hljs-attr\">field</span>: <span class=\"hljs-string\">\"philosophers\"</span>,\n        <span class=\"hljs-attr\">customValue</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">value</span>) =&gt;</span>\n          value\n            .<span class=\"hljs-title function_\">map</span>(\n              <span class=\"hljs-function\">(<span class=\"hljs-params\">item</span>) =&gt;</span>\n                <span class=\"hljs-string\">`name: <span class=\"hljs-subst\">${item.name}</span>, lifespan: <span class=\"hljs-subst\">${item.lifespan.join(<span class=\"hljs-string\">\"~\"</span>)}</span>`</span>\n            )\n            .<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">\";\"</span>),\n      },\n    ],\n  },\n  <span class=\"hljs-attr\">zoom</span>: { <span class=\"hljs-attr\">position</span>: <span class=\"hljs-string\">\"bottomright\"</span> },\n  <span class=\"hljs-attr\">legend</span>: { <span class=\"hljs-attr\">position</span>: <span class=\"hljs-string\">\"bottomleft\"</span> },\n});\n\n<span class=\"hljs-comment\">// 3. 按时间递增顺序渲染更新区域变化图</span>\n<span class=\"hljs-keyword\">let</span> currentGroupIndex = <span class=\"hljs-number\">0</span>;\nchinaMap.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">\"loaded\"</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  <span class=\"hljs-keyword\">const</span> geoPhilosophers = <span class=\"hljs-title function_\">joinData</span>(\n    philosopherGroups[currentGroupIndex],\n    countrys\n  );\n  chinaMap.<span class=\"hljs-title function_\">changeData</span>(geoPhilosophers);\n});\nchinaMap.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">\"change-data\"</span>, <span class=\"hljs-function\">() =&gt;</span> {\n  currentGroupIndex =\n    currentGroupIndex === philosopherGroups.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>\n      ? <span class=\"hljs-number\">0</span>\n      : ++currentGroupIndex;\n  <span class=\"hljs-keyword\">const</span> geoPhilosophers = <span class=\"hljs-title function_\">joinData</span>(\n    philosopherGroups[currentGroupIndex],\n    countrys\n  );\n  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n    chinaMap.<span class=\"hljs-title function_\">changeData</span>(geoPhilosophers);\n  }, <span class=\"hljs-number\">1500</span>);\n});\n</code></pre>\n<p>最后绘制出来的效果如下图所示，代码地址 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsparrow-vis%2Fvisualize-sophie-world%2Ftree%2Fmain%2Fexample%2F19\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sparrow-vis/visualize-sophie-world/tree/main/example/19\" ref=\"nofollow noopener noreferrer\">visualize-sophie-world</a>。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th align=\"center\">各个国家的哲学家数量气泡图</th><th align=\"center\">各个国家的哲学家数量区域分布</th><th>以时间顺序哲学区域分布变化</th></tr></thead><tbody><tr><td align=\"center\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b7318d155e440efbab5e9d741e3096a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></td><td align=\"center\"><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd02f15fe13b45688c58230e226a52eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></td><td><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/242be57afb4a4656853dd1151ab57ca3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr></tbody></table>\n<h3 data-id=\"heading-5\">数据洞察</h3>\n<p>从中我们可以获取一些有效信息和洞察：</p>\n<ul>\n<li>哲学家主要集中在欧洲这些国家</li>\n<li>哲学家最多的国家，希腊哲学家最多，意大利次之</li>\n<li>地中海沿岸国家，哲学家比较集中</li>\n<li>随着时间的变化，哲学中心从地中海北部迁移至北海</li>\n</ul>\n<h2 data-id=\"heading-6\">延伸</h2>\n<h3 data-id=\"heading-7\">地理数据可视化库</h3>\n<blockquote>\n<p>开源地理数据可视化库及相关工具类</p>\n</blockquote>\n<p><strong>2/2.5D</strong></p>\n<ul>\n<li>\n<p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fd3%2Fd3-geo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/d3/d3-geo\" ref=\"nofollow noopener noreferrer\">d3-geo</a> <code>图表类</code></p>\n</li>\n<li>\n<p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsgratzl%2Fchartjs-chart-geo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/sgratzl/chartjs-chart-geo\" ref=\"nofollow noopener noreferrer\">Chart.js Geo</a> <code>图表类</code></p>\n</li>\n<li>\n<p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvega%2Fvega\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/vega/vega\" ref=\"nofollow noopener noreferrer\">vega</a> <code>图表类</code></p>\n</li>\n<li>\n<p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fecharts\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/apache/echarts\" ref=\"nofollow noopener noreferrer\">ECharts</a> <code>图表类</code></p>\n</li>\n<li>\n<p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FLeaflet%2FLeaflet\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/Leaflet/Leaflet\" ref=\"nofollow noopener noreferrer\">Leaflet</a></p>\n</li>\n<li>\n<p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fopenlayers%2Fopenlayers\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/openlayers/openlayers\" ref=\"nofollow noopener noreferrer\">OpenLayers</a></p>\n</li>\n<li>\n<p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fhuiyan-fe%2Fmapv\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/huiyan-fe/mapv\" ref=\"nofollow noopener noreferrer\">Mapv</a></p>\n</li>\n<li>\n<p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7\" ref=\"nofollow noopener noreferrer\">L7</a></p>\n</li>\n<li>\n<p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7Plot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7Plot\" ref=\"nofollow noopener noreferrer\">L7Plot</a> <code>图表类</code></p>\n</li>\n</ul>\n<p><strong>3D</strong></p>\n<ul>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmapbox%2Fmapbox-gl-js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/mapbox/mapbox-gl-js\" ref=\"nofollow noopener noreferrer\">Mapbox GL JS</a></li>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCesiumGS%2Fcesium\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/CesiumGS/cesium\" ref=\"nofollow noopener noreferrer\">Cesium</a></li>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvisgl%2Fdeck.gl\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/visgl/deck.gl\" ref=\"nofollow noopener noreferrer\">Deck.gl</a></li>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmaptalks%2Fmaptalks.js\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/maptalks/maptalks.js\" ref=\"nofollow noopener noreferrer\">maptalks.js</a></li>\n</ul>\n<h3 data-id=\"heading-8\">L7、L7Plot 关系</h3>\n<p><strong>L7</strong></p>\n<p>基于 WebGL 的地理空间数据可视化引擎，以图形符号学为理论基础，将抽象复杂的空间数据转化成 2D、3D 符号，通过颜色、大小、体积、纹理等视觉变量实现丰富的可视化表达。在 API 使用语法上跟 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FG2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/G2\" ref=\"nofollow noopener noreferrer\">G2</a> 一样基于图形语法。 与 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FG2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/G2\" ref=\"nofollow noopener noreferrer\">G2</a> 区别： <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7\" ref=\"nofollow noopener noreferrer\">L7</a> 专注于地理空间数据可视分析，<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FG2\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/G2\" ref=\"nofollow noopener noreferrer\">G2</a> 专注于统计图表。它的取名中的 L 代表 Location，7 代表世界七大洲。</p>\n<p><strong>L7Plot</strong></p>\n<p><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7Plot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7Plot\" ref=\"nofollow noopener noreferrer\">L7Plot</a> 基于 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7\" ref=\"nofollow noopener noreferrer\">L7</a> 实现的<strong>开箱即用</strong>地理空间数据可视化图表库，与 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7\" ref=\"nofollow noopener noreferrer\">L7</a> 区别：</p>\n<ul>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7\" ref=\"nofollow noopener noreferrer\">L7</a> 基于图形符号学为理论，以图形语法 API 方式使用，概念较多，实现简单的地理可视化业务需要不少代码量。</li>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7Plot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7Plot\" ref=\"nofollow noopener noreferrer\">L7Plot</a> 专注于专注于地理可视化图表；以声明配置式的方式，降低用户使用成本；以常见地理图表分类的方式，降低用户选择成本；内部集成全国行政区域数据，降低用户使用地理数据心智。</li>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fantvis%2FL7Plot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://github.com/antvis/L7Plot\" ref=\"nofollow noopener noreferrer\">L7Plot</a> L7Plot 专注于地理数据可视化展示，不会涉及数据编辑能力。</li>\n</ul>\n<h2 data-id=\"heading-9\">小结</h2>\n<p>这一章我们完成了：“苏菲的世界中，哲学中心如何变化？”这一个任务。</p>\n<p>到此为止，我们所有的开发和分析任务就都结束了，那么下一章将是我们的最后一章：<strong>看看通过本小册子我们学到了什么，还有什么可以深入学习的东西。</strong></p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    },
    {
        "name": "20\n总结：回顾过去，展望未来\n学习时长: 11分48秒",
        "content": "<div class=\"markdown-body\"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:\"\"}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>《可视化入门：从 0 到 1 开发一个图表库》到这里就快结束了，这一章我们来盘点一下我们学到了什么，还有什么地方是需要改进的。小册子一共分为4大部分：开篇、基础篇、实战篇和分析篇，我们接下来就分别来看看。</p>\n<h2 data-id=\"heading-0\">开篇</h2>\n<p>首先在开篇我们通过下面这两张图认识了数据可视化，知道了数据可视化就是：“<strong>利用人眼的感知能力对数据进行交互的可视表达以增强认知的技术，将不可见或难以直接显示的数据转化为可感知的图形、符号、颜色、 纹理等，增强数据识别效率，传递有效信息。</strong>”</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c6950be1078485a94bbdf8667939fa5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3eb0045335644b59c8a8528197f3e85~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>同时了解到人眼能提高数据分析效率的原因主要有两点：</p>\n<ul>\n<li><strong>在几种感官系统中，视觉系统获得信息是最高效的。</strong></li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe9592d6bc62461198e3cf96a95c84af~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<ul>\n<li><strong>图片可以加速人们查找和识别信息，因为信息会和空间信息相关联。</strong></li>\n</ul>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87ebdfa9cb1a481f8e5663025dff9e14~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>这之后我们知道了不是所有的可视化都是好的，真正好的可视化具有四个特点：<strong>新颖，充实，高效和美感。</strong></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1caa426f7ac47a4aaba715440f1232c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>但是凡事都有例外，信息图过多的装饰能让用户提高参与感、让用户更难忘让它也渐渐进入人们的视线中。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d2a3b1c8a484d3a98bfbe7d48835581~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>最后我们知道了现在是一个大数据时代，分析数据获得信息和知识有助于帮助我们做决策，而数据可视化是其中一个不可替代的手段。</p>\n<p>进一步来讲，数据可视化主要有三大分支：科学可视化、信息可视化和可视分析学，而日常生活中我们接触最多就是信息可视化。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaa9fd0e0b5f4cb38b6c2a2def24bc20~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>信息可视化在工作中的具体场景又会有：基于统计图表的可视化、移动端可视化、图可视化和地理可视化。</p>\n<p>开篇主要让大家大体了解了一下数据可视化，接下来就进入了基础篇。</p>\n<h2 data-id=\"heading-1\">基础篇</h2>\n<p>在基础篇首先是给大家介绍了《Visualization Analysis &amp; Design，Tamara Munzner》提到的数据分析模型：What、Why、How，并且引入了“可视化苏菲的世界”这个任务。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93dab1c5186546a6bd4d84613079477f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>这之后给大家介绍了如何用 Canvas2d 和 SVG 绘制一个条形图，知道了它们的基本使用方法。但同时发现绘制起来过于繁琐，所以准备开发一个小工具 Sparrow 来加快这个过程。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca62d68ad63f45f88208957a0a27b60a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>在开发我们的小工具之前，我们先了解了社区上一些成熟的可视化工具，知道了它们的优点和缺点以及适用的场景。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fff4706e9f6f4c92baf8f726ee1b2608~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>然后确定在“可视化语法”这一层去设计我们的 Sparrow 的 API，并且它的架构如下图。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c79d9edbde94357aed1adc1db0bf7eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>这部分的最后我们根据下图去搭建了 Sparrow 的开发环境。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7f0e9257d6848debd48b226a6dfae5e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-2\">实战篇</h2>\n<p>接下来就进入了实战篇，首先我们基于 SVG 封装了一个<strong>渲染引擎</strong>，用于提高图形元素的管理能力。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2cb1d69390c4588a72ca36606976aac~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>然后学习并且开发了<strong>比例尺</strong>，了解了数据属性是如何映射到视觉属性上的。<strong>比例尺在可视化图表中非常重要，因为它是数据和视觉元素的桥梁。</strong></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bfe0184a30542d48ed3cf2fac7ec3e5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>了解完比例尺，我们学习了<strong>函数形式编程</strong>，知道了它相对于面向对象编程的优势；然后就开发了<strong>坐标系</strong>，其主要用于将归一化的数据转换成画布坐标数据。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acf15a94ecfe4d149943b434c8fceddf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>经过这两章比较抽象的数据处理学习之后，我们进入了直观形象的<strong>几何图形</strong>的学习：首先简单了解了一下视觉编码理论，然后看了看几何图形是如何把处理好的数据绘制成真正的 SVG 元素的。</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cc3dd6db10145669ddcb71c04028c40~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>几何图形之后就进入了<strong>辅助组件</strong>的学习，知道了它们可以加快人们理解几何图形的速度，也知道了它们和比例尺、坐标系之间的关系。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb4b259a27f84f39b2aea04d75b555b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>这之后我们学习了<strong>统计</strong>，了解了统计函数是如何改变几何图形的位置和外观的。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0852cfa07d6449a1870cac2d6a4ef8a8~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>学习完统计我们了解<strong>视图</strong>，看看其是如何绘制多视图和多几何元素的图表的。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9726351c3774cce82962a9304cecec6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<p>最后我们学习了<strong>渲染流程</strong>，把上面的模块串了起来，最后完成了 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fsparrow-vis.github.io%2F%23%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://sparrow-vis.github.io/#/\" ref=\"nofollow noopener noreferrer\">Sparrow</a> 的开发。</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/879e056ccea346e1bca703561b752506~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"\" loading=\"lazy\" class=\"medium-zoom-image\"></p>\n<h2 data-id=\"heading-3\">分析篇</h2>\n<p>实战篇以后我们就进入了分析篇，不忘初心得开始完成我们最开始提出的分析任务。</p>\n<p>对于我们的可视化设计，我们首先都用 Sparrow 去实现，发现总是有可以优化的空间，所以我们也介绍了 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fantv.vision%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://antv.vision/\" ref=\"nofollow noopener noreferrer\">AntV 技术栈</a>的去完成相同的可视化设计。这个过程也接触了 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fd3js.org%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://d3js.org/\" ref=\"nofollow noopener noreferrer\">D3</a> 的一些工具。</p>\n<p>而我们的可视化设计也是涉及了基于<strong>统计图表的可视化</strong>、<strong>图可视化</strong>和<strong>地图可视化。</strong> 下面是我们的一些成果。</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>类型</th><th>Sparrow + D3</th><th>AntV</th></tr></thead><tbody><tr><td>表格</td><td><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b70b52e51ea14613b4319788fe549021~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td><td><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06342994cc2349deb16e396e39f120f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr><tr><td>散点图</td><td><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9a87220bea746c5844b5e0bc8eb0bc3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td><td><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7bfab54d2f54182898de9550a4a3cd0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr><tr><td>词云</td><td><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7086a23f5f104f57ab4a1f8d4a4904a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td><td><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fe881b7cf9e409c86d8509746c24207~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr><tr><td>力导向图</td><td><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c734d44cbb214dff8c6d1a51e699922b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td><td><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96982aa38da342f48fb57976cdaaf5c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr><tr><td>圆形树状图</td><td><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b309e121d642426799f58f33c1a8e3cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td><td><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73855aabf82c4ebeaebc48beac8cf57c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr><tr><td>地图</td><td><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77fb0365cf6444a3afe5a5599b3df301~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td><td><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cc8fffe86864ceb8dc81d43d366fffc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?\" alt=\"image.png\" loading=\"lazy\" class=\"medium-zoom-image\"></td></tr></tbody></table>\n<h2 data-id=\"heading-4\">总结</h2>\n<p>总的来说，这次可视化之旅还是很有意思的，我们理论和实战结合地去认识了数据可视化。</p>\n<p>当然，最重要的是：我们收获了一个基于图形语法的可视化库，虽然它不具备动画和交互能力，但是它已经帮助我们做了最重要的事情：<strong>把数据映射为视觉元素</strong>。</p>\n<p>小册子到这里就结束了，但数据可视化的学习之旅才开始，强烈推荐大家去阅读下面的几本书和 <a href=\"https://link.juejin.cn?target=https%3A%2F%2Fd3js.org%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://d3js.org/\" ref=\"nofollow noopener noreferrer\">D3</a> 的官网，你将获益匪浅！</p>\n<ul>\n<li><a href=\"https://link.juejin.cn?target=https%3A%2F%2Fd3js.org%2F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://d3js.org/\" ref=\"nofollow noopener noreferrer\">D3</a></li>\n<li>Visualization Analysis &amp; Design，Tamara Munzner</li>\n<li>Beautiful.Visualization，Julie Steele/&nbsp;Noah Iliinsky</li>\n<li>The Grammar of Graphics, 2nd Edition, Leland Wilkinson</li>\n</ul>\n<p>同时还有一点需要说明，在宣传里提到我们团队主要负责 G2 的维护，但是细心的同学可能已经发现： <strong>Sparrow 的 API 设计、代码架构以及渲染流程和 G2 却不太一样！</strong> 这是因为 Sparrow 的设计其实是参考我们团队今年年底将要发布的 G2 5.0 版本。</p>\n<p>G2 5.0 将是一个尽量兼容 4.0 的全新版本，在解决已有问题，提高绘图能力的之外（图形语法、动画语法和交互与发放），它的目标就是<strong>优雅</strong>：优雅的图表、优雅的文档以及优雅的代码！欢迎大家关注<a href=\"https://link.juejin.cn?target=https%3A%2F%2Fwww.yuque.com%2Fantv%2Fg2-docs%2Fabout-g2-5.x\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" title=\"https://www.yuque.com/antv/g2-docs/about-g2-5.x\" ref=\"nofollow noopener noreferrer\">这里</a>，除了了解我们的最新进展，还可以参与贡献。</p>\n<p>我们有一个缺点，缺点优秀的你们，所以到时候不见不散。</p><style>.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style></div>"
    }
]

const fs = require('fs')

const fetch = require("node-fetch");
const stream = require("stream");

async function hasFile (path) {
    return new Promise((resolve) => {
        fs.access(path, (err) => {
            if (err) {
                resolve(false)
            } else {
                resolve(true)
            }
        })
    })
} 

async function getImgReplace(content) {
  const match = content.match(/https:\/\/\S{10,}awebp/g) || [];

  for (let img of match) {
    let imgPath = img.replace("https:/", "").replace(/\//g, "").replace(/:/g, '');
    content = content.replace(img, imgPath);
    const isHasFile = await hasFile(imgPath)
    if (isHasFile) {
        console.log('有了，跳过')
        continue
    }
    const response = await fetch(img);
    stream.pipeline(response.body, fs.createWriteStream(imgPath), (err) => {
      console.log(err);
    });
  }
  return content;
}



totalData.map(async (i) => {
  const index = i.name.split("\n")[0];
  const name = i.name.split("\n")[1];
  const content = await getImgReplace(i.content);
  fs.writeFileSync(
    `./${index}${name}.html`,

    `<!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title></title>
    </head>
    <body>
    ${content}
    </body>
    </html>`
  );
});