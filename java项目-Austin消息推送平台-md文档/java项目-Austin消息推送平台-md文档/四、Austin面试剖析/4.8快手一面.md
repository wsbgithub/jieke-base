# 4.8 快手一面


## 怎么实现的消息隔离
我们接收到请求了以后，会把消息写到Kafka（消息队列），目前我们的做法是给每个渠道的每种类型都使用不同的消费者（group），那自然他们的消费就不会互相影响。

比如，发短信有1000W人，也不会影响到发push通知的2000W人。


## 动态线程池怎么体现动态
简单来说，我们线程池在创建的时候会定义几个比较重要的参数：

- 核心线程数
- 最大线程数
- 阻塞队列的实现类（大小）
- 等等

由于线程池的参数我们可能是无法能根据**动态的场景**进行实时的调整，所以有动态线程池。

顺便在这给大家推荐美团的线程池文章：[https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)，如果没读过这篇文章的，建议都去读下，挺不错的。

现在在Github/Gitee开源的动态线程池轮子，几乎都是根据这篇文章去实现的。具体原因和原理都已经讲清楚了。简单摘录下重点：

**动态调参**：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效

而实现动态现在一般可以借助**分布式配置中心**去干这活（比如Nacos和Apollo），而Austin选择的动态线程池轮子使用的是Apollo实现的。

面试者这段的回答也挺好的，可参考：
> 为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置（线程池监听配置中心修改）。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置


## 怎么感知配置中心的改动

本质上就是用**长连接**实现的，客户端维护与Apollo服务端的长连接，只要有配置变更了，就告知客户端去更新。


## 如果说出了问题，你改动线程池配置的思路是什么

出了问题未必是线程池的配置的问题，首先确保是不是业务或者认为的变动导致问题。

这时候可以以**积压**的问题来做回复；

当出现消息积压的时候，我们的肯定会收到告警（因为一般公司里本身会对消费的进度进行监控），那有了告警了以后我们就可以得出是哪一个渠道的哪种消息在积压中。

得出了哪个渠道的哪种消息在积压我们就可以找正在积压的消息体是什么，通过这一步就能查出是不是在这个时间点上有运营的操作（有可能运营在做活动推送，推了4000W的人群，那这时候的积压是正常的，可以忽略这次的问题）

如果不是运营的活动问题，那这时候就需要去排查是不是调用下发的中间件存在问题，这时候也是去找监控，看各种中间件有无明显的异常。如果有，则及时反馈给中间件的团队去修复。

如果不是中间件的问题，思考自身在近期有没变动改过（大多数的问题都来自于发布变动），如果有，是否可以直接回退原始版本恢复线上的正常运行。

如果不是改动的问题，思考是否需要调整线程池的参数/服务器配置，进而提高消费的能力（系统持续的运行，消费端的正常处理下，很少由于这个


> 原文: <https://www.yuque.com/u37247843/dg9569/dfawyu2gg4zt1g4y>