# 4.4 xx科技 一面


## 项目背景和下发渠道有哪些？
**业务的角度**：项目背景可以根据自身的情况来聊聊，说明为什么会产生出这个项目，只要能说得通就没问题。
**技术的角度**：由于下发消息的需求太常见了，邮件/短信/微信服务号/小程序/钉钉/企业微信/push等等这些消息在生产环境下都是有需求去下发的。所以，建设一个**消息推送平台**去下发消息是很正常又很合理的（不然每种消息分布在各个系统里，就很难维护了）

**1**、消息推送平台它承接着各种消息类型的推送，比如短信、邮件、小程序、微信公众号、通知栏PUSH、企业微信、钉钉等等。你可以简单理解为：只要发送消息的，就跟它脱不了关系。
**2**、发送的消息主要给两部分用户，一部分是我们站内的真实用户（比如我们给用户发短信验证码），另一部分是我们内网的消息（比如钉钉的工作提醒、群消息助手）


## 怎么保证生产者不重复发送消息，消费者不重复消费消息？、
在消息推送平台里，我是没有**实现生产者不重复发送消息的**，因为没啥必要。

在Kafka里，我印象中生产者会有幂等的姿势，同时比较高版本的Kafka也提供了事务的支持，这或许能一定程度上去避免重复发送消息。但无论是哪种实现，肯定会带来性能的损耗。

消费者不重复消费消息这就得在**消费端自己做幂等的处理**，而在消息推送平台里，我是实现是用Redis做的消息去重功能的。


## 幂等是怎么设计的
我理解下的幂等（去重），由两部分组成：**Key+存储**

像我处理过的业务（订单类），用的是Redis+MySQL唯一索引的方式去做的。唯一key就是**订单Id号+订单状态**。Redis主要做前置的判断，而MySQL做最后的判断（反正最后订单的数据还是会落到数据库里）

消息推送平台里，我们是平台类的去重，为了性能，用的是Redis存储，会根**据不同的业务对Key进行构建**
1、**五分钟相同的文案发送相同的人去重**，key就是 **md5（发送模板ID+接收人+文案内容）。**这里md5主要就是为了减小key的长度
2、**一天内一个用户只能收到某个渠道的消息 N 次**。key就是  **发送人+发送渠道。**这里的key其实并不唯一，因为要根据**次数**进行判断。


## 去重Key是在哪里生成的？如果生产者发了两遍，去重Key会一样吗？

去重Key是在从消息队列拉取消费后**根据要发送的消息体生成的**（线程池内的业务逻辑之一）

如果生产者发了两遍，去重的Key当然会一样了。

## 商家能复用某个消息模板来发送营销消息吗？

可以，但不建议复用某个模板来发送**营销消息**，消息后台会有提供**复制模板**的功能，不会麻烦的。

1、营销消息的推送内容应该是要留存的，如果重复使用模板很可能会将原有的模板内容改掉，运维侧/商家就不太好翻阅以前的记录
2、部分的渠道是支持消息撤回的（比如说站内的IM/钉钉），而消息撤回是目前是基于整个模板去做的，所以很有可能会撤回到之前的内容消息。

从功能上是没问题的，但是**为了维护性**，营销类的消息最好是新建出新的消息模板，或者在原有的模板进行复制（产出新的模板ID）进行消息推送。


## 消费者是从kafka里面拉消息以后，跟线程池怎么配合的？
这块其实就是**线程池**的内容啦。
1):首先会判断运行线程数是否小于corePoolSize，如果小于，则直接创建新的线程执行任务
2):如果大于corePoolSize，判断workQueue阻塞队列是否已满，如果还没满，则将任务放到阻塞队列中
3):如果workQueue阻塞队列已经满了，则判断当前线程数是否大于maximumPoolSize，如果没大于则创建新的线程执行任务
4):如果大于maximumPoolSize，则执行任务拒绝策略（具体就是你自己实现的handler，**而我的实现就是让其等待**）。
所以，说白了就是：如果线程池有线程可以执行，那就会执行Kafka拉取的消息，如果没有线程执行了，那就会把Kafka的消息扔到阻塞队列里，如果阻塞队列也满了，那拉取消息这个过程就会阻塞。

使用线程池的好处就是能够一定程度上提高**消费的吞吐量**，当然也需要对各种参数线程池进行调试（不然发挥不出线程池的作用）


## 动态线程池的消费能力能进行动态调控，解释一下是怎么用的，为了解决一个什么样的问题？动态线程池的实现原理你有了解吗？
简单来说，我们线程池在创建的时候会定义几个比较重要的参数：

- 核心线程数
- 最大线程数
- 阻塞队列的实现类（大小）
- 等等

由于线程池的参数我们可能是无法能根据**动态的场景**进行实时的调整，所以有动态线程池。

顺便在这给大家推荐美团的线程池文章：[https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)，如果没读过这篇文章的，建议都去读下，挺不错的。

现在在Github/Gitee开源的动态线程池轮子，几乎都是根据这篇文章去实现的。具体原因和原理都已经讲清楚了。简单摘录下重点：





> 原文: <https://www.yuque.com/u37247843/dg9569/kbpq4637yiq146yk>